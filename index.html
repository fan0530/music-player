<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon"  href="https://cdn.jsdelivr.net/gh/fan0530/music-player/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>听歌小助手（For Hifini）</title>
    <script type="module" crossorigin>
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
/**
* @vue/shared v3.4.19
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function makeMap(str, expectsLowerCase) {
  const set2 = new Set(str.split(","));
  return expectsLowerCase ? (val) => set2.has(val.toLowerCase()) : (val) => set2.has(val);
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$1 = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$2.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isFunction$1 = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$2 = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return (isObject$2(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn2) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn2(str));
  };
};
const camelizeRE$1 = /-(\w)/g;
const camelize$1 = cacheStringFunction((str) => {
  return str.replace(camelizeRE$1, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction((str) => {
  const s = str ? `on${capitalize(str)}` : ``;
  return s;
});
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value) || isObject$2(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$2(value)) {
    for (const name2 in value) {
      if (value[name2]) {
        res += name2 + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject$2(val) && (val.toString === objectToString || !isFunction$1(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject$2(val) && !isArray(val) && !isPlainObject$1(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a;
  return isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v;
};
/**
* @vue/reactivity v3.4.19
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn2) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn2();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect22, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect22);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn2) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn2);
  }
}
let activeEffect;
class ReactiveEffect {
  constructor(fn2, trigger2, scheduler, scope) {
    this.fn = fn2;
    this.trigger = trigger2;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this._dirtyLevel = 4;
    this._trackId = 0;
    this._runnings = 0;
    this._shouldSchedule = false;
    this._depsLength = 0;
    recordEffectScope(this, scope);
  }
  get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      this._dirtyLevel = 1;
      pauseTracking();
      for (let i = 0; i < this._depsLength; i++) {
        const dep = this.deps[i];
        if (dep.computed) {
          triggerComputed(dep.computed);
          if (this._dirtyLevel >= 4) {
            break;
          }
        }
      }
      if (this._dirtyLevel === 1) {
        this._dirtyLevel = 0;
      }
      resetTracking();
    }
    return this._dirtyLevel >= 4;
  }
  set dirty(v) {
    this._dirtyLevel = v ? 4 : 0;
  }
  run() {
    this._dirtyLevel = 0;
    if (!this.active) {
      return this.fn();
    }
    let lastShouldTrack = shouldTrack;
    let lastEffect = activeEffect;
    try {
      shouldTrack = true;
      activeEffect = this;
      this._runnings++;
      preCleanupEffect(this);
      return this.fn();
    } finally {
      postCleanupEffect(this);
      this._runnings--;
      activeEffect = lastEffect;
      shouldTrack = lastShouldTrack;
    }
  }
  stop() {
    var _a;
    if (this.active) {
      preCleanupEffect(this);
      postCleanupEffect(this);
      (_a = this.onStop) == null ? void 0 : _a.call(this);
      this.active = false;
    }
  }
}
function triggerComputed(computed2) {
  return computed2.value;
}
function preCleanupEffect(effect22) {
  effect22._trackId++;
  effect22._depsLength = 0;
}
function postCleanupEffect(effect22) {
  if (effect22.deps.length > effect22._depsLength) {
    for (let i = effect22._depsLength; i < effect22.deps.length; i++) {
      cleanupDepEffect(effect22.deps[i], effect22);
    }
    effect22.deps.length = effect22._depsLength;
  }
}
function cleanupDepEffect(dep, effect22) {
  const trackId = dep.get(effect22);
  if (trackId !== void 0 && effect22._trackId !== trackId) {
    dep.delete(effect22);
    if (dep.size === 0) {
      dep.cleanup();
    }
  }
}
let shouldTrack = true;
let pauseScheduleStack = 0;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function pauseScheduling() {
  pauseScheduleStack++;
}
function resetScheduling() {
  pauseScheduleStack--;
  while (!pauseScheduleStack && queueEffectSchedulers.length) {
    queueEffectSchedulers.shift()();
  }
}
function trackEffect(effect22, dep, debuggerEventExtraInfo) {
  if (dep.get(effect22) !== effect22._trackId) {
    dep.set(effect22, effect22._trackId);
    const oldDep = effect22.deps[effect22._depsLength];
    if (oldDep !== dep) {
      if (oldDep) {
        cleanupDepEffect(oldDep, effect22);
      }
      effect22.deps[effect22._depsLength++] = dep;
    } else {
      effect22._depsLength++;
    }
  }
}
const queueEffectSchedulers = [];
function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
  pauseScheduling();
  for (const effect22 of dep.keys()) {
    let tracking;
    if (effect22._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect22) === effect22._trackId)) {
      effect22._shouldSchedule || (effect22._shouldSchedule = effect22._dirtyLevel === 0);
      effect22._dirtyLevel = dirtyLevel;
    }
    if (effect22._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect22) === effect22._trackId)) {
      effect22.trigger();
      if ((!effect22._runnings || effect22.allowRecurse) && effect22._dirtyLevel !== 2) {
        effect22._shouldSchedule = false;
        if (effect22.scheduler) {
          queueEffectSchedulers.push(effect22.scheduler);
        }
      }
    }
  }
  resetScheduling();
}
const createDep = (cleanup, computed2) => {
  const dep = /* @__PURE__ */ new Map();
  dep.cleanup = cleanup;
  dep.computed = computed2;
  return dep;
};
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
    }
    trackEffect(
      activeEffect,
      dep
    );
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || !isSymbol(key2) && key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  pauseScheduling();
  for (const dep of deps) {
    if (dep) {
      triggerEffects(
        dep,
        4
      );
    }
  }
  resetScheduling();
}
function getDepFromReactive(object, key) {
  var _a;
  return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      pauseScheduling();
      const res = toRaw(this)[key].apply(this, args);
      resetScheduling();
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty$1(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _shallow = false) {
    this._isReadonly = _isReadonly;
    this._shallow = _shallow;
  }
  get(target, key, receiver) {
    const isReadonly2 = this._isReadonly, shallow = this._shallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the reciever is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$1;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$2(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(shallow = false) {
    super(false, shallow);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (!this._shallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(shallow = false) {
    super(true, shallow);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
  true
);
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$3(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$1(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear$1() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$3(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set: set$1,
    delete: deleteEntry,
    clear: clear$1,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$3(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set: set$1,
    delete: deleteEntry,
    clear: clear$1,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$3(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$3(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(
      method,
      false,
      false
    );
    readonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      false
    );
    shallowInstrumentations2[method] = createIterableMethod(
      method,
      false,
      true
    );
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$2(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (Object.isExtensible(value)) {
    def(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => isObject$2(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$2(value) ? readonly(value) : value;
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this.effect = new ReactiveEffect(
      () => getter(this._value),
      () => triggerRefValue(
        this,
        this.effect._dirtyLevel === 2 ? 2 : 3
      )
    );
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
      triggerRefValue(self2, 4);
    }
    trackRefValue(self2);
    if (self2.effect._dirtyLevel >= 2) {
      triggerRefValue(self2, 2);
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
  get _dirty() {
    return this.effect.dirty;
  }
  set _dirty(v) {
    this.effect.dirty = v;
  }
  // #endregion
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$1(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function trackRefValue(ref2) {
  var _a;
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    trackEffect(
      activeEffect,
      (_a = ref2.dep) != null ? _a : ref2.dep = createDep(
        () => ref2.dep = void 0,
        ref2 instanceof ComputedRefImpl ? ref2 : void 0
      )
    );
  }
}
function triggerRefValue(ref2, dirtyLevel = 4, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    triggerEffects(
      dep,
      dirtyLevel
    );
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this, 4);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function toRefs(object) {
  const ret = isArray(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
/**
* @vue/runtime-core v3.4.19
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack = [];
function warn$1(msg, ...args) {
  pauseTracking();
  const instance2 = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance2 && instance2.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance2,
      11,
      [
        msg + args.join(""),
        instance2 && instance2.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance2, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction$1(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function callWithErrorHandling(fn2, instance2, type, args) {
  try {
    return args ? fn2(...args) : fn2();
  } catch (err) {
    handleError(err, instance2, type);
  }
}
function callWithAsyncErrorHandling(fn2, instance2, type, args) {
  if (isFunction$1(fn2)) {
    const res = callWithErrorHandling(fn2, instance2, type, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance2, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn2.length; i++) {
    values.push(callWithAsyncErrorHandling(fn2[i], instance2, type, args));
  }
  return values;
}
function handleError(err, instance2, type, throwInDev = true) {
  const contextVNode = instance2 ? instance2.vnode : null;
  if (instance2) {
    let cur = instance2.parent;
    const exposedInstance = instance2.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance2.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue$1 = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn2) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
}
function findInsertionIndex(id) {
  let start2 = flushIndex + 1;
  let end2 = queue$1.length;
  while (start2 < end2) {
    const middle = start2 + end2 >>> 1;
    const middleJob = queue$1[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.pre) {
      start2 = middle + 1;
    } else {
      end2 = middle;
    }
  }
  return start2;
}
function queueJob(job) {
  if (!queue$1.length || !queue$1.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue$1.push(job);
    } else {
      queue$1.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue$1.indexOf(job);
  if (i > flushIndex) {
    queue$1.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb,
      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance2, seen, i = isFlushing ? flushIndex + 1 : 0) {
  for (; i < queue$1.length; i++) {
    const cb = queue$1[i];
    if (cb && cb.pre) {
      if (instance2 && cb.id !== instance2.uid) {
        continue;
      }
      queue$1.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId(a) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b) => {
  const diff = getId(a) - getId(b);
  if (diff === 0) {
    if (a.pre && !b.pre)
      return -1;
    if (b.pre && !a.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  queue$1.sort(comparator);
  try {
    for (flushIndex = 0; flushIndex < queue$1.length; flushIndex++) {
      const job = queue$1[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue$1.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue$1.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
function emit(instance2, event, ...rawArgs) {
  if (instance2.isUnmounted)
    return;
  const props = instance2.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => isString(a) ? a.trim() : a);
    }
    if (number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize$1(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance2,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance2.emitted) {
      instance2.emitted = {};
    } else if (instance2.emitted[handlerName]) {
      return;
    }
    instance2.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance2,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$1(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$2(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$1(normalized, raw);
  }
  if (isObject$2(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance2) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance2;
  currentScopeId = instance2 && instance2.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn2;
  if (fn2._n) {
    return fn2;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn2(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance2) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    props,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render,
    renderCache,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance2;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance2);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render.call(
          thisProxy,
          proxyToUse,
          renderCache,
          props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false)
        ;
      result = normalizeVNode(
        render2.length > 1 ? render2(
          props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return attrs;
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render2(
          props,
          null
          /* we know it doesn't need it */
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance2, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDirective(name2) {
  return resolveAsset(DIRECTIVES, name2);
}
function resolveAsset(type, name2, warnMissing = true, maybeSelfReference = false) {
  const instance2 = currentRenderingInstance || currentInstance;
  if (instance2) {
    const Component = instance2.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name2 || selfName === camelize$1(name2) || selfName === capitalize(camelize$1(name2)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance2[type] || Component[type], name2) || // global registration
      resolve(instance2.appContext[type], name2)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name2) {
  return registry && (registry[name2] || registry[camelize$1(name2)] || registry[capitalize(camelize$1(name2))]);
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn2, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn2)) {
      suspense.effects.push(...fn2);
    } else {
      suspense.effects.push(fn2);
    }
  } else {
    queuePostFlushCb(fn2);
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
function watchEffect(effect22, options) {
  return doWatch(effect22, null, options);
}
function watchPostEffect(effect22, options) {
  return doWatch(
    effect22,
    null,
    { flush: "post" }
  );
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, {
  immediate,
  deep,
  flush,
  once,
  onTrack,
  onTrigger
} = EMPTY_OBJ) {
  if (cb && once) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      unwatch();
    };
  }
  const instance2 = currentInstance;
  const reactiveGetter = (source2) => deep === true ? source2 : (
    // for deep: false, only traverse root-level properties
    traverse(source2, deep === false ? 1 : void 0)
  );
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction$1(s)) {
        return callWithErrorHandling(s, instance2, 2);
      } else
        ;
    });
  } else if (isFunction$1(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance2, 2);
    } else {
      getter = () => {
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source,
          instance2,
          3,
          [onCleanup]
        );
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn2) => {
    cleanup = effect22.onStop = () => {
      callWithErrorHandling(fn2, instance2, 4);
      cleanup = effect22.onStop = void 0;
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance2, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect22.active || !effect22.dirty) {
      return;
    }
    if (cb) {
      const newValue = effect22.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance2, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect22.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance2 && instance2.suspense);
  } else {
    job.pre = true;
    if (instance2)
      job.id = instance2.uid;
    scheduler = () => queueJob(job);
  }
  const effect22 = new ReactiveEffect(getter, NOOP, scheduler);
  const scope = getCurrentScope();
  const unwatch = () => {
    effect22.stop();
    if (scope) {
      remove(scope.effects, effect22);
    }
  };
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect22.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(
      effect22.run.bind(effect22),
      instance2 && instance2.suspense
    );
  } else {
    effect22.run();
  }
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$1(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, depth, currentDepth = 0, seen) {
  if (!isObject$2(value) || value["__v_skip"]) {
    return value;
  }
  if (depth && depth > 0) {
    if (currentDepth >= depth) {
      return value;
    }
    currentDepth++;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, depth, currentDepth, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], depth, currentDepth, seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, depth, currentDepth, seen);
    });
  } else if (isPlainObject$1(value)) {
    for (const key in value) {
      traverse(value[key], depth, currentDepth, seen);
    }
  }
  return value;
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance2 = getExposeProxy(currentRenderingInstance) || currentRenderingInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction$1(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance: instance2,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance2, name2) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name2];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance2, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance2 = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        for (const c of children) {
          if (c.type !== Comment) {
            child = c;
            break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance2
      );
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance2.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance2
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance2.update.active !== false) {
              instance2.effect.dirty = true;
              instance2.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance2) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance2,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey] = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el[enterCbKey]) {
        el[enterCbKey](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance2);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? (
    // #7121 ensure get the child component subtree in case
    // it's been replaced during HMR
    vnode.children ? vnode.children[0] : void 0
  ) : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction$1(options) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend$1({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current2 = target;
    while (current2) {
      if (current2.isDeactivated) {
        return;
      }
      current2 = current2.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current2 = target.parent;
    while (current2 && current2.parent) {
      if (isKeepAlive(current2.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current2);
      }
      current2 = current2.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
  "rtg"
);
const onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache && cache[index];
  if (isArray(source) || isString(source)) {
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject$2(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached && cached[i])
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index] = ret;
  }
  return ret;
}
function renderSlot(slots, name2, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name2 !== "default")
      props.name = name2;
    return createVNode("slot", props, fallback && fallback());
  }
  let slot = slots[name2];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(
    Fragment,
    {
      key: props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key || `_${name2}`
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => {
      i.effect.dirty = true;
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance2 }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance2;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance2.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance2, "get", key);
      }
      return publicGetter(instance2);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance2 }, key, value) {
    const { data, setupState, ctx } = instance2;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance2.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance2) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function normalizePropsOrEmits(props) {
  return isArray(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
let shouldCacheAccess = true;
function applyOptions(instance2) {
  const options = resolveMergedOptions(instance2);
  const publicThis = instance2.proxy;
  const ctx = instance2.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance2, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$1(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$2(data))
      ;
    else {
      instance2.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance2, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance2.exposed || (instance2.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance2.exposed) {
      instance2.exposed = {};
    }
  }
  if (render && instance2.render === NOOP) {
    instance2.render = render;
  }
  if (inheritAttrs != null) {
    instance2.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance2.components = components;
  if (directives)
    instance2.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$2(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance2, type) {
  callWithAsyncErrorHandling(
    isArray(hook) ? hook.map((h2) => h2.bind(instance2.proxy)) : hook.bind(instance2.proxy),
    instance2,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction$1(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$1(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$2(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$1(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance2) {
  const base = instance2.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance2.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject$2(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend$1(
      isFunction$1(to) ? to.call(this, this) : to,
      isFunction$1(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend$1(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray(to) && isArray(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend$1(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$1(rootComponent)) {
      rootComponent = extend$1({}, rootComponent);
    }
    if (rootProps != null && !isObject$2(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction$1(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction$1(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else
          ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name2, component) {
        if (!component) {
          return context.components[name2];
        }
        context.components[name2] = component;
        return app;
      },
      directive(name2, directive) {
        if (!directive) {
          return context.directives[name2];
        }
        context.directives[name2] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn2) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn2();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance2 = currentInstance || currentRenderingInstance;
  if (instance2 || currentApp) {
    const provides = instance2 ? instance2.parent == null ? instance2.vnode.appContext && instance2.vnode.appContext.provides : instance2.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance2 && instance2.proxy) : defaultValue;
    } else
      ;
  }
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}
function initProps(instance2, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance2.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance2, rawProps, props, attrs);
  for (const key in instance2.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance2.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance2.type.props) {
      instance2.props = attrs;
    } else {
      instance2.props = props;
    }
  }
  instance2.attrs = attrs;
}
function updateProps(instance2, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance2;
  const rawCurrentProps = toRaw(props);
  const [options] = instance2.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance2.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance2.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize$1(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance2,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance2, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance2,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance2, "set", "$attrs");
  }
}
function setFullProps(instance2, rawProps, props, attrs) {
  const [options, needCastKeys] = instance2.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize$1(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance2.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance2,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance2, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
        const { propsDefaults } = instance2;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance2);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend$1(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$2(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize$1(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize$1(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction$1(opt) ? { type: opt } : extend$1({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$2(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  }
  return false;
}
function getType(ctor) {
  if (ctor === null) {
    return "null";
  }
  if (typeof ctor === "function") {
    return ctor.name || "";
  } else if (typeof ctor === "object") {
    const name2 = ctor.constructor && ctor.constructor.name;
    return name2 || "";
  }
  return "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray(expectedTypes)) {
    return expectedTypes.findIndex((t2) => isSameType(t2, type));
  } else if (isFunction$1(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance2) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction$1(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance2, children) => {
  const normalized = normalizeSlotValue(children);
  instance2.slots.default = () => normalized;
};
const initSlots = (instance2, children) => {
  if (instance2.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance2.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(
        children,
        instance2.slots = {}
      );
    }
  } else {
    instance2.slots = {};
    if (children) {
      normalizeVNodeSlots(instance2, children);
    }
  }
  def(instance2.slots, InternalObjectKey, 1);
};
const updateSlots = (instance2, children, optimized) => {
  const { vnode, slots } = instance2;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend$1(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance2, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref3) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$1(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (hasOwn(setupState, ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                ref3.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref3.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value;
          if (hasOwn(setupState, ref3)) {
            setupState[ref3] = value;
          }
        } else if (_isRef) {
          ref3.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref3, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else
          ;
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(
            el,
            key,
            null,
            props[key],
            namespace,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start2 = 0) => {
    for (let i = start2; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          namespace
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                namespace,
                n1.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el,
        n2,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        namespace
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(
            el,
            key,
            prev,
            next,
            namespace,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent2(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent2 = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance2 = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance2.ctx.renderer = internals;
    }
    {
      setupComponent(instance2);
    }
    if (instance2.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance2, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance2.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance2,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance2 = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance2.asyncDep && !instance2.asyncResolved) {
        updateComponentPreRender(instance2, n2, optimized);
        return;
      } else {
        instance2.next = n2;
        invalidateJob(instance2.update);
        instance2.effect.dirty = true;
        instance2.update();
      }
    } else {
      n2.el = n1.el;
      instance2.vnode = n2;
    }
  };
  const setupRenderEffect = (instance2, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance2.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent } = instance2;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance2, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance2, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance2.subTree = renderComponentRoot(instance2);
            hydrateNode(
              el,
              instance2.subTree,
              instance2,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance2.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance2.subTree = renderComponentRoot(instance2);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance2,
            parentSuspense,
            namespace
          );
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance2.a && queuePostRenderEffect(instance2.a, parentSuspense);
        }
        instance2.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance2;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance2);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance2, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance2.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance2, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance2, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance2, true);
        const nextTree = renderComponentRoot(instance2);
        const prevTree = instance2.subTree;
        instance2.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance2,
          parentSuspense,
          namespace
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance2, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    const effect22 = instance2.effect = new ReactiveEffect(
      componentUpdateFn,
      NOOP,
      () => queueJob(update),
      instance2.scope
      // track it in component's effect scope
    );
    const update = instance2.update = () => {
      if (effect22.dirty) {
        effect22.run();
      }
    };
    update.id = instance2.uid;
    toggleRecurse(instance2, true);
    update();
  };
  const updateComponentPreRender = (instance2, nextVNode, optimized) => {
    nextVNode.component = instance2;
    const prevProps = instance2.vnode.props;
    instance2.vnode = nextVNode;
    instance2.next = null;
    updateProps(instance2, nextVNode.props, prevProps, optimized);
    updateSlots(instance2, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance2);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref3,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs
    } = vnode;
    if (ref3 != null) {
      setRef(ref3, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          optimized,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end2) => {
    let next;
    while (cur !== end2) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end2);
  };
  const unmountComponent = (instance2, parentSuspense, doRemove) => {
    const { bum, scope, update, subTree, um } = instance2;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance2, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance2.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance2.asyncDep && !instance2.asyncResolved && instance2.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
    for (let i = start2; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  let isFlushing2 = false;
  const render = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    if (!isFlushing2) {
      isFlushing2 = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing2 = false;
    }
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent2,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect22, update }, allowed) {
  effect22.allowRecurse = update.allowRecurse = allowed;
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p2[v];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance2) {
  const subComponent = instance2.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        if (namespace === "svg" || isTargetSVG(target)) {
          namespace = "svg";
        } else if (namespace === "mathml" || isTargetMathML(target)) {
          namespace = "mathml";
        }
      }
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
    }
    updateCssVars(n2);
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(
          children[i],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(
          targetNode,
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node = vnode.children[0].el;
    while (node && node !== vnode.targetAnchor) {
      if (node.nodeType === 1)
        node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$2(style)) {
      if (isProxy(style) && !isArray(style)) {
        style = extend$1({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$2(type) ? 4 : isFunction$1(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend$1({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref3, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$1(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance2, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance2, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance2 = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance2.ctx = { _: instance2 };
  }
  instance2.root = parent ? parent.root : instance2;
  instance2.emit = emit.bind(null, instance2);
  if (vnode.ce) {
    vnode.ce(instance2);
  }
  return instance2;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = getGlobalThis();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key]))
      setters = g[key] = [];
    setters.push(setter);
    return (v) => {
      if (setters.length > 1)
        setters.forEach((set2) => set2(v));
      else
        setters[0](v);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v) => currentInstance = v
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v) => isInSSRComponentSetup = v
  );
}
const setCurrentInstance = (instance2) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance2);
  instance2.scope.on();
  return () => {
    instance2.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance2) {
  return instance2.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance2, isSSR = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance2.vnode;
  const isStateful = isStatefulComponent(instance2);
  initProps(instance2, props, isStateful, isSSR);
  initSlots(instance2, children);
  const setupResult = isStateful ? setupStatefulComponent(instance2, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance2, isSSR) {
  const Component = instance2.type;
  instance2.accessCache = /* @__PURE__ */ Object.create(null);
  instance2.proxy = markRaw(new Proxy(instance2.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance2.setupContext = setup.length > 1 ? createSetupContext(instance2) : null;
    const reset = setCurrentInstance(instance2);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup,
      instance2,
      0,
      [
        instance2.props,
        setupContext
      ]
    );
    resetTracking();
    reset();
    if (isPromise$1(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance2, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance2, 0);
        });
      } else {
        instance2.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance2, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance2, isSSR);
  }
}
function handleSetupResult(instance2, setupResult, isSSR) {
  if (isFunction$1(setupResult)) {
    if (instance2.type.__ssrInlineRender) {
      instance2.ssrRender = setupResult;
    } else {
      instance2.render = setupResult;
    }
  } else if (isObject$2(setupResult)) {
    instance2.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance2, isSSR);
}
let compile;
function finishComponentSetup(instance2, isSSR, skipOptions) {
  const Component = instance2.type;
  if (!instance2.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance2).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance2.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$1(
          extend$1(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance2.render = Component.render || NOOP;
  }
  {
    const reset = setCurrentInstance(instance2);
    pauseTracking();
    try {
      applyOptions(instance2);
    } finally {
      resetTracking();
      reset();
    }
  }
}
function getAttrsProxy(instance2) {
  return instance2.attrsProxy || (instance2.attrsProxy = new Proxy(
    instance2.attrs,
    {
      get(target, key) {
        track(instance2, "get", "$attrs");
        return target[key];
      }
    }
  ));
}
function createSetupContext(instance2) {
  const expose = (exposed) => {
    instance2.exposed = exposed || {};
  };
  {
    return {
      get attrs() {
        return getAttrsProxy(instance2);
      },
      slots: instance2.slots,
      emit: instance2.emit,
      expose
    };
  }
}
function getExposeProxy(instance2) {
  if (instance2.exposed) {
    return instance2.exposeProxy || (instance2.exposeProxy = new Proxy(proxyRefs(markRaw(instance2.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance2);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance2, Component, isRoot = false) {
  let name2 = getComponentName(Component);
  if (!name2 && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name2 = match[1];
    }
  }
  if (!name2 && instance2 && instance2.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name2 = inferFromRegistry(
      instance2.components || instance2.parent.type.components
    ) || inferFromRegistry(instance2.appContext.components);
  }
  return name2 ? classify(name2) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction$1(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$2(propsOrChildren) && !isArray(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const version = "3.4.19";
/**
* @vue/runtime-dom v3.4.19
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start2, end2) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start2 && (start2 === end2 || start2.nextSibling)) {
      while (true) {
        parent.insertBefore(start2.cloneNode(true), anchor);
        if (start2 === end2 || !(start2 = start2.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content;
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
Transition.props = /* @__PURE__ */ extend$1(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const callHook = (hook, args = []) => {
  if (isArray(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name: name2 = "v",
    type,
    duration,
    enterFromClass = `${name2}-enter-from`,
    enterActiveClass = `${name2}-enter-active`,
    enterToClass = `${name2}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name2}-leave-from`,
    leaveActiveClass = `${name2}-leave-active`,
    leaveToClass = `${name2}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend$1(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$2(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end2 = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end2();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end2();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  if (s === "auto")
    return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
const vShowOldKey = Symbol("_vod");
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el[vShowOldKey] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue && (el.style.display === el[vShowOldKey] || !value))
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el[vShowOldKey] : "none";
}
const CSS_VAR_TEXT = Symbol("");
function useCssVars(getter) {
  const instance2 = getCurrentInstance();
  if (!instance2) {
    return;
  }
  const updateTeleports = instance2.ut = (vars = getter(instance2.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${instance2.uid}"]`)
    ).forEach((node) => setVarsOnNode(node, vars));
  };
  const setVars = () => {
    const vars = getter(instance2.proxy);
    setVarsOnVNode(instance2.subTree, vars);
    updateTeleports(vars);
  };
  watchPostEffect(setVars);
  onMounted(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance2.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor)
        break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    let cssText = "";
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
      cssText += `--${key}: ${vars[key]};`;
    }
    style[CSS_VAR_TEXT] = cssText;
  }
}
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString(next);
  const currentDisplay = style.display;
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev && !isString(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style, key, "");
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOldKey in el) {
    el[vShowOldKey] = hasControlledDisplay ? style.display : "";
    style.display = currentDisplay;
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name2, val) {
  if (isArray(val)) {
    val.forEach((v) => setStyle(style, name2, v));
  } else {
    if (val == null)
      val = "";
    if (name2.startsWith("--")) {
      style.setProperty(name2, val);
    } else {
      const prefixed = autoPrefix(style, name2);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name2 = camelize$1(rawName);
  if (name2 !== "filter" && name2 in style) {
    return prefixCache[rawName] = name2;
  }
  name2 = capitalize(name2);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name2;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance2) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean = isSpecialBooleanAttr(key);
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    el._value = value;
    const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
    const newValue = value == null ? "" : value;
    if (oldValue !== newValue) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance2 = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name2, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance2);
      addEventListener(el, name2, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name2, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name2) {
  let options;
  if (optionsModifierRE.test(name2)) {
    options = {};
    let m;
    while (m = name2.match(optionsModifierRE)) {
      name2 = name2.slice(0, name2.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name2[2] === ":" ? name2.slice(3) : hyphenate(name2.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance2) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance2,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn2) => (e2) => !e2._stopped && fn2 && fn2(e2));
  } else {
    return value;
  }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(
      el,
      key,
      nextValue,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    );
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction$1(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString(value)) {
    return false;
  }
  return key in el;
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn2, modifiers) => {
  const cache = fn2._withMods || (fn2._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn2(event, ...args);
  });
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn2, modifiers) => {
  const cache = fn2._withKeys || (fn2._withKeys = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
      return fn2(event);
    }
  });
};
const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction$1(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
var isVue2 = false;
/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */
let activePinia;
const setActivePinia = (pinia2) => activePinia = pinia2;
const piniaSymbol = (
  /* istanbul ignore next */
  Symbol()
);
function isPlainObject(o) {
  return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
}
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
function createPinia() {
  const scope = effectScope(true);
  const state = scope.run(() => ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia2 = markRaw({
    install(app) {
      setActivePinia(pinia2);
      {
        pinia2._a = app;
        app.provide(piniaSymbol, pinia2);
        app.config.globalProperties.$pinia = pinia2;
        toBeInstalled.forEach((plugin) => _p.push(plugin));
        toBeInstalled = [];
      }
    },
    use(plugin) {
      if (!this._a && !isVue2) {
        toBeInstalled.push(plugin);
      } else {
        _p.push(plugin);
      }
      return this;
    },
    _p,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state
  });
  return pinia2;
}
const noop$1 = () => {
};
function addSubscription(subscriptions, callback, detached, onCleanup = noop$1) {
  subscriptions.push(callback);
  const removeSubscription = () => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
      onCleanup();
    }
  };
  if (!detached && getCurrentScope()) {
    onScopeDispose(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.slice().forEach((callback) => {
    callback(...args);
  });
}
const fallbackRunWithContext = (fn2) => fn2();
function mergeReactiveObjects(target, patchToApply) {
  if (target instanceof Map && patchToApply instanceof Map) {
    patchToApply.forEach((value, key) => target.set(key, value));
  }
  if (target instanceof Set && patchToApply instanceof Set) {
    patchToApply.forEach(target.add, target);
  }
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key))
      continue;
    const subPatch = patchToApply[key];
    const targetValue = target[key];
    if (isPlainObject(targetValue) && isPlainObject(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
      target[key] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target[key] = subPatch;
    }
  }
  return target;
}
const skipHydrateSymbol = (
  /* istanbul ignore next */
  Symbol()
);
function shouldHydrate(obj) {
  return !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
}
const { assign } = Object;
function isComputed(o) {
  return !!(isRef(o) && o.effect);
}
function createOptionsStore(id, options, pinia2, hot) {
  const { state, actions, getters } = options;
  const initialState = pinia2.state.value[id];
  let store;
  function setup() {
    if (!initialState && true) {
      {
        pinia2.state.value[id] = state ? state() : {};
      }
    }
    const localState = toRefs(pinia2.state.value[id]);
    return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name2) => {
      computedGetters[name2] = markRaw(computed(() => {
        setActivePinia(pinia2);
        const store2 = pinia2._s.get(id);
        return getters[name2].call(store2, store2);
      }));
      return computedGetters;
    }, {}));
  }
  store = createSetupStore(id, setup, options, pinia2, hot, true);
  return store;
}
function createSetupStore($id, setup, options = {}, pinia2, hot, isOptionsStore) {
  let scope;
  const optionsForPlugin = assign({ actions: {} }, options);
  const $subscribeOptions = {
    deep: true
    // flush: 'post',
  };
  let isListening;
  let isSyncListening;
  let subscriptions = [];
  let actionSubscriptions = [];
  let debuggerEvents;
  const initialState = pinia2.state.value[$id];
  if (!isOptionsStore && !initialState && true) {
    {
      pinia2.state.value[$id] = {};
    }
  }
  ref({});
  let activeListener;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia2.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    const myListenerId = activeListener = Symbol();
    nextTick().then(() => {
      if (activeListener === myListenerId) {
        isListening = true;
      }
    });
    isSyncListening = true;
    triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
  }
  const $reset = isOptionsStore ? function $reset2() {
    const { state } = options;
    const newState = state ? state() : {};
    this.$patch(($state) => {
      assign($state, newState);
    });
  } : (
    /* istanbul ignore next */
    noop$1
  );
  function $dispose() {
    scope.stop();
    subscriptions = [];
    actionSubscriptions = [];
    pinia2._s.delete($id);
  }
  function wrapAction(name2, action) {
    return function() {
      setActivePinia(pinia2);
      const args = Array.from(arguments);
      const afterCallbackList = [];
      const onErrorCallbackList = [];
      function after(callback) {
        afterCallbackList.push(callback);
      }
      function onError(callback) {
        onErrorCallbackList.push(callback);
      }
      triggerSubscriptions(actionSubscriptions, {
        args,
        name: name2,
        store,
        after,
        onError
      });
      let ret;
      try {
        ret = action.apply(this && this.$id === $id ? this : store, args);
      } catch (error) {
        triggerSubscriptions(onErrorCallbackList, error);
        throw error;
      }
      if (ret instanceof Promise) {
        return ret.then((value) => {
          triggerSubscriptions(afterCallbackList, value);
          return value;
        }).catch((error) => {
          triggerSubscriptions(onErrorCallbackList, error);
          return Promise.reject(error);
        });
      }
      triggerSubscriptions(afterCallbackList, ret);
      return ret;
    };
  }
  const partialStore = {
    _p: pinia2,
    // _s: scope,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options2 = {}) {
      const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia2.state.value[$id], (state) => {
        if (options2.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id,
            type: MutationType.direct,
            events: debuggerEvents
          }, state);
        }
      }, assign({}, $subscribeOptions, options2)));
      return removeSubscription;
    },
    $dispose
  };
  const store = reactive(partialStore);
  pinia2._s.set($id, store);
  const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
  const setupStore = runWithContext(() => pinia2._e.run(() => (scope = effectScope()).run(setup)));
  for (const key in setupStore) {
    const prop = setupStore[key];
    if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
      if (!isOptionsStore) {
        if (initialState && shouldHydrate(prop)) {
          if (isRef(prop)) {
            prop.value = initialState[key];
          } else {
            mergeReactiveObjects(prop, initialState[key]);
          }
        }
        {
          pinia2.state.value[$id][key] = prop;
        }
      }
    } else if (typeof prop === "function") {
      const actionValue = wrapAction(key, prop);
      {
        setupStore[key] = actionValue;
      }
      optionsForPlugin.actions[key] = prop;
    } else
      ;
  }
  {
    assign(store, setupStore);
    assign(toRaw(store), setupStore);
  }
  Object.defineProperty(store, "$state", {
    get: () => pinia2.state.value[$id],
    set: (state) => {
      $patch(($state) => {
        assign($state, state);
      });
    }
  });
  pinia2._p.forEach((extender) => {
    {
      assign(store, scope.run(() => extender({
        store,
        app: pinia2._a,
        pinia: pinia2,
        options: optionsForPlugin
      })));
    }
  });
  if (initialState && isOptionsStore && options.hydrate) {
    options.hydrate(store.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store;
}
function defineStore(idOrOptions, setup, setupOptions) {
  let id;
  let options;
  const isSetupStore = typeof setup === "function";
  if (typeof idOrOptions === "string") {
    id = idOrOptions;
    options = isSetupStore ? setupOptions : setup;
  } else {
    options = idOrOptions;
    id = idOrOptions.id;
  }
  function useStore(pinia2, hot) {
    const hasContext = hasInjectionContext();
    pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    pinia2 || (hasContext ? inject(piniaSymbol, null) : null);
    if (pinia2)
      setActivePinia(pinia2);
    pinia2 = activePinia;
    if (!pinia2._s.has(id)) {
      if (isSetupStore) {
        createSetupStore(id, setup, options, pinia2);
      } else {
        createOptionsStore(id, options, pinia2);
      }
    }
    const store = pinia2._s.get(id);
    return store;
  }
  useStore.$id = id;
  return useStore;
}
function isObject$1(v) {
  return typeof v === "object" && v !== null;
}
function normalizeOptions(options, factoryOptions) {
  options = isObject$1(options) ? options : /* @__PURE__ */ Object.create(null);
  return new Proxy(options, {
    get(target, key, receiver) {
      if (key === "key")
        return Reflect.get(target, key, receiver);
      return Reflect.get(target, key, receiver) || Reflect.get(factoryOptions, key, receiver);
    }
  });
}
function get$2(state, path) {
  return path.reduce((obj, p2) => {
    return obj == null ? void 0 : obj[p2];
  }, state);
}
function set(state, path, val) {
  return path.slice(0, -1).reduce((obj, p2) => {
    if (/^(__proto__)$/.test(p2))
      return {};
    else
      return obj[p2] = obj[p2] || {};
  }, state)[path[path.length - 1]] = val, state;
}
function pick$1(baseState, paths) {
  return paths.reduce((substate, path) => {
    const pathArray = path.split(".");
    return set(substate, pathArray, get$2(baseState, pathArray));
  }, {});
}
function parsePersistence(factoryOptions, store) {
  return (o) => {
    var _a;
    try {
      const {
        storage = localStorage,
        beforeRestore = void 0,
        afterRestore = void 0,
        serializer = {
          serialize: JSON.stringify,
          deserialize: JSON.parse
        },
        key = store.$id,
        paths = null,
        debug = false
      } = o;
      return {
        storage,
        beforeRestore,
        afterRestore,
        serializer,
        key: ((_a = factoryOptions.key) != null ? _a : (k) => k)(typeof key == "string" ? key : key(store.$id)),
        paths,
        debug
      };
    } catch (e) {
      if (o.debug)
        ;
      return null;
    }
  };
}
function hydrateStore(store, { storage, serializer, key, debug }) {
  try {
    const fromStorage = storage == null ? void 0 : storage.getItem(key);
    if (fromStorage)
      store.$patch(serializer == null ? void 0 : serializer.deserialize(fromStorage));
  } catch (e) {
    if (debug)
      ;
  }
}
function persistState(state, { storage, serializer, key, paths, debug }) {
  try {
    const toStore = Array.isArray(paths) ? pick$1(state, paths) : state;
    storage.setItem(key, serializer.serialize(toStore));
  } catch (e) {
    if (debug)
      ;
  }
}
function createPersistedState(factoryOptions = {}) {
  return (context) => {
    const { auto: auto2 = false } = factoryOptions;
    const {
      options: { persist = auto2 },
      store,
      pinia: pinia2
    } = context;
    if (!persist)
      return;
    if (!(store.$id in pinia2.state.value)) {
      const original_store = pinia2._s.get(store.$id.replace("__hot:", ""));
      if (original_store)
        Promise.resolve().then(() => original_store.$persist());
      return;
    }
    const persistences = (Array.isArray(persist) ? persist.map((p2) => normalizeOptions(p2, factoryOptions)) : [normalizeOptions(persist, factoryOptions)]).map(parsePersistence(factoryOptions, store)).filter(Boolean);
    store.$persist = () => {
      persistences.forEach((persistence) => {
        persistState(store.$state, persistence);
      });
    };
    store.$hydrate = ({ runHooks = true } = {}) => {
      persistences.forEach((persistence) => {
        const { beforeRestore, afterRestore } = persistence;
        if (runHooks)
          beforeRestore == null ? void 0 : beforeRestore(context);
        hydrateStore(store, persistence);
        if (runHooks)
          afterRestore == null ? void 0 : afterRestore(context);
      });
    };
    persistences.forEach((persistence) => {
      const { beforeRestore, afterRestore } = persistence;
      beforeRestore == null ? void 0 : beforeRestore(context);
      hydrateStore(store, persistence);
      afterRestore == null ? void 0 : afterRestore(context);
      store.$subscribe(
        (_mutation, state) => {
          persistState(state, persistence);
        },
        {
          detached: true
        }
      );
    });
  };
}
var src_default = createPersistedState();
function noop() {
}
const extend = Object.assign;
const inBrowser$1 = typeof window !== "undefined";
const isObject = (val) => val !== null && typeof val === "object";
const isDef = (val) => val !== void 0 && val !== null;
const isFunction = (val) => typeof val === "function";
const isPromise = (val) => isObject(val) && isFunction(val.then) && isFunction(val.catch);
const isNumeric = (val) => typeof val === "number" || /^\d+(\.\d+)?$/.test(val);
const isIOS = () => inBrowser$1 ? /ios|iphone|ipad|ipod/.test(navigator.userAgent.toLowerCase()) : false;
function get$1(object, path) {
  const keys = path.split(".");
  let result = object;
  keys.forEach((key) => {
    var _a;
    result = isObject(result) ? (_a = result[key]) != null ? _a : "" : "";
  });
  return result;
}
function pick(obj, keys, ignoreUndefined) {
  return keys.reduce(
    (ret, key) => {
      if (!ignoreUndefined || obj[key] !== void 0) {
        ret[key] = obj[key];
      }
      return ret;
    },
    {}
  );
}
const isSameValue = (newValue, oldValue) => JSON.stringify(newValue) === JSON.stringify(oldValue);
const unknownProp = null;
const numericProp = [Number, String];
const truthProp = {
  type: Boolean,
  default: true
};
const makeArrayProp = () => ({
  type: Array,
  default: () => []
});
const makeNumberProp = (defaultVal) => ({
  type: Number,
  default: defaultVal
});
const makeNumericProp = (defaultVal) => ({
  type: numericProp,
  default: defaultVal
});
const makeStringProp = (defaultVal) => ({
  type: String,
  default: defaultVal
});
var inBrowser = typeof window !== "undefined";
var isWindow = (val) => val === window;
var makeDOMRect = (width2, height2) => ({
  top: 0,
  left: 0,
  right: width2,
  bottom: height2,
  width: width2,
  height: height2
});
var useRect = (elementOrRef) => {
  const element = unref(elementOrRef);
  if (isWindow(element)) {
    const width2 = element.innerWidth;
    const height2 = element.innerHeight;
    return makeDOMRect(width2, height2);
  }
  if (element == null ? void 0 : element.getBoundingClientRect) {
    return element.getBoundingClientRect();
  }
  return makeDOMRect(0, 0);
};
function useParent(key) {
  const parent = inject(key, null);
  if (parent) {
    const instance2 = getCurrentInstance();
    const { link, unlink, internalChildren } = parent;
    link(instance2);
    onUnmounted(() => unlink(instance2));
    const index = computed(() => internalChildren.indexOf(instance2));
    return {
      parent,
      index
    };
  }
  return {
    parent: null,
    index: ref(-1)
  };
}
function flattenVNodes(children) {
  const result = [];
  const traverse2 = (children2) => {
    if (Array.isArray(children2)) {
      children2.forEach((child) => {
        var _a;
        if (isVNode(child)) {
          result.push(child);
          if ((_a = child.component) == null ? void 0 : _a.subTree) {
            result.push(child.component.subTree);
            traverse2(child.component.subTree.children);
          }
          if (child.children) {
            traverse2(child.children);
          }
        }
      });
    }
  };
  traverse2(children);
  return result;
}
var findVNodeIndex = (vnodes, vnode) => {
  const index = vnodes.indexOf(vnode);
  if (index === -1) {
    return vnodes.findIndex(
      (item) => vnode.key !== void 0 && vnode.key !== null && item.type === vnode.type && item.key === vnode.key
    );
  }
  return index;
};
function sortChildren(parent, publicChildren, internalChildren) {
  const vnodes = flattenVNodes(parent.subTree.children);
  internalChildren.sort(
    (a, b) => findVNodeIndex(vnodes, a.vnode) - findVNodeIndex(vnodes, b.vnode)
  );
  const orderedPublicChildren = internalChildren.map((item) => item.proxy);
  publicChildren.sort((a, b) => {
    const indexA = orderedPublicChildren.indexOf(a);
    const indexB = orderedPublicChildren.indexOf(b);
    return indexA - indexB;
  });
}
function useChildren(key) {
  const publicChildren = reactive([]);
  const internalChildren = reactive([]);
  const parent = getCurrentInstance();
  const linkChildren = (value) => {
    const link = (child) => {
      if (child.proxy) {
        internalChildren.push(child);
        publicChildren.push(child.proxy);
        sortChildren(parent, publicChildren, internalChildren);
      }
    };
    const unlink = (child) => {
      const index = internalChildren.indexOf(child);
      publicChildren.splice(index, 1);
      internalChildren.splice(index, 1);
    };
    provide(
      key,
      Object.assign(
        {
          link,
          unlink,
          children: publicChildren,
          internalChildren
        },
        value
      )
    );
  };
  return {
    children: publicChildren,
    linkChildren
  };
}
function onMountedOrActivated(hook) {
  let mounted;
  onMounted(() => {
    hook();
    nextTick(() => {
      mounted = true;
    });
  });
  onActivated(() => {
    if (mounted) {
      hook();
    }
  });
}
function useEventListener(type, listener, options = {}) {
  if (!inBrowser) {
    return;
  }
  const { target = window, passive: passive2 = false, capture = false } = options;
  let cleaned = false;
  let attached;
  const add2 = (target2) => {
    if (cleaned) {
      return;
    }
    const element = unref(target2);
    if (element && !attached) {
      element.addEventListener(type, listener, {
        capture,
        passive: passive2
      });
      attached = true;
    }
  };
  const remove2 = (target2) => {
    if (cleaned) {
      return;
    }
    const element = unref(target2);
    if (element && attached) {
      element.removeEventListener(type, listener, capture);
      attached = false;
    }
  };
  onUnmounted(() => remove2(target));
  onDeactivated(() => remove2(target));
  onMountedOrActivated(() => add2(target));
  let stopWatch;
  if (isRef(target)) {
    stopWatch = watch(target, (val, oldVal) => {
      remove2(oldVal);
      add2(val);
    });
  }
  return () => {
    stopWatch == null ? void 0 : stopWatch();
    remove2(target);
    cleaned = true;
  };
}
function useClickAway(target, listener, options = {}) {
  if (!inBrowser) {
    return;
  }
  const { eventName = "click" } = options;
  const onClick = (event) => {
    const targets = Array.isArray(target) ? target : [target];
    const isClickAway = targets.every((item) => {
      const element = unref(item);
      return element && !element.contains(event.target);
    });
    if (isClickAway) {
      listener(event);
    }
  };
  useEventListener(eventName, onClick, { target: document });
}
var width;
var height;
function useWindowSize() {
  if (!width) {
    width = ref(0);
    height = ref(0);
    if (inBrowser) {
      const update = () => {
        width.value = window.innerWidth;
        height.value = window.innerHeight;
      };
      update();
      window.addEventListener("resize", update, { passive: true });
      window.addEventListener("orientationchange", update, { passive: true });
    }
  }
  return { width, height };
}
var overflowScrollReg = /scroll|auto|overlay/i;
var defaultRoot = inBrowser ? window : void 0;
function isElement$1(node) {
  const ELEMENT_NODE_TYPE = 1;
  return node.tagName !== "HTML" && node.tagName !== "BODY" && node.nodeType === ELEMENT_NODE_TYPE;
}
function getScrollParent$1(el, root = defaultRoot) {
  let node = el;
  while (node && node !== root && isElement$1(node)) {
    const { overflowY } = window.getComputedStyle(node);
    if (overflowScrollReg.test(overflowY)) {
      return node;
    }
    node = node.parentNode;
  }
  return root;
}
var CUSTOM_FIELD_INJECTION_KEY = Symbol("van-field");
function useCustomFieldValue(customValue) {
  const field = inject(CUSTOM_FIELD_INJECTION_KEY, null);
  if (field && !field.customValue.value) {
    field.customValue.value = customValue;
    watch(customValue, () => {
      field.resetValidation();
      field.validateWithTrigger("onChange");
    });
  }
}
isIOS();
const stopPropagation = (event) => event.stopPropagation();
function preventDefault(event, isStopPropagation) {
  if (typeof event.cancelable !== "boolean" || event.cancelable) {
    event.preventDefault();
  }
  if (isStopPropagation) {
    stopPropagation(event);
  }
}
const { width: windowWidth, height: windowHeight } = useWindowSize();
function addUnit(value) {
  if (isDef(value)) {
    return isNumeric(value) ? `${value}px` : String(value);
  }
  return void 0;
}
function getSizeStyle(originSize) {
  if (isDef(originSize)) {
    if (Array.isArray(originSize)) {
      return {
        width: addUnit(originSize[0]),
        height: addUnit(originSize[1])
      };
    }
    const size2 = addUnit(originSize);
    return {
      width: size2,
      height: size2
    };
  }
}
function getZIndexStyle(zIndex) {
  const style = {};
  if (zIndex !== void 0) {
    style.zIndex = +zIndex;
  }
  return style;
}
const camelizeRE = /-(\w)/g;
const camelize = (str) => str.replace(camelizeRE, (_, c) => c.toUpperCase());
const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
function addNumber(num1, num2) {
  const cardinal = 10 ** 10;
  return Math.round((num1 + num2) * cardinal) / cardinal;
}
const { hasOwnProperty } = Object.prototype;
function assignKey(to, from, key) {
  const val = from[key];
  if (!isDef(val)) {
    return;
  }
  if (!hasOwnProperty.call(to, key) || !isObject(val)) {
    to[key] = val;
  } else {
    to[key] = deepAssign(Object(to[key]), val);
  }
}
function deepAssign(to, from) {
  Object.keys(from).forEach((key) => {
    assignKey(to, from, key);
  });
  return to;
}
var stdin_default$f = {
  name: "姓名",
  tel: "电话",
  save: "保存",
  clear: "清空",
  cancel: "取消",
  confirm: "确认",
  delete: "删除",
  loading: "加载中...",
  noCoupon: "暂无优惠券",
  nameEmpty: "请填写姓名",
  addContact: "添加联系人",
  telInvalid: "请填写正确的电话",
  vanCalendar: {
    end: "结束",
    start: "开始",
    title: "日期选择",
    weekdays: ["日", "一", "二", "三", "四", "五", "六"],
    monthTitle: (year, month) => `${year}年${month}月`,
    rangePrompt: (maxRange) => `最多选择 ${maxRange} 天`
  },
  vanCascader: {
    select: "请选择"
  },
  vanPagination: {
    prev: "上一页",
    next: "下一页"
  },
  vanPullRefresh: {
    pulling: "下拉即可刷新...",
    loosing: "释放即可刷新..."
  },
  vanSubmitBar: {
    label: "合计:"
  },
  vanCoupon: {
    unlimited: "无门槛",
    discount: (discount) => `${discount}折`,
    condition: (condition) => `满${condition}元可用`
  },
  vanCouponCell: {
    title: "优惠券",
    count: (count) => `${count}张可用`
  },
  vanCouponList: {
    exchange: "兑换",
    close: "不使用",
    enable: "可用",
    disabled: "不可用",
    placeholder: "输入优惠码"
  },
  vanAddressEdit: {
    area: "地区",
    areaEmpty: "请选择地区",
    addressEmpty: "请填写详细地址",
    addressDetail: "详细地址",
    defaultAddress: "设为默认收货地址"
  },
  vanAddressList: {
    add: "新增地址"
  }
};
const lang = ref("zh-CN");
const messages = reactive({
  "zh-CN": stdin_default$f
});
const Locale = {
  messages() {
    return messages[lang.value];
  },
  use(newLang, newMessages) {
    lang.value = newLang;
    this.add({ [newLang]: newMessages });
  },
  add(newMessages = {}) {
    deepAssign(messages, newMessages);
  }
};
var stdin_default$e = Locale;
function createTranslate(name2) {
  const prefix = camelize(name2) + ".";
  return (path, ...args) => {
    const messages2 = stdin_default$e.messages();
    const message = get$1(messages2, prefix + path) || get$1(messages2, path);
    return isFunction(message) ? message(...args) : message;
  };
}
function genBem(name2, mods) {
  if (!mods) {
    return "";
  }
  if (typeof mods === "string") {
    return ` ${name2}--${mods}`;
  }
  if (Array.isArray(mods)) {
    return mods.reduce(
      (ret, item) => ret + genBem(name2, item),
      ""
    );
  }
  return Object.keys(mods).reduce(
    (ret, key) => ret + (mods[key] ? genBem(name2, key) : ""),
    ""
  );
}
function createBEM(name2) {
  return (el, mods) => {
    if (el && typeof el !== "string") {
      mods = el;
      el = "";
    }
    el = el ? `${name2}__${el}` : name2;
    return `${el}${genBem(el, mods)}`;
  };
}
function createNamespace(name2) {
  const prefixedName = `van-${name2}`;
  return [
    prefixedName,
    createBEM(prefixedName),
    createTranslate(prefixedName)
  ];
}
const BORDER = "van-hairline";
const BORDER_TOP = `${BORDER}--top`;
const BORDER_LEFT = `${BORDER}--left`;
const BORDER_RIGHT = `${BORDER}--right`;
const BORDER_BOTTOM = `${BORDER}--bottom`;
const BORDER_SURROUND = `${BORDER}--surround`;
const HAPTICS_FEEDBACK = "van-haptics-feedback";
const TAP_OFFSET = 5;
function callInterceptor(interceptor, {
  args = [],
  done,
  canceled,
  error
}) {
  if (interceptor) {
    const returnVal = interceptor.apply(null, args);
    if (isPromise(returnVal)) {
      returnVal.then((value) => {
        if (value) {
          done();
        } else if (canceled) {
          canceled();
        }
      }).catch(error || noop);
    } else if (returnVal) {
      done();
    } else if (canceled) {
      canceled();
    }
  } else {
    done();
  }
}
function withInstall(options) {
  options.install = (app) => {
    const { name: name2 } = options;
    if (name2) {
      app.component(name2, options);
      app.component(camelize(`-${name2}`), options);
    }
  };
  return options;
}
const POPUP_TOGGLE_KEY = Symbol();
function onPopupReopen(callback) {
  const popupToggleStatus = inject(POPUP_TOGGLE_KEY, null);
  if (popupToggleStatus) {
    watch(popupToggleStatus, (show) => {
      if (show) {
        callback();
      }
    });
  }
}
const useHeight = (element, withSafeArea) => {
  const height2 = ref();
  const setHeight = () => {
    height2.value = useRect(element).height;
  };
  onMounted(() => {
    nextTick(setHeight);
    if (withSafeArea) {
      for (let i = 1; i <= 3; i++) {
        setTimeout(setHeight, 100 * i);
      }
    }
  });
  onPopupReopen(() => nextTick(setHeight));
  watch([windowWidth, windowHeight], setHeight);
  return height2;
};
function usePlaceholder(contentRef, bem2) {
  const height2 = useHeight(contentRef, true);
  return (renderContent) => createVNode("div", {
    "class": bem2("placeholder"),
    "style": {
      height: height2.value ? `${height2.value}px` : void 0
    }
  }, [renderContent()]);
}
const [name$e, bem$e] = createNamespace("action-bar");
const ACTION_BAR_KEY = Symbol(name$e);
const actionBarProps = {
  placeholder: Boolean,
  safeAreaInsetBottom: truthProp
};
var stdin_default$d = /* @__PURE__ */ defineComponent({
  name: name$e,
  props: actionBarProps,
  setup(props, {
    slots
  }) {
    const root = ref();
    const renderPlaceholder = usePlaceholder(root, bem$e);
    const {
      linkChildren
    } = useChildren(ACTION_BAR_KEY);
    linkChildren();
    const renderActionBar = () => {
      var _a;
      return createVNode("div", {
        "ref": root,
        "class": [bem$e(), {
          "van-safe-area-bottom": props.safeAreaInsetBottom
        }]
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
    return () => {
      if (props.placeholder) {
        return renderPlaceholder(renderActionBar);
      }
      return renderActionBar();
    };
  }
});
const ActionBar = withInstall(stdin_default$d);
function useExpose(apis) {
  const instance2 = getCurrentInstance();
  if (instance2) {
    extend(instance2.proxy, apis);
  }
}
const routeProps = {
  to: [String, Object],
  url: String,
  replace: Boolean
};
function route({
  to,
  url,
  replace,
  $router: router
}) {
  if (to && router) {
    router[replace ? "replace" : "push"](to);
  } else if (url) {
    replace ? location.replace(url) : location.href = url;
  }
}
function useRoute() {
  const vm = getCurrentInstance().proxy;
  return () => route(vm);
}
const [name$d, bem$d] = createNamespace("badge");
const badgeProps = {
  dot: Boolean,
  max: numericProp,
  tag: makeStringProp("div"),
  color: String,
  offset: Array,
  content: numericProp,
  showZero: truthProp,
  position: makeStringProp("top-right")
};
var stdin_default$c = /* @__PURE__ */ defineComponent({
  name: name$d,
  props: badgeProps,
  setup(props, {
    slots
  }) {
    const hasContent = () => {
      if (slots.content) {
        return true;
      }
      const {
        content,
        showZero
      } = props;
      return isDef(content) && content !== "" && (showZero || content !== 0 && content !== "0");
    };
    const renderContent = () => {
      const {
        dot,
        max,
        content
      } = props;
      if (!dot && hasContent()) {
        if (slots.content) {
          return slots.content();
        }
        if (isDef(max) && isNumeric(content) && +content > +max) {
          return `${max}+`;
        }
        return content;
      }
    };
    const getOffsetWithMinusString = (val) => val.startsWith("-") ? val.replace("-", "") : `-${val}`;
    const style = computed(() => {
      const style2 = {
        background: props.color
      };
      if (props.offset) {
        const [x, y] = props.offset;
        const {
          position
        } = props;
        const [offsetY, offsetX] = position.split("-");
        if (slots.default) {
          if (typeof y === "number") {
            style2[offsetY] = addUnit(offsetY === "top" ? y : -y);
          } else {
            style2[offsetY] = offsetY === "top" ? addUnit(y) : getOffsetWithMinusString(y);
          }
          if (typeof x === "number") {
            style2[offsetX] = addUnit(offsetX === "left" ? x : -x);
          } else {
            style2[offsetX] = offsetX === "left" ? addUnit(x) : getOffsetWithMinusString(x);
          }
        } else {
          style2.marginTop = addUnit(y);
          style2.marginLeft = addUnit(x);
        }
      }
      return style2;
    });
    const renderBadge = () => {
      if (hasContent() || props.dot) {
        return createVNode("div", {
          "class": bem$d([props.position, {
            dot: props.dot,
            fixed: !!slots.default
          }]),
          "style": style.value
        }, [renderContent()]);
      }
    };
    return () => {
      if (slots.default) {
        const {
          tag
        } = props;
        return createVNode(tag, {
          "class": bem$d("wrapper")
        }, {
          default: () => [slots.default(), renderBadge()]
        });
      }
      return renderBadge();
    };
  }
});
const Badge = withInstall(stdin_default$c);
let globalZIndex = 2e3;
const useGlobalZIndex = () => ++globalZIndex;
const [name$c, bem$c] = createNamespace("config-provider");
const CONFIG_PROVIDER_KEY = Symbol(name$c);
const [name$b, bem$b] = createNamespace("icon");
const isImage = (name2) => name2 == null ? void 0 : name2.includes("/");
const iconProps = {
  dot: Boolean,
  tag: makeStringProp("i"),
  name: String,
  size: numericProp,
  badge: numericProp,
  color: String,
  badgeProps: Object,
  classPrefix: String
};
var stdin_default$b = /* @__PURE__ */ defineComponent({
  name: name$b,
  props: iconProps,
  setup(props, {
    slots
  }) {
    const config = inject(CONFIG_PROVIDER_KEY, null);
    const classPrefix = computed(() => props.classPrefix || (config == null ? void 0 : config.iconPrefix) || bem$b());
    return () => {
      const {
        tag,
        dot,
        name: name2,
        size: size2,
        badge,
        color
      } = props;
      const isImageIcon = isImage(name2);
      return createVNode(Badge, mergeProps({
        "dot": dot,
        "tag": tag,
        "class": [classPrefix.value, isImageIcon ? "" : `${classPrefix.value}-${name2}`],
        "style": {
          color,
          fontSize: addUnit(size2)
        },
        "content": badge
      }, props.badgeProps), {
        default: () => {
          var _a;
          return [(_a = slots.default) == null ? void 0 : _a.call(slots), isImageIcon && createVNode("img", {
            "class": bem$b("image"),
            "src": name2
          }, null)];
        }
      });
    };
  }
});
const Icon = withInstall(stdin_default$b);
const [name$a, bem$a] = createNamespace("loading");
const SpinIcon = Array(12).fill(null).map((_, index) => createVNode("i", {
  "class": bem$a("line", String(index + 1))
}, null));
const CircularIcon = createVNode("svg", {
  "class": bem$a("circular"),
  "viewBox": "25 25 50 50"
}, [createVNode("circle", {
  "cx": "50",
  "cy": "50",
  "r": "20",
  "fill": "none"
}, null)]);
const loadingProps = {
  size: numericProp,
  type: makeStringProp("circular"),
  color: String,
  vertical: Boolean,
  textSize: numericProp,
  textColor: String
};
var stdin_default$a = /* @__PURE__ */ defineComponent({
  name: name$a,
  props: loadingProps,
  setup(props, {
    slots
  }) {
    const spinnerStyle = computed(() => extend({
      color: props.color
    }, getSizeStyle(props.size)));
    const renderIcon = () => {
      const DefaultIcon = props.type === "spinner" ? SpinIcon : CircularIcon;
      return createVNode("span", {
        "class": bem$a("spinner", props.type),
        "style": spinnerStyle.value
      }, [slots.icon ? slots.icon() : DefaultIcon]);
    };
    const renderText = () => {
      var _a;
      if (slots.default) {
        return createVNode("span", {
          "class": bem$a("text"),
          "style": {
            fontSize: addUnit(props.textSize),
            color: (_a = props.textColor) != null ? _a : props.color
          }
        }, [slots.default()]);
      }
    };
    return () => {
      const {
        type,
        vertical
      } = props;
      return createVNode("div", {
        "class": bem$a([type, {
          vertical
        }]),
        "aria-live": "polite",
        "aria-busy": true
      }, [renderIcon(), renderText()]);
    };
  }
});
const Loading = withInstall(stdin_default$a);
const [name$9, bem$9] = createNamespace("button");
const buttonProps = extend({}, routeProps, {
  tag: makeStringProp("button"),
  text: String,
  icon: String,
  type: makeStringProp("default"),
  size: makeStringProp("normal"),
  color: String,
  block: Boolean,
  plain: Boolean,
  round: Boolean,
  square: Boolean,
  loading: Boolean,
  hairline: Boolean,
  disabled: Boolean,
  iconPrefix: String,
  nativeType: makeStringProp("button"),
  loadingSize: numericProp,
  loadingText: String,
  loadingType: String,
  iconPosition: makeStringProp("left")
});
var stdin_default$9 = /* @__PURE__ */ defineComponent({
  name: name$9,
  props: buttonProps,
  emits: ["click"],
  setup(props, {
    emit: emit2,
    slots
  }) {
    const route2 = useRoute();
    const renderLoadingIcon = () => {
      if (slots.loading) {
        return slots.loading();
      }
      return createVNode(Loading, {
        "size": props.loadingSize,
        "type": props.loadingType,
        "class": bem$9("loading")
      }, null);
    };
    const renderIcon = () => {
      if (props.loading) {
        return renderLoadingIcon();
      }
      if (slots.icon) {
        return createVNode("div", {
          "class": bem$9("icon")
        }, [slots.icon()]);
      }
      if (props.icon) {
        return createVNode(Icon, {
          "name": props.icon,
          "class": bem$9("icon"),
          "classPrefix": props.iconPrefix
        }, null);
      }
    };
    const renderText = () => {
      let text;
      if (props.loading) {
        text = props.loadingText;
      } else {
        text = slots.default ? slots.default() : props.text;
      }
      if (text) {
        return createVNode("span", {
          "class": bem$9("text")
        }, [text]);
      }
    };
    const getStyle = () => {
      const {
        color,
        plain
      } = props;
      if (color) {
        const style = {
          color: plain ? color : "white"
        };
        if (!plain) {
          style.background = color;
        }
        if (color.includes("gradient")) {
          style.border = 0;
        } else {
          style.borderColor = color;
        }
        return style;
      }
    };
    const onClick = (event) => {
      if (props.loading) {
        preventDefault(event);
      } else if (!props.disabled) {
        emit2("click", event);
        route2();
      }
    };
    return () => {
      const {
        tag,
        type,
        size: size2,
        block,
        round: round2,
        plain,
        square,
        loading,
        disabled,
        hairline,
        nativeType,
        iconPosition
      } = props;
      const classes = [bem$9([type, size2, {
        plain,
        block,
        round: round2,
        square,
        loading,
        disabled,
        hairline
      }]), {
        [BORDER_SURROUND]: hairline
      }];
      return createVNode(tag, {
        "type": nativeType,
        "class": classes,
        "style": getStyle(),
        "disabled": disabled,
        "onClick": onClick
      }, {
        default: () => [createVNode("div", {
          "class": bem$9("content")
        }, [iconPosition === "left" && renderIcon(), renderText(), iconPosition === "right" && renderIcon()])]
      });
    };
  }
});
const Button = withInstall(stdin_default$9);
const [name$8, bem$8] = createNamespace("action-bar-button");
const actionBarButtonProps = extend({}, routeProps, {
  type: String,
  text: String,
  icon: String,
  color: String,
  loading: Boolean,
  disabled: Boolean
});
var stdin_default$8 = /* @__PURE__ */ defineComponent({
  name: name$8,
  props: actionBarButtonProps,
  setup(props, {
    slots
  }) {
    const route2 = useRoute();
    const {
      parent,
      index
    } = useParent(ACTION_BAR_KEY);
    const isFirst = computed(() => {
      if (parent) {
        const prev = parent.children[index.value - 1];
        return !(prev && "isButton" in prev);
      }
    });
    const isLast = computed(() => {
      if (parent) {
        const next = parent.children[index.value + 1];
        return !(next && "isButton" in next);
      }
    });
    useExpose({
      isButton: true
    });
    return () => {
      const {
        type,
        icon,
        text,
        color,
        loading,
        disabled
      } = props;
      return createVNode(Button, {
        "class": bem$8([type, {
          last: isLast.value,
          first: isFirst.value
        }]),
        "size": "large",
        "type": type,
        "icon": icon,
        "color": color,
        "loading": loading,
        "disabled": disabled,
        "onClick": route2
      }, {
        default: () => [slots.default ? slots.default() : text]
      });
    };
  }
});
const ActionBarButton = withInstall(stdin_default$8);
const popupSharedProps = {
  // whether to show popup
  show: Boolean,
  // z-index
  zIndex: numericProp,
  // whether to show overlay
  overlay: truthProp,
  // transition duration
  duration: numericProp,
  // teleport
  teleport: [String, Object],
  // prevent body scroll
  lockScroll: truthProp,
  // whether to lazy render
  lazyRender: truthProp,
  // callback function before close
  beforeClose: Function,
  // overlay custom style
  overlayStyle: Object,
  // overlay custom class name
  overlayClass: unknownProp,
  // Initial rendering animation
  transitionAppear: Boolean,
  // whether to close popup when overlay is clicked
  closeOnClickOverlay: truthProp
};
const popupSharedPropKeys = Object.keys(
  popupSharedProps
);
function getDirection(x, y) {
  if (x > y) {
    return "horizontal";
  }
  if (y > x) {
    return "vertical";
  }
  return "";
}
function useTouch() {
  const startX = ref(0);
  const startY = ref(0);
  const deltaX = ref(0);
  const deltaY = ref(0);
  const offsetX = ref(0);
  const offsetY = ref(0);
  const direction = ref("");
  const isTap = ref(true);
  const isVertical = () => direction.value === "vertical";
  const isHorizontal = () => direction.value === "horizontal";
  const reset = () => {
    deltaX.value = 0;
    deltaY.value = 0;
    offsetX.value = 0;
    offsetY.value = 0;
    direction.value = "";
    isTap.value = true;
  };
  const start2 = (event) => {
    reset();
    startX.value = event.touches[0].clientX;
    startY.value = event.touches[0].clientY;
  };
  const move = (event) => {
    const touch = event.touches[0];
    deltaX.value = (touch.clientX < 0 ? 0 : touch.clientX) - startX.value;
    deltaY.value = touch.clientY - startY.value;
    offsetX.value = Math.abs(deltaX.value);
    offsetY.value = Math.abs(deltaY.value);
    const LOCK_DIRECTION_DISTANCE = 10;
    if (!direction.value || offsetX.value < LOCK_DIRECTION_DISTANCE && offsetY.value < LOCK_DIRECTION_DISTANCE) {
      direction.value = getDirection(offsetX.value, offsetY.value);
    }
    if (isTap.value && (offsetX.value > TAP_OFFSET || offsetY.value > TAP_OFFSET)) {
      isTap.value = false;
    }
  };
  return {
    move,
    start: start2,
    reset,
    startX,
    startY,
    deltaX,
    deltaY,
    offsetX,
    offsetY,
    direction,
    isVertical,
    isHorizontal,
    isTap
  };
}
let totalLockCount = 0;
const BODY_LOCK_CLASS = "van-overflow-hidden";
function useLockScroll(rootRef, shouldLock) {
  const touch = useTouch();
  const DIRECTION_UP = "01";
  const DIRECTION_DOWN = "10";
  const onTouchMove = (event) => {
    touch.move(event);
    const direction = touch.deltaY.value > 0 ? DIRECTION_DOWN : DIRECTION_UP;
    const el = getScrollParent$1(
      event.target,
      rootRef.value
    );
    const { scrollHeight, offsetHeight, scrollTop } = el;
    let status = "11";
    if (scrollTop === 0) {
      status = offsetHeight >= scrollHeight ? "00" : "01";
    } else if (scrollTop + offsetHeight >= scrollHeight) {
      status = "10";
    }
    if (status !== "11" && touch.isVertical() && !(parseInt(status, 2) & parseInt(direction, 2))) {
      preventDefault(event, true);
    }
  };
  const lock = () => {
    document.addEventListener("touchstart", touch.start);
    document.addEventListener("touchmove", onTouchMove, { passive: false });
    if (!totalLockCount) {
      document.body.classList.add(BODY_LOCK_CLASS);
    }
    totalLockCount++;
  };
  const unlock = () => {
    if (totalLockCount) {
      document.removeEventListener("touchstart", touch.start);
      document.removeEventListener("touchmove", onTouchMove);
      totalLockCount--;
      if (!totalLockCount) {
        document.body.classList.remove(BODY_LOCK_CLASS);
      }
    }
  };
  const init = () => shouldLock() && lock();
  const destroy = () => shouldLock() && unlock();
  onMountedOrActivated(init);
  onDeactivated(destroy);
  onBeforeUnmount(destroy);
  watch(shouldLock, (value) => {
    value ? lock() : unlock();
  });
}
function useLazyRender(show) {
  const inited = ref(false);
  watch(
    show,
    (value) => {
      if (value) {
        inited.value = value;
      }
    },
    { immediate: true }
  );
  return (render) => () => inited.value ? render() : null;
}
const useScopeId = () => {
  var _a;
  const { scopeId } = ((_a = getCurrentInstance()) == null ? void 0 : _a.vnode) || {};
  return scopeId ? { [scopeId]: "" } : null;
};
const [name$7, bem$7] = createNamespace("overlay");
const overlayProps = {
  show: Boolean,
  zIndex: numericProp,
  duration: numericProp,
  className: unknownProp,
  lockScroll: truthProp,
  lazyRender: truthProp,
  customStyle: Object
};
var stdin_default$7 = /* @__PURE__ */ defineComponent({
  name: name$7,
  props: overlayProps,
  setup(props, {
    slots
  }) {
    const root = ref();
    const lazyRender = useLazyRender(() => props.show || !props.lazyRender);
    const onTouchMove = (event) => {
      if (props.lockScroll) {
        preventDefault(event, true);
      }
    };
    const renderOverlay = lazyRender(() => {
      var _a;
      const style = extend(getZIndexStyle(props.zIndex), props.customStyle);
      if (isDef(props.duration)) {
        style.animationDuration = `${props.duration}s`;
      }
      return withDirectives(createVNode("div", {
        "ref": root,
        "style": style,
        "class": [bem$7(), props.className]
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]), [[vShow, props.show]]);
    });
    useEventListener("touchmove", onTouchMove, {
      target: root
    });
    return () => createVNode(Transition, {
      "name": "van-fade",
      "appear": true
    }, {
      default: renderOverlay
    });
  }
});
const Overlay = withInstall(stdin_default$7);
const popupProps$1 = extend({}, popupSharedProps, {
  round: Boolean,
  position: makeStringProp("center"),
  closeIcon: makeStringProp("cross"),
  closeable: Boolean,
  transition: String,
  iconPrefix: String,
  closeOnPopstate: Boolean,
  closeIconPosition: makeStringProp("top-right"),
  safeAreaInsetTop: Boolean,
  safeAreaInsetBottom: Boolean
});
const [name$6, bem$6] = createNamespace("popup");
var stdin_default$6 = /* @__PURE__ */ defineComponent({
  name: name$6,
  inheritAttrs: false,
  props: popupProps$1,
  emits: ["open", "close", "opened", "closed", "keydown", "update:show", "clickOverlay", "clickCloseIcon"],
  setup(props, {
    emit: emit2,
    attrs,
    slots
  }) {
    let opened;
    let shouldReopen;
    const zIndex = ref();
    const popupRef = ref();
    const lazyRender = useLazyRender(() => props.show || !props.lazyRender);
    const style = computed(() => {
      const style2 = {
        zIndex: zIndex.value
      };
      if (isDef(props.duration)) {
        const key = props.position === "center" ? "animationDuration" : "transitionDuration";
        style2[key] = `${props.duration}s`;
      }
      return style2;
    });
    const open = () => {
      if (!opened) {
        opened = true;
        zIndex.value = props.zIndex !== void 0 ? +props.zIndex : useGlobalZIndex();
        emit2("open");
      }
    };
    const close = () => {
      if (opened) {
        callInterceptor(props.beforeClose, {
          done() {
            opened = false;
            emit2("close");
            emit2("update:show", false);
          }
        });
      }
    };
    const onClickOverlay = (event) => {
      emit2("clickOverlay", event);
      if (props.closeOnClickOverlay) {
        close();
      }
    };
    const renderOverlay = () => {
      if (props.overlay) {
        return createVNode(Overlay, mergeProps({
          "show": props.show,
          "class": props.overlayClass,
          "zIndex": zIndex.value,
          "duration": props.duration,
          "customStyle": props.overlayStyle,
          "role": props.closeOnClickOverlay ? "button" : void 0,
          "tabindex": props.closeOnClickOverlay ? 0 : void 0
        }, useScopeId(), {
          "onClick": onClickOverlay
        }), {
          default: slots["overlay-content"]
        });
      }
    };
    const onClickCloseIcon = (event) => {
      emit2("clickCloseIcon", event);
      close();
    };
    const renderCloseIcon = () => {
      if (props.closeable) {
        return createVNode(Icon, {
          "role": "button",
          "tabindex": 0,
          "name": props.closeIcon,
          "class": [bem$6("close-icon", props.closeIconPosition), HAPTICS_FEEDBACK],
          "classPrefix": props.iconPrefix,
          "onClick": onClickCloseIcon
        }, null);
      }
    };
    let timer;
    const onOpened = () => {
      if (timer)
        clearTimeout(timer);
      timer = setTimeout(() => {
        emit2("opened");
      });
    };
    const onClosed = () => emit2("closed");
    const onKeydown = (event) => emit2("keydown", event);
    const renderPopup = lazyRender(() => {
      var _a;
      const {
        round: round2,
        position,
        safeAreaInsetTop,
        safeAreaInsetBottom
      } = props;
      return withDirectives(createVNode("div", mergeProps({
        "ref": popupRef,
        "style": style.value,
        "role": "dialog",
        "tabindex": 0,
        "class": [bem$6({
          round: round2,
          [position]: position
        }), {
          "van-safe-area-top": safeAreaInsetTop,
          "van-safe-area-bottom": safeAreaInsetBottom
        }],
        "onKeydown": onKeydown
      }, attrs, useScopeId()), [(_a = slots.default) == null ? void 0 : _a.call(slots), renderCloseIcon()]), [[vShow, props.show]]);
    });
    const renderTransition = () => {
      const {
        position,
        transition,
        transitionAppear
      } = props;
      const name2 = position === "center" ? "van-fade" : `van-popup-slide-${position}`;
      return createVNode(Transition, {
        "name": transition || name2,
        "appear": transitionAppear,
        "onAfterEnter": onOpened,
        "onAfterLeave": onClosed
      }, {
        default: renderPopup
      });
    };
    watch(() => props.show, (show) => {
      if (show && !opened) {
        open();
        if (attrs.tabindex === 0) {
          nextTick(() => {
            var _a;
            (_a = popupRef.value) == null ? void 0 : _a.focus();
          });
        }
      }
      if (!show && opened) {
        opened = false;
        emit2("close");
      }
    });
    useExpose({
      popupRef
    });
    useLockScroll(popupRef, () => props.show && props.lockScroll);
    useEventListener("popstate", () => {
      if (props.closeOnPopstate) {
        close();
        shouldReopen = false;
      }
    });
    onMounted(() => {
      if (props.show) {
        open();
      }
    });
    onActivated(() => {
      if (shouldReopen) {
        emit2("update:show", true);
        shouldReopen = false;
      }
    });
    onDeactivated(() => {
      if (props.show && props.teleport) {
        close();
        shouldReopen = true;
      }
    });
    provide(POPUP_TOGGLE_KEY, () => props.show);
    return () => {
      if (props.teleport) {
        return createVNode(Teleport, {
          "to": props.teleport
        }, {
          default: () => [renderOverlay(), renderTransition()]
        });
      }
      return createVNode(Fragment, null, [renderOverlay(), renderTransition()]);
    };
  }
});
const Popup = withInstall(stdin_default$6);
const useSyncPropRef = (getProp, setProp) => {
  const propRef = ref(getProp());
  watch(getProp, (value) => {
    if (value !== propRef.value) {
      propRef.value = value;
    }
  });
  watch(propRef, (value) => {
    if (value !== getProp()) {
      setProp(value);
    }
  });
  return propRef;
};
let current = 0;
function useId() {
  const vm = getCurrentInstance();
  const { name: name2 = "unknown" } = (vm == null ? void 0 : vm.type) || {};
  return `${name2}-${++current}`;
}
let lockCount = 0;
function lockClick(lock) {
  if (lock) {
    if (!lockCount) {
      document.body.classList.add("van-toast--unclickable");
    }
    lockCount++;
  } else if (lockCount) {
    lockCount--;
    if (!lockCount) {
      document.body.classList.remove("van-toast--unclickable");
    }
  }
}
const [name$5, bem$5] = createNamespace("toast");
const popupInheritProps = ["show", "overlay", "teleport", "transition", "overlayClass", "overlayStyle", "closeOnClickOverlay", "zIndex"];
const toastProps = {
  icon: String,
  show: Boolean,
  type: makeStringProp("text"),
  overlay: Boolean,
  message: numericProp,
  iconSize: numericProp,
  duration: makeNumberProp(2e3),
  position: makeStringProp("middle"),
  teleport: [String, Object],
  wordBreak: String,
  className: unknownProp,
  iconPrefix: String,
  transition: makeStringProp("van-fade"),
  loadingType: String,
  forbidClick: Boolean,
  overlayClass: unknownProp,
  overlayStyle: Object,
  closeOnClick: Boolean,
  closeOnClickOverlay: Boolean,
  zIndex: numericProp
};
var stdin_default$5 = /* @__PURE__ */ defineComponent({
  name: name$5,
  props: toastProps,
  emits: ["update:show"],
  setup(props, {
    emit: emit2,
    slots
  }) {
    let timer;
    let clickable = false;
    const toggleClickable = () => {
      const newValue = props.show && props.forbidClick;
      if (clickable !== newValue) {
        clickable = newValue;
        lockClick(clickable);
      }
    };
    const updateShow = (show) => emit2("update:show", show);
    const onClick = () => {
      if (props.closeOnClick) {
        updateShow(false);
      }
    };
    const clearTimer = () => clearTimeout(timer);
    const renderIcon = () => {
      const {
        icon,
        type,
        iconSize,
        iconPrefix,
        loadingType
      } = props;
      const hasIcon = icon || type === "success" || type === "fail";
      if (hasIcon) {
        return createVNode(Icon, {
          "name": icon || type,
          "size": iconSize,
          "class": bem$5("icon"),
          "classPrefix": iconPrefix
        }, null);
      }
      if (type === "loading") {
        return createVNode(Loading, {
          "class": bem$5("loading"),
          "size": iconSize,
          "type": loadingType
        }, null);
      }
    };
    const renderMessage = () => {
      const {
        type,
        message
      } = props;
      if (slots.message) {
        return createVNode("div", {
          "class": bem$5("text")
        }, [slots.message()]);
      }
      if (isDef(message) && message !== "") {
        return type === "html" ? createVNode("div", {
          "key": 0,
          "class": bem$5("text"),
          "innerHTML": String(message)
        }, null) : createVNode("div", {
          "class": bem$5("text")
        }, [message]);
      }
    };
    watch(() => [props.show, props.forbidClick], toggleClickable);
    watch(() => [props.show, props.type, props.message, props.duration], () => {
      clearTimer();
      if (props.show && props.duration > 0) {
        timer = setTimeout(() => {
          updateShow(false);
        }, props.duration);
      }
    });
    onMounted(toggleClickable);
    onUnmounted(toggleClickable);
    return () => createVNode(Popup, mergeProps({
      "class": [bem$5([props.position, props.wordBreak === "normal" ? "break-normal" : props.wordBreak, {
        [props.type]: !props.icon
      }]), props.className],
      "lockScroll": false,
      "onClick": onClick,
      "onClosed": clearTimer,
      "onUpdate:show": updateShow
    }, pick(props, popupInheritProps)), {
      default: () => [renderIcon(), renderMessage()]
    });
  }
});
function usePopupState() {
  const state = reactive({
    show: false
  });
  const toggle = (show) => {
    state.show = show;
  };
  const open = (props) => {
    extend(state, props, { transitionAppear: true });
    toggle(true);
  };
  const close = () => toggle(false);
  useExpose({ open, close, toggle });
  return {
    open,
    close,
    state,
    toggle
  };
}
function mountComponent(RootComponent) {
  const app = createApp(RootComponent);
  const root = document.createElement("div");
  document.body.appendChild(root);
  return {
    instance: app.mount(root),
    unmount() {
      app.unmount();
      document.body.removeChild(root);
    }
  };
}
const defaultOptions = {
  icon: "",
  type: "text",
  message: "",
  className: "",
  overlay: false,
  onClose: void 0,
  onOpened: void 0,
  duration: 2e3,
  teleport: "body",
  iconSize: void 0,
  iconPrefix: void 0,
  position: "middle",
  transition: "van-fade",
  forbidClick: false,
  loadingType: void 0,
  overlayClass: "",
  overlayStyle: void 0,
  closeOnClick: false,
  closeOnClickOverlay: false
};
let queue = [];
let allowMultiple = false;
let currentOptions$1 = extend({}, defaultOptions);
const defaultOptionsMap = /* @__PURE__ */ new Map();
function parseOptions(message) {
  if (isObject(message)) {
    return message;
  }
  return {
    message
  };
}
function createInstance() {
  const {
    instance: instance2,
    unmount
  } = mountComponent({
    setup() {
      const message = ref("");
      const {
        open,
        state,
        close,
        toggle
      } = usePopupState();
      const onClosed = () => {
      };
      const render = () => {
        const attrs = {
          onClosed,
          "onUpdate:show": toggle
        };
        return createVNode(stdin_default$5, mergeProps(state, attrs), null);
      };
      watch(message, (val) => {
        state.message = val;
      });
      getCurrentInstance().render = render;
      return {
        open,
        close,
        message
      };
    }
  });
  return instance2;
}
function getInstance() {
  if (!queue.length || allowMultiple) {
    const instance2 = createInstance();
    queue.push(instance2);
  }
  return queue[queue.length - 1];
}
function showToast(options = {}) {
  if (!inBrowser$1) {
    return {};
  }
  const toast = getInstance();
  const parsedOptions = parseOptions(options);
  toast.open(extend({}, currentOptions$1, defaultOptionsMap.get(parsedOptions.type || currentOptions$1.type), parsedOptions));
  return toast;
}
const [name$4, bem$4] = createNamespace("image");
const imageProps = {
  src: String,
  alt: String,
  fit: String,
  position: String,
  round: Boolean,
  block: Boolean,
  width: numericProp,
  height: numericProp,
  radius: numericProp,
  lazyLoad: Boolean,
  iconSize: numericProp,
  showError: truthProp,
  errorIcon: makeStringProp("photo-fail"),
  iconPrefix: String,
  showLoading: truthProp,
  loadingIcon: makeStringProp("photo")
};
var stdin_default$4 = /* @__PURE__ */ defineComponent({
  name: name$4,
  props: imageProps,
  emits: ["load", "error"],
  setup(props, {
    emit: emit2,
    slots
  }) {
    const error = ref(false);
    const loading = ref(true);
    const imageRef = ref();
    const {
      $Lazyload
    } = getCurrentInstance().proxy;
    const style = computed(() => {
      const style2 = {
        width: addUnit(props.width),
        height: addUnit(props.height)
      };
      if (isDef(props.radius)) {
        style2.overflow = "hidden";
        style2.borderRadius = addUnit(props.radius);
      }
      return style2;
    });
    watch(() => props.src, () => {
      error.value = false;
      loading.value = true;
    });
    const onLoad = (event) => {
      if (loading.value) {
        loading.value = false;
        emit2("load", event);
      }
    };
    const triggerLoad = () => {
      const loadEvent = new Event("load");
      Object.defineProperty(loadEvent, "target", {
        value: imageRef.value,
        enumerable: true
      });
      onLoad(loadEvent);
    };
    const onError = (event) => {
      error.value = true;
      loading.value = false;
      emit2("error", event);
    };
    const renderIcon = (name2, className, slot) => {
      if (slot) {
        return slot();
      }
      return createVNode(Icon, {
        "name": name2,
        "size": props.iconSize,
        "class": className,
        "classPrefix": props.iconPrefix
      }, null);
    };
    const renderPlaceholder = () => {
      if (loading.value && props.showLoading) {
        return createVNode("div", {
          "class": bem$4("loading")
        }, [renderIcon(props.loadingIcon, bem$4("loading-icon"), slots.loading)]);
      }
      if (error.value && props.showError) {
        return createVNode("div", {
          "class": bem$4("error")
        }, [renderIcon(props.errorIcon, bem$4("error-icon"), slots.error)]);
      }
    };
    const renderImage = () => {
      if (error.value || !props.src) {
        return;
      }
      const attrs = {
        alt: props.alt,
        class: bem$4("img"),
        style: {
          objectFit: props.fit,
          objectPosition: props.position
        }
      };
      if (props.lazyLoad) {
        return withDirectives(createVNode("img", mergeProps({
          "ref": imageRef
        }, attrs), null), [[resolveDirective("lazy"), props.src]]);
      }
      return createVNode("img", mergeProps({
        "ref": imageRef,
        "src": props.src,
        "onLoad": onLoad,
        "onError": onError
      }, attrs), null);
    };
    const onLazyLoaded = ({
      el
    }) => {
      const check = () => {
        if (el === imageRef.value && loading.value) {
          triggerLoad();
        }
      };
      if (imageRef.value) {
        check();
      } else {
        nextTick(check);
      }
    };
    const onLazyLoadError = ({
      el
    }) => {
      if (el === imageRef.value && !error.value) {
        onError();
      }
    };
    if ($Lazyload && inBrowser$1) {
      $Lazyload.$on("loaded", onLazyLoaded);
      $Lazyload.$on("error", onLazyLoadError);
      onBeforeUnmount(() => {
        $Lazyload.$off("loaded", onLazyLoaded);
        $Lazyload.$off("error", onLazyLoadError);
      });
    }
    onMounted(() => {
      nextTick(() => {
        var _a;
        if (((_a = imageRef.value) == null ? void 0 : _a.complete) && !props.lazyLoad) {
          triggerLoad();
        }
      });
    });
    return () => {
      var _a;
      return createVNode("div", {
        "class": bem$4({
          round: props.round,
          block: props.block
        }),
        "style": style.value
      }, [renderImage(), renderPlaceholder(), (_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
const Image = withInstall(stdin_default$4);
const [name$3, bem$3] = createNamespace("empty");
const emptyProps = {
  image: makeStringProp("default"),
  imageSize: [Number, String, Array],
  description: String
};
var stdin_default$3 = /* @__PURE__ */ defineComponent({
  name: name$3,
  props: emptyProps,
  setup(props, {
    slots
  }) {
    const renderDescription = () => {
      const description = slots.description ? slots.description() : props.description;
      if (description) {
        return createVNode("p", {
          "class": bem$3("description")
        }, [description]);
      }
    };
    const renderBottom = () => {
      if (slots.default) {
        return createVNode("div", {
          "class": bem$3("bottom")
        }, [slots.default()]);
      }
    };
    const baseId = useId();
    const getId2 = (num) => `${baseId}-${num}`;
    const getUrlById = (num) => `url(#${getId2(num)})`;
    const renderStop = (color, offset2, opacity) => createVNode("stop", {
      "stop-color": color,
      "offset": `${offset2}%`,
      "stop-opacity": opacity
    }, null);
    const renderStops = (fromColor, toColor) => [renderStop(fromColor, 0), renderStop(toColor, 100)];
    const renderShadow = (id) => [createVNode("defs", null, [createVNode("radialGradient", {
      "id": getId2(id),
      "cx": "50%",
      "cy": "54%",
      "fx": "50%",
      "fy": "54%",
      "r": "297%",
      "gradientTransform": "matrix(-.16 0 0 -.33 .58 .72)"
    }, [renderStop("#EBEDF0", 0), renderStop("#F2F3F5", 100, 0.3)])]), createVNode("ellipse", {
      "fill": getUrlById(id),
      "opacity": ".8",
      "cx": "80",
      "cy": "140",
      "rx": "46",
      "ry": "8"
    }, null)];
    const renderBuilding = () => [createVNode("defs", null, [createVNode("linearGradient", {
      "id": getId2("a"),
      "x1": "64%",
      "y1": "100%",
      "x2": "64%"
    }, [renderStop("#FFF", 0, 0.5), renderStop("#F2F3F5", 100)])]), createVNode("g", {
      "opacity": ".8"
    }, [createVNode("path", {
      "d": "M36 131V53H16v20H2v58h34z",
      "fill": getUrlById("a")
    }, null), createVNode("path", {
      "d": "M123 15h22v14h9v77h-31V15z",
      "fill": getUrlById("a")
    }, null)])];
    const renderCloud = () => [createVNode("defs", null, [createVNode("linearGradient", {
      "id": getId2("b"),
      "x1": "64%",
      "y1": "97%",
      "x2": "64%",
      "y2": "0%"
    }, [renderStop("#F2F3F5", 0, 0.3), renderStop("#F2F3F5", 100)])]), createVNode("g", {
      "opacity": ".8"
    }, [createVNode("path", {
      "d": "M87 6c3 0 7 3 8 6a8 8 0 1 1-1 16H80a7 7 0 0 1-8-6c0-4 3-7 6-7 0-5 4-9 9-9Z",
      "fill": getUrlById("b")
    }, null), createVNode("path", {
      "d": "M19 23c2 0 3 1 4 3 2 0 4 2 4 4a4 4 0 0 1-4 3v1h-7v-1l-1 1c-2 0-3-2-3-4 0-1 1-3 3-3 0-2 2-4 4-4Z",
      "fill": getUrlById("b")
    }, null)])];
    const renderNetwork = () => createVNode("svg", {
      "viewBox": "0 0 160 160"
    }, [createVNode("defs", null, [createVNode("linearGradient", {
      "id": getId2(1),
      "x1": "64%",
      "y1": "100%",
      "x2": "64%"
    }, [renderStop("#FFF", 0, 0.5), renderStop("#F2F3F5", 100)]), createVNode("linearGradient", {
      "id": getId2(2),
      "x1": "50%",
      "x2": "50%",
      "y2": "84%"
    }, [renderStop("#EBEDF0", 0), renderStop("#DCDEE0", 100, 0)]), createVNode("linearGradient", {
      "id": getId2(3),
      "x1": "100%",
      "x2": "100%",
      "y2": "100%"
    }, [renderStops("#EAEDF0", "#DCDEE0")]), createVNode("radialGradient", {
      "id": getId2(4),
      "cx": "50%",
      "cy": "0%",
      "fx": "50%",
      "fy": "0%",
      "r": "100%",
      "gradientTransform": "matrix(0 1 -.54 0 .5 -.5)"
    }, [renderStop("#EBEDF0", 0), renderStop("#FFF", 100, 0)])]), createVNode("g", {
      "fill": "none"
    }, [renderBuilding(), createVNode("path", {
      "fill": getUrlById(4),
      "d": "M0 139h160v21H0z"
    }, null), createVNode("path", {
      "d": "M80 54a7 7 0 0 1 3 13v27l-2 2h-2a2 2 0 0 1-2-2V67a7 7 0 0 1 3-13z",
      "fill": getUrlById(2)
    }, null), createVNode("g", {
      "opacity": ".6",
      "stroke-linecap": "round",
      "stroke-width": "7"
    }, [createVNode("path", {
      "d": "M64 47a19 19 0 0 0-5 13c0 5 2 10 5 13",
      "stroke": getUrlById(3)
    }, null), createVNode("path", {
      "d": "M53 36a34 34 0 0 0 0 48",
      "stroke": getUrlById(3)
    }, null), createVNode("path", {
      "d": "M95 73a19 19 0 0 0 6-13c0-5-2-9-6-13",
      "stroke": getUrlById(3)
    }, null), createVNode("path", {
      "d": "M106 84a34 34 0 0 0 0-48",
      "stroke": getUrlById(3)
    }, null)]), createVNode("g", {
      "transform": "translate(31 105)"
    }, [createVNode("rect", {
      "fill": "#EBEDF0",
      "width": "98",
      "height": "34",
      "rx": "2"
    }, null), createVNode("rect", {
      "fill": "#FFF",
      "x": "9",
      "y": "8",
      "width": "80",
      "height": "18",
      "rx": "1.1"
    }, null), createVNode("rect", {
      "fill": "#EBEDF0",
      "x": "15",
      "y": "12",
      "width": "18",
      "height": "6",
      "rx": "1.1"
    }, null)])])]);
    const renderMaterial = () => createVNode("svg", {
      "viewBox": "0 0 160 160"
    }, [createVNode("defs", null, [createVNode("linearGradient", {
      "x1": "50%",
      "x2": "50%",
      "y2": "100%",
      "id": getId2(5)
    }, [renderStops("#F2F3F5", "#DCDEE0")]), createVNode("linearGradient", {
      "x1": "95%",
      "y1": "48%",
      "x2": "5.5%",
      "y2": "51%",
      "id": getId2(6)
    }, [renderStops("#EAEDF1", "#DCDEE0")]), createVNode("linearGradient", {
      "y1": "45%",
      "x2": "100%",
      "y2": "54%",
      "id": getId2(7)
    }, [renderStops("#EAEDF1", "#DCDEE0")])]), renderBuilding(), renderCloud(), createVNode("g", {
      "transform": "translate(36 50)",
      "fill": "none"
    }, [createVNode("g", {
      "transform": "translate(8)"
    }, [createVNode("rect", {
      "fill": "#EBEDF0",
      "opacity": ".6",
      "x": "38",
      "y": "13",
      "width": "36",
      "height": "53",
      "rx": "2"
    }, null), createVNode("rect", {
      "fill": getUrlById(5),
      "width": "64",
      "height": "66",
      "rx": "2"
    }, null), createVNode("rect", {
      "fill": "#FFF",
      "x": "6",
      "y": "6",
      "width": "52",
      "height": "55",
      "rx": "1"
    }, null), createVNode("g", {
      "transform": "translate(15 17)",
      "fill": getUrlById(6)
    }, [createVNode("rect", {
      "width": "34",
      "height": "6",
      "rx": "1"
    }, null), createVNode("path", {
      "d": "M0 14h34v6H0z"
    }, null), createVNode("rect", {
      "y": "28",
      "width": "34",
      "height": "6",
      "rx": "1"
    }, null)])]), createVNode("rect", {
      "fill": getUrlById(7),
      "y": "61",
      "width": "88",
      "height": "28",
      "rx": "1"
    }, null), createVNode("rect", {
      "fill": "#F7F8FA",
      "x": "29",
      "y": "72",
      "width": "30",
      "height": "6",
      "rx": "1"
    }, null)])]);
    const renderError = () => createVNode("svg", {
      "viewBox": "0 0 160 160"
    }, [createVNode("defs", null, [createVNode("linearGradient", {
      "x1": "50%",
      "x2": "50%",
      "y2": "100%",
      "id": getId2(8)
    }, [renderStops("#EAEDF1", "#DCDEE0")])]), renderBuilding(), renderCloud(), renderShadow("c"), createVNode("path", {
      "d": "m59 60 21 21 21-21h3l9 9v3L92 93l21 21v3l-9 9h-3l-21-21-21 21h-3l-9-9v-3l21-21-21-21v-3l9-9h3Z",
      "fill": getUrlById(8)
    }, null)]);
    const renderSearch = () => createVNode("svg", {
      "viewBox": "0 0 160 160"
    }, [createVNode("defs", null, [createVNode("linearGradient", {
      "x1": "50%",
      "y1": "100%",
      "x2": "50%",
      "id": getId2(9)
    }, [renderStops("#EEE", "#D8D8D8")]), createVNode("linearGradient", {
      "x1": "100%",
      "y1": "50%",
      "y2": "50%",
      "id": getId2(10)
    }, [renderStops("#F2F3F5", "#DCDEE0")]), createVNode("linearGradient", {
      "x1": "50%",
      "x2": "50%",
      "y2": "100%",
      "id": getId2(11)
    }, [renderStops("#F2F3F5", "#DCDEE0")]), createVNode("linearGradient", {
      "x1": "50%",
      "x2": "50%",
      "y2": "100%",
      "id": getId2(12)
    }, [renderStops("#FFF", "#F7F8FA")])]), renderBuilding(), renderCloud(), renderShadow("d"), createVNode("g", {
      "transform": "rotate(-45 113 -4)",
      "fill": "none"
    }, [createVNode("rect", {
      "fill": getUrlById(9),
      "x": "24",
      "y": "52.8",
      "width": "5.8",
      "height": "19",
      "rx": "1"
    }, null), createVNode("rect", {
      "fill": getUrlById(10),
      "x": "22.1",
      "y": "67.3",
      "width": "9.9",
      "height": "28",
      "rx": "1"
    }, null), createVNode("circle", {
      "stroke": getUrlById(11),
      "stroke-width": "8",
      "cx": "27",
      "cy": "27",
      "r": "27"
    }, null), createVNode("circle", {
      "fill": getUrlById(12),
      "cx": "27",
      "cy": "27",
      "r": "16"
    }, null), createVNode("path", {
      "d": "M37 7c-8 0-15 5-16 12",
      "stroke": getUrlById(11),
      "stroke-width": "3",
      "opacity": ".5",
      "stroke-linecap": "round",
      "transform": "rotate(45 29 13)"
    }, null)])]);
    const renderImage = () => {
      var _a;
      if (slots.image) {
        return slots.image();
      }
      const PRESET_IMAGES = {
        error: renderError,
        search: renderSearch,
        network: renderNetwork,
        default: renderMaterial
      };
      return ((_a = PRESET_IMAGES[props.image]) == null ? void 0 : _a.call(PRESET_IMAGES)) || createVNode("img", {
        "src": props.image
      }, null);
    };
    return () => createVNode("div", {
      "class": bem$3()
    }, [createVNode("div", {
      "class": bem$3("image"),
      "style": getSizeStyle(props.imageSize)
    }, [renderImage()]), renderDescription(), renderBottom()]);
  }
});
const Empty = withInstall(stdin_default$3);
const [name$2, bem$2, t] = createNamespace("dialog");
const dialogProps = extend({}, popupSharedProps, {
  title: String,
  theme: String,
  width: numericProp,
  message: [String, Function],
  callback: Function,
  allowHtml: Boolean,
  className: unknownProp,
  transition: makeStringProp("van-dialog-bounce"),
  messageAlign: String,
  closeOnPopstate: truthProp,
  showCancelButton: Boolean,
  cancelButtonText: String,
  cancelButtonColor: String,
  cancelButtonDisabled: Boolean,
  confirmButtonText: String,
  confirmButtonColor: String,
  confirmButtonDisabled: Boolean,
  showConfirmButton: truthProp,
  closeOnClickOverlay: Boolean
});
const popupInheritKeys = [...popupSharedPropKeys, "transition", "closeOnPopstate"];
var stdin_default$2 = /* @__PURE__ */ defineComponent({
  name: name$2,
  props: dialogProps,
  emits: ["confirm", "cancel", "keydown", "update:show"],
  setup(props, {
    emit: emit2,
    slots
  }) {
    const root = ref();
    const loading = reactive({
      confirm: false,
      cancel: false
    });
    const updateShow = (value) => emit2("update:show", value);
    const close = (action) => {
      var _a;
      updateShow(false);
      (_a = props.callback) == null ? void 0 : _a.call(props, action);
    };
    const getActionHandler = (action) => () => {
      if (!props.show) {
        return;
      }
      emit2(action);
      if (props.beforeClose) {
        loading[action] = true;
        callInterceptor(props.beforeClose, {
          args: [action],
          done() {
            close(action);
            loading[action] = false;
          },
          canceled() {
            loading[action] = false;
          }
        });
      } else {
        close(action);
      }
    };
    const onCancel = getActionHandler("cancel");
    const onConfirm = getActionHandler("confirm");
    const onKeydown = withKeys((event) => {
      var _a, _b;
      if (event.target !== ((_b = (_a = root.value) == null ? void 0 : _a.popupRef) == null ? void 0 : _b.value)) {
        return;
      }
      const onEventType = {
        Enter: props.showConfirmButton ? onConfirm : noop,
        Escape: props.showCancelButton ? onCancel : noop
      };
      onEventType[event.key]();
      emit2("keydown", event);
    }, ["enter", "esc"]);
    const renderTitle = () => {
      const title = slots.title ? slots.title() : props.title;
      if (title) {
        return createVNode("div", {
          "class": bem$2("header", {
            isolated: !props.message && !slots.default
          })
        }, [title]);
      }
    };
    const renderMessage = (hasTitle) => {
      const {
        message,
        allowHtml,
        messageAlign
      } = props;
      const classNames = bem$2("message", {
        "has-title": hasTitle,
        [messageAlign]: messageAlign
      });
      const content = isFunction(message) ? message() : message;
      if (allowHtml && typeof content === "string") {
        return createVNode("div", {
          "class": classNames,
          "innerHTML": content
        }, null);
      }
      return createVNode("div", {
        "class": classNames
      }, [content]);
    };
    const renderContent = () => {
      if (slots.default) {
        return createVNode("div", {
          "class": bem$2("content")
        }, [slots.default()]);
      }
      const {
        title,
        message,
        allowHtml
      } = props;
      if (message) {
        const hasTitle = !!(title || slots.title);
        return createVNode("div", {
          "key": allowHtml ? 1 : 0,
          "class": bem$2("content", {
            isolated: !hasTitle
          })
        }, [renderMessage(hasTitle)]);
      }
    };
    const renderButtons = () => createVNode("div", {
      "class": [BORDER_TOP, bem$2("footer")]
    }, [props.showCancelButton && createVNode(Button, {
      "size": "large",
      "text": props.cancelButtonText || t("cancel"),
      "class": bem$2("cancel"),
      "style": {
        color: props.cancelButtonColor
      },
      "loading": loading.cancel,
      "disabled": props.cancelButtonDisabled,
      "onClick": onCancel
    }, null), props.showConfirmButton && createVNode(Button, {
      "size": "large",
      "text": props.confirmButtonText || t("confirm"),
      "class": [bem$2("confirm"), {
        [BORDER_LEFT]: props.showCancelButton
      }],
      "style": {
        color: props.confirmButtonColor
      },
      "loading": loading.confirm,
      "disabled": props.confirmButtonDisabled,
      "onClick": onConfirm
    }, null)]);
    const renderRoundButtons = () => createVNode(ActionBar, {
      "class": bem$2("footer")
    }, {
      default: () => [props.showCancelButton && createVNode(ActionBarButton, {
        "type": "warning",
        "text": props.cancelButtonText || t("cancel"),
        "class": bem$2("cancel"),
        "color": props.cancelButtonColor,
        "loading": loading.cancel,
        "disabled": props.cancelButtonDisabled,
        "onClick": onCancel
      }, null), props.showConfirmButton && createVNode(ActionBarButton, {
        "type": "danger",
        "text": props.confirmButtonText || t("confirm"),
        "class": bem$2("confirm"),
        "color": props.confirmButtonColor,
        "loading": loading.confirm,
        "disabled": props.confirmButtonDisabled,
        "onClick": onConfirm
      }, null)]
    });
    const renderFooter = () => {
      if (slots.footer) {
        return slots.footer();
      }
      return props.theme === "round-button" ? renderRoundButtons() : renderButtons();
    };
    return () => {
      const {
        width: width2,
        title,
        theme,
        message,
        className
      } = props;
      return createVNode(Popup, mergeProps({
        "ref": root,
        "role": "dialog",
        "class": [bem$2([theme]), className],
        "style": {
          width: addUnit(width2)
        },
        "tabindex": 0,
        "aria-labelledby": title || message,
        "onKeydown": onKeydown,
        "onUpdate:show": updateShow
      }, pick(props, popupInheritKeys)), {
        default: () => [renderTitle(), renderContent(), renderFooter()]
      });
    };
  }
});
let instance;
const DEFAULT_OPTIONS$1 = {
  title: "",
  width: "",
  theme: null,
  message: "",
  overlay: true,
  callback: null,
  teleport: "body",
  className: "",
  allowHtml: false,
  lockScroll: true,
  transition: void 0,
  beforeClose: null,
  overlayClass: "",
  overlayStyle: void 0,
  messageAlign: "",
  cancelButtonText: "",
  cancelButtonColor: null,
  cancelButtonDisabled: false,
  confirmButtonText: "",
  confirmButtonColor: null,
  confirmButtonDisabled: false,
  showConfirmButton: true,
  showCancelButton: false,
  closeOnPopstate: true,
  closeOnClickOverlay: false
};
let currentOptions = extend({}, DEFAULT_OPTIONS$1);
function initInstance() {
  const Wrapper = {
    setup() {
      const {
        state,
        toggle
      } = usePopupState();
      return () => createVNode(stdin_default$2, mergeProps(state, {
        "onUpdate:show": toggle
      }), null);
    }
  };
  ({
    instance
  } = mountComponent(Wrapper));
}
function showDialog(options) {
  if (!inBrowser$1) {
    return Promise.resolve(void 0);
  }
  return new Promise((resolve2, reject) => {
    if (!instance) {
      initInstance();
    }
    instance.open(extend({}, currentOptions, options, {
      callback: (action) => {
        (action === "confirm" ? resolve2 : reject)(action);
      }
    }));
  });
}
const showConfirmDialog = (options) => showDialog(extend({
  showCancelButton: true
}, options));
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width2 = clientRect.width / scaleX;
  var height2 = clientRect.height / scaleY;
  return {
    width: width2,
    height: height2,
    top: y,
    right: x + width2,
    bottom: y + height2,
    left: x,
    x,
    y
  };
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width2 = element.offsetWidth;
  var height2 = element.offsetHeight;
  if (Math.abs(clientRect.width - width2) <= 1) {
    width2 = clientRect.width;
  }
  if (Math.abs(clientRect.height - height2) <= 1) {
    height2 = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width2,
    height: height2
  };
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve2) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve2(fn2());
        });
      });
    }
    return pending;
  };
}
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p2, c) {
    return p2.replace(/%s/, c);
  }, str);
}
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self2) {
      return self2.indexOf(value) === index;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
          }
          break;
        case "options":
        case "data":
          break;
        default:
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
        }
      });
    });
  });
}
function uniqueBy(arr, fn2) {
  var identifiers = /* @__PURE__ */ new Set();
  return arr.filter(function(item) {
    var identifier = fn2(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current2) {
    var existing = merged2[current2.name];
    merged2[current2.name] = existing ? Object.assign({}, existing, current2, {
      options: Object.assign({}, existing.options, current2.options),
      data: Object.assign({}, existing.data, current2.data)
    }) : current2;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
function getVariation(placement) {
  return placement.split("-")[1];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function computeOffsets(_ref) {
  var reference = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference,
        popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance2 = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name2 = _ref.name;
            return name2;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name2 = _ref2.name;
              return name2 === "flip";
            });
            if (!flipModifier) {
            }
          }
          var _getComputedStyle = getComputedStyle(popper), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
          }
        }
        runModifierEffects();
        return instance2.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference2 = _state$elements.reference, popper2 = _state$elements.popper;
        if (!areValidElements(reference2, popper2)) {
          {
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference2, getOffsetParent(popper2), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper2)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name: name2,
              instance: instance2
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve2) {
          instance2.forceUpdate();
          resolve2(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference, popper)) {
      {
      }
      return instance2;
    }
    instance2.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name2 = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect3 = _ref3.effect;
        if (typeof effect3 === "function") {
          var cleanupFn = effect3({
            state,
            name: name2,
            instance: instance2,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance2;
  };
}
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance2 = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance2.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance2.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance2.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance2.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
function popperOffsets(_ref) {
  var state = _ref.state, name2 = _ref.name;
  state.modifiersData[name2] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  {
    var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name2) {
    var style = state.styles[name2] || {};
    var attributes = state.attributes[name2] || {};
    var element = state.elements[name2];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name22) {
      var value = attributes[name22];
      if (value === false) {
        element.removeAttribute(name22);
      } else {
        element.setAttribute(name22, value === true ? "" : value);
      }
    });
  });
}
function effect2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name2) {
      var element = state.elements[name2];
      var attributes = state.attributes[name2] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect2,
  requires: ["computeStyles"]
};
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name2 = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name2] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
const [name$1, bem$1] = createNamespace("popover");
const popupProps = ["overlay", "duration", "teleport", "overlayStyle", "overlayClass", "closeOnClickOverlay"];
const popoverProps = {
  show: Boolean,
  theme: makeStringProp("light"),
  overlay: Boolean,
  actions: makeArrayProp(),
  actionsDirection: makeStringProp("vertical"),
  trigger: makeStringProp("click"),
  duration: numericProp,
  showArrow: truthProp,
  placement: makeStringProp("bottom"),
  iconPrefix: String,
  overlayClass: unknownProp,
  overlayStyle: Object,
  closeOnClickAction: truthProp,
  closeOnClickOverlay: truthProp,
  closeOnClickOutside: truthProp,
  offset: {
    type: Array,
    default: () => [0, 8]
  },
  teleport: {
    type: [String, Object],
    default: "body"
  }
};
var stdin_default$1 = /* @__PURE__ */ defineComponent({
  name: name$1,
  props: popoverProps,
  emits: ["select", "touchstart", "update:show"],
  setup(props, {
    emit: emit2,
    slots,
    attrs
  }) {
    let popper;
    const popupRef = ref();
    const wrapperRef = ref();
    const popoverRef = ref();
    const show = useSyncPropRef(() => props.show, (value) => emit2("update:show", value));
    const getPopoverOptions = () => ({
      placement: props.placement,
      modifiers: [{
        name: "computeStyles",
        options: {
          adaptive: false,
          gpuAcceleration: false
        }
      }, extend({}, offset_default, {
        options: {
          offset: props.offset
        }
      })]
    });
    const createPopperInstance = () => {
      if (wrapperRef.value && popoverRef.value) {
        return createPopper(wrapperRef.value, popoverRef.value.popupRef.value, getPopoverOptions());
      }
      return null;
    };
    const updateLocation = () => {
      nextTick(() => {
        if (!show.value) {
          return;
        }
        if (!popper) {
          popper = createPopperInstance();
          if (inBrowser$1) {
            window.addEventListener("animationend", updateLocation);
            window.addEventListener("transitionend", updateLocation);
          }
        } else {
          popper.setOptions(getPopoverOptions());
        }
      });
    };
    const updateShow = (value) => {
      show.value = value;
    };
    const onClickWrapper = () => {
      if (props.trigger === "click") {
        show.value = !show.value;
      }
    };
    const onClickAction = (action, index) => {
      if (action.disabled) {
        return;
      }
      emit2("select", action, index);
      if (props.closeOnClickAction) {
        show.value = false;
      }
    };
    const onClickAway = () => {
      if (show.value && props.closeOnClickOutside && (!props.overlay || props.closeOnClickOverlay)) {
        show.value = false;
      }
    };
    const renderActionContent = (action, index) => {
      if (slots.action) {
        return slots.action({
          action,
          index
        });
      }
      return [action.icon && createVNode(Icon, {
        "name": action.icon,
        "classPrefix": props.iconPrefix,
        "class": bem$1("action-icon")
      }, null), createVNode("div", {
        "class": [bem$1("action-text"), {
          [BORDER_BOTTOM]: props.actionsDirection === "vertical"
        }]
      }, [action.text])];
    };
    const renderAction = (action, index) => {
      const {
        icon,
        color,
        disabled,
        className
      } = action;
      return createVNode("div", {
        "role": "menuitem",
        "class": [bem$1("action", {
          disabled,
          "with-icon": icon
        }), {
          [BORDER_RIGHT]: props.actionsDirection === "horizontal"
        }, className],
        "style": {
          color
        },
        "tabindex": disabled ? void 0 : 0,
        "aria-disabled": disabled || void 0,
        "onClick": () => onClickAction(action, index)
      }, [renderActionContent(action, index)]);
    };
    onMounted(() => {
      updateLocation();
      watchEffect(() => {
        var _a;
        popupRef.value = (_a = popoverRef.value) == null ? void 0 : _a.popupRef.value;
      });
    });
    onBeforeUnmount(() => {
      if (popper) {
        if (inBrowser$1) {
          window.removeEventListener("animationend", updateLocation);
          window.removeEventListener("transitionend", updateLocation);
        }
        popper.destroy();
        popper = null;
      }
    });
    watch(() => [show.value, props.offset, props.placement], updateLocation);
    useClickAway([wrapperRef, popupRef], onClickAway, {
      eventName: "touchstart"
    });
    return () => {
      var _a;
      return createVNode(Fragment, null, [createVNode("span", {
        "ref": wrapperRef,
        "class": bem$1("wrapper"),
        "onClick": onClickWrapper
      }, [(_a = slots.reference) == null ? void 0 : _a.call(slots)]), createVNode(Popup, mergeProps({
        "ref": popoverRef,
        "show": show.value,
        "class": bem$1([props.theme]),
        "position": "",
        "transition": "van-popover-zoom",
        "lockScroll": false,
        "onUpdate:show": updateShow
      }, attrs, useScopeId(), pick(props, popupProps)), {
        default: () => [props.showArrow && createVNode("div", {
          "class": bem$1("arrow")
        }, null), createVNode("div", {
          "role": "menu",
          "class": bem$1("content", props.actionsDirection)
        }, [slots.default ? slots.default() : props.actions.map(renderAction)])]
      })]);
    };
  }
});
const Popover = withInstall(stdin_default$1);
const [name, bem] = createNamespace("slider");
const sliderProps = {
  min: makeNumericProp(0),
  max: makeNumericProp(100),
  step: makeNumericProp(1),
  range: Boolean,
  reverse: Boolean,
  disabled: Boolean,
  readonly: Boolean,
  vertical: Boolean,
  barHeight: numericProp,
  buttonSize: numericProp,
  activeColor: String,
  inactiveColor: String,
  modelValue: {
    type: [Number, Array],
    default: 0
  }
};
var stdin_default = /* @__PURE__ */ defineComponent({
  name,
  props: sliderProps,
  emits: ["change", "dragEnd", "dragStart", "update:modelValue"],
  setup(props, {
    emit: emit2,
    slots
  }) {
    let buttonIndex;
    let current2;
    let startValue;
    const root = ref();
    const slider = [ref(), ref()];
    const dragStatus = ref();
    const touch = useTouch();
    const scope = computed(() => Number(props.max) - Number(props.min));
    const wrapperStyle = computed(() => {
      const crossAxis = props.vertical ? "width" : "height";
      return {
        background: props.inactiveColor,
        [crossAxis]: addUnit(props.barHeight)
      };
    });
    const isRange = (val) => props.range && Array.isArray(val);
    const calcMainAxis = () => {
      const {
        modelValue,
        min
      } = props;
      if (isRange(modelValue)) {
        return `${(modelValue[1] - modelValue[0]) * 100 / scope.value}%`;
      }
      return `${(modelValue - Number(min)) * 100 / scope.value}%`;
    };
    const calcOffset = () => {
      const {
        modelValue,
        min
      } = props;
      if (isRange(modelValue)) {
        return `${(modelValue[0] - Number(min)) * 100 / scope.value}%`;
      }
      return "0%";
    };
    const barStyle = computed(() => {
      const mainAxis = props.vertical ? "height" : "width";
      const style = {
        [mainAxis]: calcMainAxis(),
        background: props.activeColor
      };
      if (dragStatus.value) {
        style.transition = "none";
      }
      const getPositionKey = () => {
        if (props.vertical) {
          return props.reverse ? "bottom" : "top";
        }
        return props.reverse ? "right" : "left";
      };
      style[getPositionKey()] = calcOffset();
      return style;
    });
    const format2 = (value) => {
      const min = +props.min;
      const max = +props.max;
      const step = +props.step;
      value = clamp(value, min, max);
      const diff = Math.round((value - min) / step) * step;
      return addNumber(min, diff);
    };
    const updateStartValue = () => {
      const current22 = props.modelValue;
      if (isRange(current22)) {
        startValue = current22.map(format2);
      } else {
        startValue = format2(current22);
      }
    };
    const handleRangeValue = (value) => {
      var _a, _b;
      const left2 = (_a = value[0]) != null ? _a : Number(props.min);
      const right2 = (_b = value[1]) != null ? _b : Number(props.max);
      return left2 > right2 ? [right2, left2] : [left2, right2];
    };
    const updateValue = (value, end2) => {
      if (isRange(value)) {
        value = handleRangeValue(value).map(format2);
      } else {
        value = format2(value);
      }
      if (!isSameValue(value, props.modelValue)) {
        emit2("update:modelValue", value);
      }
      if (end2 && !isSameValue(value, startValue)) {
        emit2("change", value);
      }
    };
    const onClick = (event) => {
      event.stopPropagation();
      if (props.disabled || props.readonly) {
        return;
      }
      updateStartValue();
      const {
        min,
        reverse,
        vertical,
        modelValue
      } = props;
      const rect = useRect(root);
      const getDelta = () => {
        if (vertical) {
          if (reverse) {
            return rect.bottom - event.clientY;
          }
          return event.clientY - rect.top;
        }
        if (reverse) {
          return rect.right - event.clientX;
        }
        return event.clientX - rect.left;
      };
      const total = vertical ? rect.height : rect.width;
      const value = Number(min) + getDelta() / total * scope.value;
      if (isRange(modelValue)) {
        const [left2, right2] = modelValue;
        const middle = (left2 + right2) / 2;
        if (value <= middle) {
          updateValue([value, right2], true);
        } else {
          updateValue([left2, value], true);
        }
      } else {
        updateValue(value, true);
      }
    };
    const onTouchStart = (event) => {
      if (props.disabled || props.readonly) {
        return;
      }
      touch.start(event);
      current2 = props.modelValue;
      updateStartValue();
      dragStatus.value = "start";
    };
    const onTouchMove = (event) => {
      if (props.disabled || props.readonly) {
        return;
      }
      if (dragStatus.value === "start") {
        emit2("dragStart", event);
      }
      preventDefault(event, true);
      touch.move(event);
      dragStatus.value = "dragging";
      const rect = useRect(root);
      const delta = props.vertical ? touch.deltaY.value : touch.deltaX.value;
      const total = props.vertical ? rect.height : rect.width;
      let diff = delta / total * scope.value;
      if (props.reverse) {
        diff = -diff;
      }
      if (isRange(startValue)) {
        const index = props.reverse ? 1 - buttonIndex : buttonIndex;
        current2[index] = startValue[index] + diff;
      } else {
        current2 = startValue + diff;
      }
      updateValue(current2);
    };
    const onTouchEnd = (event) => {
      if (props.disabled || props.readonly) {
        return;
      }
      if (dragStatus.value === "dragging") {
        updateValue(current2, true);
        emit2("dragEnd", event);
      }
      dragStatus.value = "";
    };
    const getButtonClassName = (index) => {
      if (typeof index === "number") {
        const position = ["left", "right"];
        return bem(`button-wrapper`, position[index]);
      }
      return bem("button-wrapper", props.reverse ? "left" : "right");
    };
    const renderButtonContent = (value, index) => {
      const dragging = dragStatus.value === "dragging";
      if (typeof index === "number") {
        const slot = slots[index === 0 ? "left-button" : "right-button"];
        let dragIndex;
        if (dragging && Array.isArray(current2)) {
          dragIndex = current2[0] > current2[1] ? buttonIndex ^ 1 : buttonIndex;
        }
        if (slot) {
          return slot({
            value,
            dragging,
            dragIndex
          });
        }
      }
      if (slots.button) {
        return slots.button({
          value,
          dragging
        });
      }
      return createVNode("div", {
        "class": bem("button"),
        "style": getSizeStyle(props.buttonSize)
      }, null);
    };
    const renderButton = (index) => {
      const current22 = typeof index === "number" ? props.modelValue[index] : props.modelValue;
      return createVNode("div", {
        "ref": slider[index != null ? index : 0],
        "role": "slider",
        "class": getButtonClassName(index),
        "tabindex": props.disabled ? void 0 : 0,
        "aria-valuemin": props.min,
        "aria-valuenow": current22,
        "aria-valuemax": props.max,
        "aria-disabled": props.disabled || void 0,
        "aria-readonly": props.readonly || void 0,
        "aria-orientation": props.vertical ? "vertical" : "horizontal",
        "onTouchstartPassive": (event) => {
          if (typeof index === "number") {
            buttonIndex = index;
          }
          onTouchStart(event);
        },
        "onTouchend": onTouchEnd,
        "onTouchcancel": onTouchEnd,
        "onClick": stopPropagation
      }, [renderButtonContent(current22, index)]);
    };
    updateValue(props.modelValue);
    useCustomFieldValue(() => props.modelValue);
    slider.forEach((item) => {
      useEventListener("touchmove", onTouchMove, {
        target: item
      });
    });
    return () => createVNode("div", {
      "ref": root,
      "style": wrapperStyle.value,
      "class": bem({
        vertical: props.vertical,
        disabled: props.disabled
      }),
      "onClick": onClick
    }, [createVNode("div", {
      "class": bem("bar"),
      "style": barStyle.value
    }, [props.range ? [renderButton(0), renderButton(1)] : renderButton()])]);
  }
});
const Slider = withInstall(stdin_default);
var DEFAULT_ICON_CONFIGS = {
  size: "1em",
  strokeWidth: 4,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  rtl: false,
  theme: "outline",
  colors: {
    outline: {
      fill: "#333",
      background: "transparent"
    },
    filled: {
      fill: "#333",
      background: "#FFF"
    },
    twoTone: {
      fill: "#333",
      twoTone: "#2F88FF"
    },
    multiColor: {
      outStrokeColor: "#333",
      outFillColor: "#2F88FF",
      innerStrokeColor: "#FFF",
      innerFillColor: "#43CCF8"
    }
  },
  prefix: "i"
};
function guid() {
  return "icon-" + ((1 + Math.random()) * 4294967296 | 0).toString(16).substring(1);
}
function IconConverter(id, icon, config) {
  var fill = typeof icon.fill === "string" ? [icon.fill] : icon.fill || [];
  var colors = [];
  var theme = icon.theme || config.theme;
  switch (theme) {
    case "outline":
      colors.push(typeof fill[0] === "string" ? fill[0] : "currentColor");
      colors.push("none");
      colors.push(typeof fill[0] === "string" ? fill[0] : "currentColor");
      colors.push("none");
      break;
    case "filled":
      colors.push(typeof fill[0] === "string" ? fill[0] : "currentColor");
      colors.push(typeof fill[0] === "string" ? fill[0] : "currentColor");
      colors.push("#FFF");
      colors.push("#FFF");
      break;
    case "two-tone":
      colors.push(typeof fill[0] === "string" ? fill[0] : "currentColor");
      colors.push(typeof fill[1] === "string" ? fill[1] : config.colors.twoTone.twoTone);
      colors.push(typeof fill[0] === "string" ? fill[0] : "currentColor");
      colors.push(typeof fill[1] === "string" ? fill[1] : config.colors.twoTone.twoTone);
      break;
    case "multi-color":
      colors.push(typeof fill[0] === "string" ? fill[0] : "currentColor");
      colors.push(typeof fill[1] === "string" ? fill[1] : config.colors.multiColor.outFillColor);
      colors.push(typeof fill[2] === "string" ? fill[2] : config.colors.multiColor.innerStrokeColor);
      colors.push(typeof fill[3] === "string" ? fill[3] : config.colors.multiColor.innerFillColor);
      break;
  }
  return {
    size: icon.size || config.size,
    strokeWidth: icon.strokeWidth || config.strokeWidth,
    strokeLinecap: icon.strokeLinecap || config.strokeLinecap,
    strokeLinejoin: icon.strokeLinejoin || config.strokeLinejoin,
    colors,
    id
  };
}
var IconContext = Symbol("icon-context");
function IconWrapper(name2, rtl, render) {
  var options = {
    name: "icon-" + name2,
    props: ["size", "strokeWidth", "strokeLinecap", "strokeLinejoin", "theme", "fill", "spin"],
    setup: function setup(props) {
      var id = guid();
      var ICON_CONFIGS = inject(IconContext, DEFAULT_ICON_CONFIGS);
      return function() {
        var size2 = props.size, strokeWidth = props.strokeWidth, strokeLinecap = props.strokeLinecap, strokeLinejoin = props.strokeLinejoin, theme = props.theme, fill = props.fill, spin = props.spin;
        var svgProps = IconConverter(id, {
          size: size2,
          strokeWidth,
          strokeLinecap,
          strokeLinejoin,
          theme,
          fill
        }, ICON_CONFIGS);
        var cls = [ICON_CONFIGS.prefix + "-icon"];
        cls.push(ICON_CONFIGS.prefix + "-icon-" + name2);
        if (rtl && ICON_CONFIGS.rtl) {
          cls.push(ICON_CONFIGS.prefix + "-icon-rtl");
        }
        if (spin) {
          cls.push(ICON_CONFIGS.prefix + "-icon-spin");
        }
        return createVNode("span", {
          "class": cls.join(" ")
        }, [render(svgProps)]);
      };
    }
  };
  return options;
}
const ArrowRight = IconWrapper("arrow-right", true, function(props) {
  return createVNode("svg", {
    "width": props.size,
    "height": props.size,
    "viewBox": "0 0 48 48",
    "fill": "none"
  }, [createVNode("path", {
    "d": "M41.9999 24H5.99994",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M30 12L42 24L30 36",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null)]);
});
const Delete = IconWrapper("delete", false, function(props) {
  return createVNode("svg", {
    "width": props.size,
    "height": props.size,
    "viewBox": "0 0 48 48",
    "fill": "none"
  }, [createVNode("path", {
    "d": "M9 10V44H39V10H9Z",
    "fill": props.colors[1],
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M20 20V33",
    "stroke": props.colors[2],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M28 20V33",
    "stroke": props.colors[2],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M4 10H44",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M16 10L19.289 4H28.7771L32 10H16Z",
    "fill": props.colors[1],
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linejoin": props.strokeLinejoin
  }, null)]);
});
const Flashlight = IconWrapper("flashlight", false, function(props) {
  return createVNode("svg", {
    "width": props.size,
    "height": props.size,
    "viewBox": "0 0 48 48",
    "fill": "none"
  }, [createVNode("path", {
    "d": "M17 22.1961C17 22.0726 16.9419 21.9564 16.8431 21.8824C11.9058 18.1793 9 12.3678 9 6.19608L9 4H39V6.19608C39 12.3678 36.0942 18.1793 31.1569 21.8824C31.0581 21.9564 31 22.0726 31 22.1961V44H17V22.1961Z",
    "fill": props.colors[1],
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M38 11H10",
    "stroke": props.colors[2],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M24 28.0083V32.0083",
    "stroke": props.colors[2],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M17 22V22C11.9639 18.2229 9 12.2951 9 6L9 4",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M39 4V6C39 12.2951 36.0361 18.2229 31 22V22",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null)]);
});
const GoEnd = IconWrapper("go-end", true, function(props) {
  return createVNode("svg", {
    "width": props.size,
    "height": props.size,
    "viewBox": "0 0 48 48",
    "fill": "none"
  }, [createVNode("path", {
    "d": "M14 12L26 24L14 36",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M34 12V36",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null)]);
});
const GoStart = IconWrapper("go-start", true, function(props) {
  return createVNode("svg", {
    "width": props.size,
    "height": props.size,
    "viewBox": "0 0 48 48",
    "fill": "none"
  }, [createVNode("path", {
    "d": "M34 36L22 24L34 12",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M14 12V36",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null)]);
});
const Info = IconWrapper("info", true, function(props) {
  return createVNode("svg", {
    "width": props.size,
    "height": props.size,
    "viewBox": "0 0 48 48",
    "fill": "none"
  }, [createVNode("path", {
    "d": "M24 44C29.5228 44 34.5228 41.7614 38.1421 38.1421C41.7614 34.5228 44 29.5228 44 24C44 18.4772 41.7614 13.4772 38.1421 9.85786C34.5228 6.23858 29.5228 4 24 4C18.4772 4 13.4772 6.23858 9.85786 9.85786C6.23858 13.4772 4 18.4772 4 24C4 29.5228 6.23858 34.5228 9.85786 38.1421C13.4772 41.7614 18.4772 44 24 44Z",
    "fill": props.colors[1],
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    "d": "M24 11C25.3807 11 26.5 12.1193 26.5 13.5C26.5 14.8807 25.3807 16 24 16C22.6193 16 21.5 14.8807 21.5 13.5C21.5 12.1193 22.6193 11 24 11Z",
    "fill": props.colors[2]
  }, null), createVNode("path", {
    "d": "M24.5 34V20H23.5H22.5",
    "stroke": props.colors[2],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M21 34H28",
    "stroke": props.colors[2],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null)]);
});
const Music = IconWrapper("music", true, function(props) {
  return createVNode("svg", {
    "width": props.size,
    "height": props.size,
    "viewBox": "0 0 48 48",
    "fill": "none"
  }, [createVNode("path", {
    "d": "M30 34.5C30 32.567 31.567 31 33.5 31H41V34.4C41 36.3882 39.3882 38 37.4 38H33.5C31.567 38 30 36.433 30 34.5Z",
    "fill": props.colors[1],
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M6 38.5C6 36.567 7.567 35 9.5 35H16V38.4C16 40.3882 14.3882 42 12.4 42H9.5C7.567 42 6 40.433 6 38.5Z",
    "fill": props.colors[1],
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M16 18.044V18.044L41 12.125",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M16 38V10L41 4V33.6924",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null)]);
});
const MusicList = IconWrapper("music-list", true, function(props) {
  return createVNode("svg", {
    "width": props.size,
    "height": props.size,
    "viewBox": "0 0 48 48",
    "fill": "none"
  }, [createVNode("path", {
    "d": "M24 19H40",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M24 10H40",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M8 38H40",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M8 28H40",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M8 10L16 15L8 20V10Z",
    "fill": props.colors[1],
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linejoin": props.strokeLinejoin
  }, null)]);
});
const PauseOne = IconWrapper("pause-one", false, function(props) {
  return createVNode("svg", {
    "width": props.size,
    "height": props.size,
    "viewBox": "0 0 48 48",
    "fill": "none"
  }, [createVNode("path", {
    "d": "M24 44C35.0457 44 44 35.0457 44 24C44 12.9543 35.0457 4 24 4C12.9543 4 4 12.9543 4 24C4 35.0457 12.9543 44 24 44Z",
    "fill": props.colors[1],
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M19 18V30",
    "stroke": props.colors[2],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M29 18V30",
    "stroke": props.colors[2],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null)]);
});
const Play = IconWrapper("play", true, function(props) {
  return createVNode("svg", {
    "width": props.size,
    "height": props.size,
    "viewBox": "0 0 48 48",
    "fill": "none"
  }, [createVNode("path", {
    "d": "M24 44C35.0457 44 44 35.0457 44 24C44 12.9543 35.0457 4 24 4C12.9543 4 4 12.9543 4 24C4 35.0457 12.9543 44 24 44Z",
    "fill": props.colors[1],
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M20 24V17.0718L26 20.5359L32 24L26 27.4641L20 30.9282V24Z",
    "fill": props.colors[3],
    "stroke": props.colors[2],
    "stroke-width": props.strokeWidth,
    "stroke-linejoin": props.strokeLinejoin
  }, null)]);
});
const PlayCycle = IconWrapper("play-cycle", true, function(props) {
  return createVNode("svg", {
    "width": props.size,
    "height": props.size,
    "viewBox": "0 0 48 48",
    "fill": "none"
  }, [createVNode("path", {
    "d": "M4 25C4 18.3502 9.39624 13 16 13H44",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M38 7L44 13L38 19",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M44 23C44 29.6498 38.6038 35 32 35H4",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M10 41L4 35L10 29",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null)]);
});
const PlayOnce = IconWrapper("play-once", true, function(props) {
  return createVNode("svg", {
    "width": props.size,
    "height": props.size,
    "viewBox": "0 0 48 48",
    "fill": "none"
  }, [createVNode("path", {
    "d": "M43.8233 25.2305C43.7019 25.9889 43.5195 26.727 43.2814 27.4395C42.763 28.9914 41.9801 30.4222 40.9863 31.6785C38.4222 34.9201 34.454 37 30 37H16C9.39697 37 4 31.6785 4 25C4 18.3502 9.39624 13 16 13H44",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M38 7L44 13L38 19",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M24 19V31",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M24 19L21 22L19.5 23.5",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null)]);
});
const Record = IconWrapper("record", true, function(props) {
  return createVNode("svg", {
    "width": props.size,
    "height": props.size,
    "viewBox": "0 0 48 48",
    "fill": "none"
  }, [createVNode("rect", {
    "x": "5",
    "y": "18",
    "width": "38",
    "height": "24",
    "rx": "2",
    "fill": props.colors[1],
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M8 12H40",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M15 6L33 6",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M26 24V30",
    "stroke": props.colors[2],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M18 32.7491C18 31.2308 19.2894 30 20.88 30H26V33.2509C26 34.7692 24.7106 36 23.12 36H20.88C19.2894 36 18 34.7692 18 33.2509V32.7491Z",
    "stroke": props.colors[2],
    "stroke-width": props.strokeWidth,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M31 25L26 24",
    "stroke": props.colors[2],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null)]);
});
const Share = IconWrapper("share", true, function(props) {
  return createVNode("svg", {
    "width": props.size,
    "height": props.size,
    "viewBox": "0 0 48 48",
    "fill": "none"
  }, [createVNode("path", {
    "d": "M28 6H42V20",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M42 29.4737V39C42 40.6569 40.6569 42 39 42H9C7.34315 42 6 40.6569 6 39V9C6 7.34315 7.34315 6 9 6L18 6",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M25.7998 22.1999L41.0998 6.8999",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null)]);
});
const ShuffleOne = IconWrapper("shuffle-one", true, function(props) {
  return createVNode("svg", {
    "width": props.size,
    "height": props.size,
    "viewBox": "0 0 48 48",
    "fill": "none"
  }, [createVNode("path", {
    "d": "M40 33L44 37L40 41",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M40 7L44 11L40 15",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M44 11H37C29.8203 11 24 16.8203 24 24C24 31.1797 29.8203 37 37 37H44",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap
  }, null), createVNode("path", {
    "d": "M4 37H11C18.1797 37 24 31.1797 24 24C24 16.8203 18.1797 11 11 11H4",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap
  }, null)]);
});
const VolumeNotice = IconWrapper("volume-notice", true, function(props) {
  return createVNode("svg", {
    "width": props.size,
    "height": props.size,
    "viewBox": "0 0 48 48",
    "fill": "none"
  }, [createVNode("path", {
    "d": "M24 6V42C17 42 11.7985 32.8391 11.7985 32.8391H6C4.89543 32.8391 4 31.9437 4 30.8391V17.0108C4 15.9062 4.89543 15.0108 6 15.0108H11.7985C11.7985 15.0108 17 6 24 6Z",
    "fill": props.colors[1],
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M32 15L32 15C32.6232 15.5565 33.1881 16.1797 33.6841 16.8588C35.1387 18.8504 36 21.3223 36 24C36 26.6545 35.1535 29.1067 33.7218 31.0893C33.2168 31.7885 32.6391 32.4293 32 33",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap,
    "stroke-linejoin": props.strokeLinejoin
  }, null), createVNode("path", {
    "d": "M34.2359 41.1857C40.0836 37.6953 44 31.305 44 24C44 16.8085 40.2043 10.5035 34.507 6.97906",
    "stroke": props.colors[0],
    "stroke-width": props.strokeWidth,
    "stroke-linecap": props.strokeLinecap
  }, null)]);
});
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _hoisted_1$7 = {
  type: "button",
  class: "base-btn"
};
const _sfc_main$8 = {
  __name: "BaseButton",
  props: {
    size: {
      type: String,
      default: "42px"
    }
  },
  setup(__props) {
    useCssVars((_ctx) => ({
      "3e06cfc9": __props.size
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", _hoisted_1$7, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ]);
    };
  }
};
const BaseButton = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-394afb03"]]);
const _hoisted_1$6 = ["fill"];
const _hoisted_2$6 = /* @__PURE__ */ createBaseVNode("path", { d: "M2.667 7.027l1.707-1.693 22.293 22.293-1.693 1.707-4-4h-11.64v4l-5.333-5.333 5.333-5.333v4h8.973l-8.973-8.973v0.973h-2.667v-3.64l-4-4zM22.667 17.333h2.667v5.573l-2.667-2.667v-2.907zM22.667 6.667v-4l5.333 5.333-5.333 5.333v-4h-10.907l-2.667-2.667h13.573z" }, null, -1);
const _hoisted_3$6 = [
  _hoisted_2$6
];
const _sfc_main$7 = {
  __name: "PlayNoLoop",
  props: {
    fill: {
      type: String,
      default: "#000"
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        version: "1.1",
        viewBox: "0 0 29 32",
        fill: __props.fill
      }, _hoisted_3$6, 8, _hoisted_1$6);
    };
  }
};
const emptyImg = "data:image/png;base64,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";
const _sfc_main$6 = {
  __name: "Empty",
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_van_button = Button;
      const _component_van_empty = Empty;
      return openBlock(), createBlock(_component_van_empty, {
        image: unref(emptyImg),
        "image-size": "240",
        description: "暂无歌曲"
      }, {
        default: withCtx(() => [
          createVNode(_component_van_button, {
            round: "",
            color: "#4ddd4c",
            type: "primary"
          }, {
            default: withCtx(() => [
              createTextVNode("前往音乐磁场添加歌曲")
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["image"]);
    };
  }
};
const _withScopeId$2 = (n) => (pushScopeId("data-v-4a5ab5c6"), n = n(), popScopeId(), n);
const _hoisted_1$5 = { class: "header" };
const _hoisted_2$5 = { class: "logo" };
const _hoisted_3$5 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("span", { class: "title" }, "听歌小助手", -1));
const _hoisted_4$5 = { class: "flex items-center" };
const _hoisted_5$4 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("span", { class: "text-16px text-#666 ml-6px" }, "关于", -1));
const _sfc_main$5 = {
  __name: "AppHeader",
  emits: ["show-about"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    return (_ctx, _cache) => {
      const _component_van_button = Button;
      return openBlock(), createElementBlock("div", _hoisted_1$5, [
        createBaseVNode("div", _hoisted_2$5, [
          createVNode(unref(Record), {
            style: { "line-height": "1" },
            theme: "two-tone",
            size: "36",
            fill: ["#409c3f", "#ffd448"],
            strokeWidth: 3
          }),
          _hoisted_3$5
        ]),
        renderSlot(_ctx.$slots, "default", {}, () => [
          createVNode(_component_van_button, {
            color: "#fff",
            onClick: _cache[0] || (_cache[0] = ($event) => emits("show-about"))
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_4$5, [
                createVNode(unref(Info), {
                  theme: "outline",
                  size: "22",
                  strokeWidth: 3,
                  fill: "#666"
                }),
                _hoisted_5$4
              ])
            ]),
            _: 1
          })
        ], true)
      ]);
    };
  }
};
const AppHeader = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-4a5ab5c6"]]);
const aboutContent = '<section class="content">\r\n\r\n    <h4>为什么写这个脚本？</h4>\r\n    <p>我挺喜欢 Hifini 这个网站，一般也都在这里听歌。\r\n        但是有个问题困扰了我许久，就是这个网站好像没有一个类似播放列表那样可以管理歌曲（如添加、删除、切换歌曲等）的功能，\r\n        因此，听歌时，我只能打开一个页面听一首歌，然后打开另一个页面听另一首歌，就这样打开一个个页面，然后一首一首地听。这不是很方便。\r\n        鉴于该网站对其自身定位只是一个由音乐爱好者维护的分享平台，而不是在线听歌平台，\r\n        我想或许它更加鼓励用户去将歌曲下载到本地，然后通过本地音乐播放器去管理歌曲。但我只是偶尔听听歌，能在线听就够了，我并不想去下载和管理歌曲，\r\n        于是我捣腾了一番，写了这个脚本，为 Hifini 提供了一个简单的播放列表。\r\n    </p>\r\n    <h4>脚本的实现</h4>\r\n    <p>\r\n        本脚本主要基于<a target="_blank" href="https://github.com/lisonge/vite-plugin-monkey/">vite-plugin-monkey</a>\r\n        这个插件提供的模板进行开发。脚本主要分成两部分，一部分是注入 Hifini 的代码，主要用于获取歌曲链接、添加歌曲到播放列表、打开播放列表等。\r\n        另一部分就是播放列表页面，用来管理歌曲，也就是现在所处的页面。两部分之间主要通过 BroadcastChannel 进行通信，实现歌曲添加。\r\n        具体的实现细节如果大家有兴趣的话，可以去看看脚本源码。\r\n    </p>\r\n    <h4>缺陷和问题</h4>\r\n    <p>\r\n        说实在的，这个脚本还不成熟，还有许多缺陷和问题。因此，欢迎大家向我反馈在使用过程中遇到的问题。我也会在有空的时候积极地去解决我能力范围内能解决的问题。\r\n    </p>\r\n    <h4>支持开发者</h4>\r\n    <p>生活不易，在线卖艺。如果这个脚本对你有点帮助，可以考虑请我喝杯奶茶或者喝瓶可乐，你的支持和鼓励将会给我动力持续去维护好这个脚本。\r\n        <br>\r\n        <img src="https://cdn.jsdelivr.net/gh/fan0530/music-player/code.jpg" alt="赞赏码" style="display: block; margin: 0 auto; width: 100%; max-width: 320px; height: auto;">\r\n                   \r\n    </p>\r\n\r\n</section>    \r\n';
const _withScopeId$1 = (n) => (pushScopeId("data-v-2c463995"), n = n(), popScopeId(), n);
const _hoisted_1$4 = { class: "h-full w-full flex flex-col box-border" };
const _hoisted_2$4 = { class: "flex items-center justify-between px-16px" };
const _hoisted_3$4 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("h3", null, "关于", -1));
const _hoisted_4$4 = ["innerHTML"];
const _sfc_main$4 = {
  __name: "AboutDialog",
  props: {
    show: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:show"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const isLarge = ref(false);
    const checkDocWidth = () => {
      const docWidth = document.documentElement.clientWidth;
      if (docWidth > 500) {
        isLarge.value = true;
      } else {
        isLarge.value = false;
      }
    };
    onMounted(() => {
      checkDocWidth();
      window.addEventListener("resize", checkDocWidth);
    });
    onBeforeUnmount(() => {
      window.removeEventListener("resize", checkDocWidth);
    });
    return (_ctx, _cache) => {
      const _component_van_icon = Icon;
      const _component_van_popup = Popup;
      return openBlock(), createBlock(_component_van_popup, {
        show: __props.show,
        round: "",
        position: isLarge.value ? "center" : "bottom",
        class: "h-85% custom-popup",
        "onUpdate:show": _cache[1] || (_cache[1] = (value) => emits("update:show", value))
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$4, [
            createBaseVNode("header", _hoisted_2$4, [
              _hoisted_3$4,
              createVNode(_component_van_icon, {
                name: "cross",
                size: "22",
                onClick: _cache[0] || (_cache[0] = ($event) => emits("update:show", false))
              })
            ]),
            createBaseVNode("div", {
              class: normalizeClass(["flex-1 overflow-y-auto px-16px custom", { "custom-scrollbar": isLarge.value }]),
              innerHTML: unref(aboutContent)
            }, null, 10, _hoisted_4$4)
          ])
        ]),
        _: 1
      }, 8, ["show", "position"]);
    };
  }
};
const AboutDialog = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-2c463995"]]);
const usePlaylistStore = defineStore("playlist", {
  state: () => {
    return {
      playlist: [],
      curSongIndex: 0
    };
  },
  // 也可以这样定义
  // state: () => ({ count: 0 })
  actions: {
    add(song) {
      this.playlist.push(song);
    },
    setCurSongIndex(index) {
      this.curSongIndex = index;
    }
  },
  persist: {
    key: "hifini-helper",
    paths: ["playlist"]
  }
});
function promisifyRequest(request) {
  return new Promise((resolve2, reject) => {
    request.oncomplete = request.onsuccess = () => resolve2(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  const request = indexedDB.open(dbName);
  request.onupgradeneeded = () => request.result.createObjectStore(storeName);
  const dbp = promisifyRequest(request);
  return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
let defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key);
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}
const _hoisted_1$3 = { class: "playlist" };
const _hoisted_2$3 = ["onClick"];
const _hoisted_3$3 = { class: "flex" };
const _hoisted_4$3 = { class: "ml-15px" };
const _hoisted_5$3 = { class: "text-#666 text-14px" };
const _hoisted_6$1 = { class: "text-#999 text-13px mt-4px" };
const _sfc_main$3 = {
  __name: "Playlist",
  emits: ["empty"],
  setup(__props, { emit: __emit }) {
    const aplayerInstance = inject("aplayerInstance");
    const emits = __emit;
    const store = usePlaylistStore();
    const curSongIndex = computed(() => {
      return store.curSongIndex;
    });
    const onSwitch = (index) => {
      var _a;
      if (index === curSongIndex.value) {
        return;
      }
      (_a = aplayerInstance.value) == null ? void 0 : _a.list.switch(index);
    };
    const onDelete = (index, item) => {
      showConfirmDialog({
        title: "提示",
        message: `确定删除歌曲（${item.name}）？`
      }).then(() => {
        var _a, _b, _c, _d, _e;
        let index2 = -1;
        if (item.id) {
          index2 = (_a = store.playlist) == null ? void 0 : _a.findIndex((x) => x.id === item.id);
        } else if (item.page) {
          index2 = (_b = store.playlist) == null ? void 0 : _b.findIndex((x) => x.page === item.page);
        }
        if (index2 !== -1) {
          (_c = store.playlist) == null ? void 0 : _c.splice(index2, 1);
          (_d = aplayerInstance.value) == null ? void 0 : _d.list.remove(index2);
          if (item.storeKey) {
            del(item.storeKey);
          }
        }
        if (((_e = store.playlist) == null ? void 0 : _e.length) === 0) {
          emits("empty");
        }
      }).catch(() => {
      });
    };
    return (_ctx, _cache) => {
      const _component_van_image = Image;
      return openBlock(), createElementBlock("ul", _hoisted_1$3, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(store).playlist, (item, index) => {
          return openBlock(), createElementBlock("li", {
            key: index,
            class: normalizeClass(curSongIndex.value === index ? "item active" : "item"),
            onClick: ($event) => onSwitch(index)
          }, [
            createBaseVNode("div", _hoisted_3$3, [
              createVNode(_component_van_image, {
                src: item.cover,
                width: 54,
                height: 54,
                radius: 4
              }, {
                error: withCtx(() => [
                  createVNode(unref(Music), {
                    theme: "outline",
                    size: "24",
                    fill: "#999"
                  })
                ]),
                _: 2
              }, 1032, ["src"]),
              createBaseVNode("div", _hoisted_4$3, [
                createBaseVNode("div", _hoisted_5$3, toDisplayString(item.name), 1),
                createBaseVNode("div", _hoisted_6$1, toDisplayString(item.artist), 1)
              ])
            ]),
            createVNode(BaseButton, {
              class: "self-center",
              onClick: withModifiers(($event) => onDelete(index, item), ["stop"])
            }, {
              default: withCtx(() => [
                createVNode(unref(Delete), {
                  theme: "outline",
                  size: "24",
                  fill: "#f34343",
                  strokeWidth: 3
                })
              ]),
              _: 2
            }, 1032, ["onClick"])
          ], 10, _hoisted_2$3);
        }), 128))
      ]);
    };
  }
};
const Playlist = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-025a921d"]]);
const _hoisted_1$2 = { class: "h-100% w-full flex flex-col box-border" };
const _hoisted_2$2 = { class: "flex items-center justify-between px-16px" };
const _hoisted_3$2 = /* @__PURE__ */ createBaseVNode("h3", null, "歌单管理", -1);
const _hoisted_4$2 = { class: "flex-1 overflow-y-auto custom-scrollbar" };
const _hoisted_5$2 = { class: "p-16px flex items-center justify-between" };
const _sfc_main$2 = {
  __name: "PlaylistManageDialog",
  props: {
    show: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:show"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const aplayerInstance = inject("aplayerInstance");
    const store = usePlaylistStore();
    const updateShow = (show) => {
      emits("update:show", show);
    };
    const removeAll = () => {
      showConfirmDialog({
        title: "提示",
        message: `确定删除全部歌曲？`
      }).then(() => {
        var _a, _b;
        (_a = store.playlist) == null ? void 0 : _a.splice(0, store.playlist.length);
        (_b = aplayerInstance.value) == null ? void 0 : _b.list.clear();
        clear();
        updateShow(false);
      }).catch(() => {
      });
    };
    const isLarge = ref(false);
    const checkDocWidth = () => {
      const docWidth = document.documentElement.clientWidth;
      if (docWidth > 500) {
        isLarge.value = true;
      } else {
        isLarge.value = false;
      }
    };
    onMounted(() => {
      checkDocWidth();
      window.addEventListener("resize", checkDocWidth);
    });
    onBeforeUnmount(() => {
      window.removeEventListener("resize", checkDocWidth);
    });
    return (_ctx, _cache) => {
      const _component_van_icon = Icon;
      const _component_van_button = Button;
      const _component_van_popup = Popup;
      return openBlock(), createBlock(_component_van_popup, {
        show: __props.show,
        round: "",
        position: isLarge.value ? "center" : "bottom",
        class: "h-85% custom-popup",
        "onUpdate:show": _cache[2] || (_cache[2] = (value) => updateShow(value))
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$2, [
            createBaseVNode("header", _hoisted_2$2, [
              _hoisted_3$2,
              createVNode(_component_van_icon, {
                name: "cross",
                size: "22",
                onClick: _cache[0] || (_cache[0] = () => updateShow(false))
              })
            ]),
            createBaseVNode("div", _hoisted_4$2, [
              createVNode(Playlist, {
                onEmpty: _cache[1] || (_cache[1] = () => updateShow(false))
              })
            ]),
            createBaseVNode("div", _hoisted_5$2, [
              createBaseVNode("div", null, [
                createTextVNode("共"),
                createBaseVNode("span", null, toDisplayString(unref(store).playlist.length), 1),
                createTextVNode("首歌曲")
              ]),
              createVNode(_component_van_button, {
                type: "danger",
                onClick: removeAll
              }, {
                default: withCtx(() => [
                  createTextVNode("删除全部")
                ]),
                _: 1
              })
            ])
          ])
        ]),
        _: 1
      }, 8, ["show", "position"]);
    };
  }
};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var media = {
  webm: "data:video/webm;base64,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",
  mp4: "data:video/mp4;base64,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"
};
const { webm, mp4 } = media;
const oldIOS = () => typeof navigator !== "undefined" && parseFloat(
  ("" + (/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(
    navigator.userAgent
  ) || [0, ""])[1]).replace("undefined", "3_2").replace("_", ".").replace("_", "")
) < 10 && !window.MSStream;
const nativeWakeLock = () => "wakeLock" in navigator;
class NoSleep {
  constructor() {
    this.enabled = false;
    if (nativeWakeLock()) {
      this._wakeLock = null;
      const handleVisibilityChange = () => {
        if (this._wakeLock !== null && document.visibilityState === "visible") {
          this.enable();
        }
      };
      document.addEventListener("visibilitychange", handleVisibilityChange);
      document.addEventListener("fullscreenchange", handleVisibilityChange);
    } else if (oldIOS()) {
      this.noSleepTimer = null;
    } else {
      this.noSleepVideo = document.createElement("video");
      this.noSleepVideo.setAttribute("title", "No Sleep");
      this.noSleepVideo.setAttribute("playsinline", "");
      this._addSourceToVideo(this.noSleepVideo, "webm", webm);
      this._addSourceToVideo(this.noSleepVideo, "mp4", mp4);
      this.noSleepVideo.addEventListener("loadedmetadata", () => {
        if (this.noSleepVideo.duration <= 1) {
          this.noSleepVideo.setAttribute("loop", "");
        } else {
          this.noSleepVideo.addEventListener("timeupdate", () => {
            if (this.noSleepVideo.currentTime > 0.5) {
              this.noSleepVideo.currentTime = Math.random();
            }
          });
        }
      });
    }
  }
  _addSourceToVideo(element, type, dataURI) {
    var source = document.createElement("source");
    source.src = dataURI;
    source.type = `video/${type}`;
    element.appendChild(source);
  }
  get isEnabled() {
    return this.enabled;
  }
  enable() {
    if (nativeWakeLock()) {
      return navigator.wakeLock.request("screen").then((wakeLock) => {
        this._wakeLock = wakeLock;
        this.enabled = true;
        this._wakeLock.addEventListener("release", () => {
        });
      }).catch((err) => {
        this.enabled = false;
        throw err;
      });
    } else if (oldIOS()) {
      this.disable();
      this.noSleepTimer = window.setInterval(() => {
        if (!document.hidden) {
          window.location.href = window.location.href.split("#")[0];
          window.setTimeout(window.stop, 0);
        }
      }, 15e3);
      this.enabled = true;
      return Promise.resolve();
    } else {
      let playPromise = this.noSleepVideo.play();
      return playPromise.then((res) => {
        this.enabled = true;
        return res;
      }).catch((err) => {
        this.enabled = false;
        throw err;
      });
    }
  }
  disable() {
    if (nativeWakeLock()) {
      if (this._wakeLock) {
        this._wakeLock.release();
      }
      this._wakeLock = null;
    } else if (oldIOS()) {
      if (this.noSleepTimer) {
        window.clearInterval(this.noSleepTimer);
        this.noSleepTimer = null;
      }
    } else {
      this.noSleepVideo.pause();
    }
    this.enabled = false;
  }
}
var src = NoSleep;
const NoSleep$1 = /* @__PURE__ */ getDefaultExportFromCjs(src);
const _withScopeId = (n) => (pushScopeId("data-v-6fa33c71"), n = n(), popScopeId(), n);
const _hoisted_1$1 = { class: "flex items-center" };
const _hoisted_2$1 = {
  key: 0,
  class: "empty"
};
const _hoisted_3$1 = {
  key: 1,
  class: "layout"
};
const _hoisted_4$1 = { class: "content" };
const _hoisted_5$1 = { class: "flex flex-1 center" };
const _hoisted_6 = ["src"];
const _hoisted_7 = { class: "w-full box-border px-16px" };
const _hoisted_8 = { class: "flex items-center" };
const _hoisted_9 = { class: "truncate mr-6px" };
const _hoisted_10 = ["href"];
const _hoisted_11 = { class: "flex flex-col" };
const _hoisted_12 = { class: "flex items-center justify-between mt-8px" };
const _hoisted_13 = { class: "toolbar mt-16px" };
const _hoisted_14 = { class: "flex items-center" };
const _hoisted_15 = { class: "flex items-center" };
const _hoisted_16 = { class: "px-16px py-10px h-120px" };
const _hoisted_17 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { class: "w-6px h-6px rounded-6px bg-#4ddd4c" }, null, -1));
const storkeWidthForSmallIcon = 3;
const _sfc_main$1 = {
  __name: "MusicPlayer",
  setup(__props) {
    if ("mediaSession" in navigator) {
      navigator.mediaSession.metadata = new MediaMetadata({
        title: "暂无歌曲",
        artist: "--",
        album: "听歌小助手"
      });
      navigator.mediaSession.setActionHandler("play", function() {
        onPlay();
      });
      navigator.mediaSession.setActionHandler("pause", function() {
        onPause();
      });
      navigator.mediaSession.setActionHandler("previoustrack", function() {
        onSkipBack();
      });
      navigator.mediaSession.setActionHandler("nexttrack", function() {
        onSkipForward();
      });
    }
    const updateMetaData = (song2) => {
      if (navigator.mediaSession && navigator.mediaSession.metadata) {
        navigator.mediaSession.metadata.title = song2 ? song2.name : "暂无歌曲";
        navigator.mediaSession.metadata.artist = song2 ? song2.artist : "--";
        navigator.mediaSession.metadata.artwork = song2 ? [{ src: song2.cover }] : [];
      }
    };
    const noSleep = new NoSleep$1();
    const aplayerInstance = inject("aplayerInstance");
    const store = usePlaylistStore();
    const song = computed(() => {
      const curSong = store.playlist[curSongIndex.value];
      updateMetaData(curSong);
      return curSong;
    });
    const duration = ref(0);
    const currentTime = ref(0);
    const isPaused = ref(true);
    const curSongIndex = ref(0);
    const showVolumePopover = ref(false);
    const showPlayList = ref(false);
    const showAbout = ref(false);
    const loop = ref("all");
    const order2 = ref("list");
    const size2 = ref(6);
    const isNoSleepEnabled = ref(false);
    const onPlay = () => {
      var _a;
      (_a = aplayerInstance.value) == null ? void 0 : _a.play();
    };
    const onPause = () => {
      var _a;
      (_a = aplayerInstance.value) == null ? void 0 : _a.pause();
    };
    const onSkipBack = () => {
      var _a;
      (_a = aplayerInstance.value) == null ? void 0 : _a.skipBack();
    };
    const onSkipForward = () => {
      var _a;
      (_a = aplayerInstance.value) == null ? void 0 : _a.skipForward();
    };
    const onSeek = (value) => {
      var _a;
      (_a = aplayerInstance.value) == null ? void 0 : _a.seek(value);
    };
    const onProgressbarDragStart = () => {
      onPause();
      size2.value = 18;
    };
    const onProgressbarDragEnd = () => {
      onPlay();
      size2.value = 6;
    };
    const getLoopSetting = computed(() => {
      return loop.value;
    });
    const getOrderSetting = computed(() => {
      return order2.value;
    });
    const volume = ref(0.7);
    const updateVolume = (value) => {
      if (aplayerInstance.value) {
        volume.value = value;
        aplayerInstance.value.volume(value);
      }
    };
    const updateOrderSetting = () => {
      const event = new MouseEvent("click");
      aplayerInstance.value.template.order.dispatchEvent(event);
    };
    const updateLoopSetting = () => {
      const event = new MouseEvent("click");
      aplayerInstance.value.template.loop.dispatchEvent(event);
    };
    const observeOptions = () => {
      Object.defineProperty(aplayerInstance.value.options, "loop", {
        get() {
          return loop.value;
        },
        set(value) {
          loop.value = value;
        }
      });
      Object.defineProperty(aplayerInstance.value.options, "order", {
        get() {
          return order2.value;
        },
        set(value) {
          order2.value = value;
        }
      });
      Object.defineProperty(aplayerInstance.value.audio, "volume", {
        get() {
          return volume.value;
        },
        set(value) {
          volume.value = value;
        }
      });
    };
    const format2 = (seconds) => {
      var _a;
      if (seconds) {
        return (_a = (seconds / 60).toFixed(2)) == null ? void 0 : _a.replace(".", ":");
      }
      return "0:00";
    };
    const toggleNoSleep = () => {
      if (noSleep.isEnabled) {
        noSleep.disable();
        isNoSleepEnabled.value = false;
      } else {
        noSleep.enable();
        isNoSleepEnabled.value = true;
        showToast("停留在此页面，并保持屏幕常亮，可使歌曲得以在前台页面持续播放");
      }
    };
    watch(curSongIndex, () => {
      store.setCurSongIndex(curSongIndex.value);
    });
    const isAplayerInstalled = ref(false);
    const shouldBeStop = ref(false);
    watch(
      aplayerInstance,
      () => {
        var _b, _d, _e, _f;
        curSongIndex.value = (_b = aplayerInstance.value) == null ? void 0 : _b.list.index;
        if (aplayerInstance.value) {
          if (isAplayerInstalled.value) {
            return;
          }
          isAplayerInstalled.value = true;
          currentTime.value = ((_d = aplayerInstance.value) == null ? void 0 : _d.audio.currentTime) || 0;
          duration.value = ((_e = aplayerInstance.value) == null ? void 0 : _e.audio.duration) || 0;
          isPaused.value = (_f = aplayerInstance.value) == null ? void 0 : _f.audio.paused;
          observeOptions();
          aplayerInstance.value.on("error", (err) => {
            const index = curSongIndex.value;
            store.playlist[index].updateTime = -1;
            aplayerInstance.value.list.audios[index].updateTime = -1;
            showConfirmDialog({
              title: "提示",
              message: `歌曲（${song.value.name}）播放出错，是否切换下一首歌曲？`
            }).then(() => {
              onSkipForward();
              if (!isPaused.value) {
                onPlay();
              }
            }).catch(() => {
              isPaused.value = true;
            });
          });
          aplayerInstance.value.on("play", () => {
            var _a2;
            if (((_a2 = aplayerInstance.value) == null ? void 0 : _a2.audio.src) !== song.value.url) {
              aplayerInstance.value.pause();
              isPaused.value = true;
              return;
            }
            if (shouldBeStop.value) {
              aplayerInstance.value.pause();
              isPaused.value = true;
              return;
            }
            isPaused.value = false;
          });
          aplayerInstance.value.on("pause", () => {
            isPaused.value = true;
            if (shouldBeStop.value) {
              shouldBeStop.value = false;
            }
          });
          aplayerInstance.value.on("canplay", () => {
            var _a2, _b2;
            duration.value = (_a2 = aplayerInstance.value) == null ? void 0 : _a2.audio.duration;
            isPaused.value = (_b2 = aplayerInstance.value) == null ? void 0 : _b2.audio.paused;
          });
          aplayerInstance.value.on("timeupdate", () => {
            var _a2, _b2;
            currentTime.value = (_a2 = aplayerInstance.value) == null ? void 0 : _a2.audio.currentTime;
            isPaused.value = (_b2 = aplayerInstance.value) == null ? void 0 : _b2.audio.paused;
          });
          aplayerInstance.value.on("listswitch", ({ index }) => {
            curSongIndex.value = index;
            currentTime.value = 0;
            duration.value = 0;
          });
        }
      },
      { deep: true, immediate: true }
    );
    return (_ctx, _cache) => {
      const _component_van_slider = Slider;
      const _component_van_popover = Popover;
      return openBlock(), createElementBlock("div", {
        class: "music-player",
        style: normalizeStyle({ backgroundImage: song.value ? `url(${song.value.cover})` : "none" })
      }, [
        createVNode(AppHeader, { class: "fixed left-0 top-0 w-full z-3 box-border" }, {
          default: withCtx(() => [
            createBaseVNode("div", _hoisted_1$1, [
              createVNode(BaseButton, {
                size: "32px",
                onClick: toggleNoSleep
              }, {
                default: withCtx(() => [
                  createVNode(unref(Flashlight), {
                    theme: "outline",
                    size: "28",
                    fill: isNoSleepEnabled.value ? "#4ddd4c" : "#fff",
                    strokeWidth: 4
                  }, null, 8, ["fill"])
                ]),
                _: 1
              }),
              createVNode(BaseButton, {
                size: "32px",
                class: "ml-10px",
                onClick: _cache[0] || (_cache[0] = ($event) => showAbout.value = true)
              }, {
                default: withCtx(() => [
                  createVNode(unref(Info), {
                    theme: "outline",
                    size: "28",
                    strokeWidth: 4,
                    fill: "#4ddd4c"
                  })
                ]),
                _: 1
              })
            ])
          ]),
          _: 1
        }),
        !song.value ? (openBlock(), createElementBlock("div", _hoisted_2$1, [
          createVNode(_sfc_main$6)
        ])) : (openBlock(), createElementBlock("div", _hoisted_3$1, [
          createBaseVNode("div", _hoisted_4$1, [
            createBaseVNode("div", _hoisted_5$1, [
              createBaseVNode("img", {
                src: song.value.cover,
                class: "cover"
              }, null, 8, _hoisted_6)
            ]),
            createBaseVNode("div", _hoisted_7, [
              createBaseVNode("p", null, toDisplayString(song.value.name) + " - " + toDisplayString(song.value.artist), 1),
              createBaseVNode("p", _hoisted_8, [
                createBaseVNode("span", _hoisted_9, "来源：" + toDisplayString(song.value.page), 1),
                createBaseVNode("a", {
                  href: song.value.page,
                  target: "_blank",
                  rel: "nofollow noopener"
                }, [
                  createVNode(unref(Share), {
                    theme: "outline",
                    size: "20",
                    fill: "#fff"
                  })
                ], 8, _hoisted_10)
              ]),
              createBaseVNode("div", _hoisted_11, [
                createVNode(_component_van_slider, {
                  modelValue: currentTime.value,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => currentTime.value = $event),
                  max: duration.value || 100,
                  barHeight: "4",
                  "active-color": "#4ddd4c",
                  onChange: onSeek,
                  onDragStart: onProgressbarDragStart,
                  onDragEnd: onProgressbarDragEnd
                }, {
                  button: withCtx(() => [
                    createBaseVNode("div", {
                      class: "custom-button",
                      style: normalizeStyle({ width: `${size2.value}px`, height: `${size2.value}px`, borderRadius: `${size2.value}px` })
                    }, null, 4)
                  ]),
                  _: 1
                }, 8, ["modelValue", "max"]),
                createBaseVNode("div", _hoisted_12, [
                  createBaseVNode("span", null, toDisplayString(format2(currentTime.value)), 1),
                  createBaseVNode("span", null, toDisplayString(format2(duration.value)), 1)
                ])
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_13, [
            createBaseVNode("div", _hoisted_14, [
              createVNode(BaseButton, null, {
                default: withCtx(() => [
                  createVNode(unref(GoStart), {
                    theme: "outline",
                    size: "40",
                    fill: "#ffffff",
                    strokeWidth: 4,
                    onClick: onSkipBack
                  })
                ]),
                _: 1
              }),
              createVNode(BaseButton, { class: "mx-16px" }, {
                default: withCtx(() => [
                  !isPaused.value ? (openBlock(), createBlock(unref(PauseOne), {
                    key: 0,
                    theme: "outline",
                    size: "56",
                    fill: "#ffffff",
                    strokeWidth: 4,
                    onClick: onPause
                  })) : (openBlock(), createBlock(unref(Play), {
                    key: 1,
                    theme: "outline",
                    size: "56",
                    fill: "#ffffff",
                    strokeWidth: 4,
                    onClick: onPlay
                  }))
                ]),
                _: 1
              }),
              createVNode(BaseButton, null, {
                default: withCtx(() => [
                  createVNode(unref(GoEnd), {
                    theme: "outline",
                    size: "40",
                    fill: "#ffffff",
                    strokeWidth: 4,
                    onClick: onSkipForward
                  })
                ]),
                _: 1
              })
            ]),
            createBaseVNode("div", _hoisted_15, [
              createVNode(BaseButton, {
                size: "36px",
                onClick: updateOrderSetting
              }, {
                default: withCtx(() => [
                  getOrderSetting.value === "list" ? (openBlock(), createBlock(unref(ArrowRight), {
                    key: 0,
                    theme: "outline",
                    size: "30",
                    fill: "#ffffff",
                    strokeWidth: storkeWidthForSmallIcon
                  })) : (openBlock(), createBlock(unref(ShuffleOne), {
                    key: 1,
                    theme: "outline",
                    size: "30",
                    fill: "#ffffff",
                    strokeWidth: storkeWidthForSmallIcon
                  }))
                ]),
                _: 1
              }),
              createVNode(BaseButton, {
                size: "36px",
                onClick: updateLoopSetting
              }, {
                default: withCtx(() => [
                  getLoopSetting.value === "all" ? (openBlock(), createBlock(unref(PlayCycle), {
                    key: 0,
                    theme: "outline",
                    size: "30",
                    fill: "#ffffff",
                    strokeWidth: storkeWidthForSmallIcon
                  })) : getLoopSetting.value === "one" ? (openBlock(), createBlock(unref(PlayOnce), {
                    key: 1,
                    theme: "outline",
                    size: "30",
                    fill: "#ffffff",
                    strokeWidth: storkeWidthForSmallIcon
                  })) : (openBlock(), createBlock(_sfc_main$7, {
                    key: 2,
                    fill: "#fff"
                  }))
                ]),
                _: 1
              }),
              createVNode(_component_van_popover, {
                show: showVolumePopover.value,
                "onUpdate:show": _cache[2] || (_cache[2] = ($event) => showVolumePopover.value = $event),
                placement: "top",
                theme: "dark"
              }, {
                reference: withCtx(() => [
                  createVNode(BaseButton, { size: "36px" }, {
                    default: withCtx(() => [
                      createVNode(unref(VolumeNotice), {
                        theme: "outline",
                        size: "30",
                        fill: "#ffffff",
                        strokeWidth: storkeWidthForSmallIcon
                      })
                    ]),
                    _: 1
                  })
                ]),
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_16, [
                    createVNode(_component_van_slider, {
                      "model-value": volume.value,
                      "bar-height": "6px",
                      "active-color": "#4ddd4c",
                      max: 1,
                      step: 0.1,
                      vertical: "",
                      reverse: "",
                      "onUpdate:modelValue": updateVolume
                    }, {
                      button: withCtx(() => [
                        _hoisted_17
                      ]),
                      _: 1
                    }, 8, ["model-value"])
                  ])
                ]),
                _: 1
              }, 8, ["show"]),
              createVNode(BaseButton, { size: "36px" }, {
                default: withCtx(() => [
                  createVNode(unref(MusicList), {
                    theme: "outline",
                    size: "32",
                    fill: "#ffffff",
                    strokeWidth: storkeWidthForSmallIcon,
                    onClick: _cache[3] || (_cache[3] = ($event) => showPlayList.value = true)
                  })
                ]),
                _: 1
              })
            ])
          ])
        ])),
        createVNode(_sfc_main$2, {
          show: showPlayList.value,
          "onUpdate:show": _cache[4] || (_cache[4] = ($event) => showPlayList.value = $event)
        }, null, 8, ["show"]),
        createVNode(AboutDialog, {
          show: showAbout.value,
          "onUpdate:show": _cache[5] || (_cache[5] = ($event) => showAbout.value = $event)
        }, null, 8, ["show"])
      ], 4);
    };
  }
};
const MusicPlayer = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-6fa33c71"]]);
var APlayer_min = { exports: {} };
(function(module, exports) {
  !function(e, t2) {
    module.exports = t2();
  }(window, function() {
    return function(e) {
      var t2 = {};
      function n(i) {
        if (t2[i])
          return t2[i].exports;
        var a = t2[i] = { i, l: false, exports: {} };
        return e[i].call(a.exports, a, a.exports, n), a.l = true, a.exports;
      }
      return n.m = e, n.c = t2, n.d = function(e2, t3, i) {
        n.o(e2, t3) || Object.defineProperty(e2, t3, { configurable: false, enumerable: true, get: i });
      }, n.r = function(e2) {
        Object.defineProperty(e2, "__esModule", { value: true });
      }, n.n = function(e2) {
        var t3 = e2 && e2.__esModule ? function() {
          return e2.default;
        } : function() {
          return e2;
        };
        return n.d(t3, "a", t3), t3;
      }, n.o = function(e2, t3) {
        return Object.prototype.hasOwnProperty.call(e2, t3);
      }, n.p = "/", n(n.s = 41);
    }([function(e, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var i = /mobile/i.test(window.navigator.userAgent), a = { secondToTime: function(e2) {
        var t3 = Math.floor(e2 / 3600), n2 = Math.floor((e2 - 3600 * t3) / 60), i2 = Math.floor(e2 - 3600 * t3 - 60 * n2);
        return (t3 > 0 ? [t3, n2, i2] : [n2, i2]).map(function(e3) {
          return e3 < 10 ? "0" + e3 : "" + e3;
        }).join(":");
      }, getElementViewLeft: function(e2) {
        var t3 = e2.offsetLeft, n2 = e2.offsetParent, i2 = document.body.scrollLeft + document.documentElement.scrollLeft;
        if (document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement)
          for (; null !== n2 && n2 !== e2; )
            t3 += n2.offsetLeft, n2 = n2.offsetParent;
        else
          for (; null !== n2; )
            t3 += n2.offsetLeft, n2 = n2.offsetParent;
        return t3 - i2;
      }, getElementViewTop: function(e2, t3) {
        for (var n2, i2 = e2.offsetTop, a2 = e2.offsetParent; null !== a2; )
          i2 += a2.offsetTop, a2 = a2.offsetParent;
        return n2 = document.body.scrollTop + document.documentElement.scrollTop, t3 ? i2 : i2 - n2;
      }, isMobile: i, storage: { set: function(e2, t3) {
        localStorage.setItem(e2, t3);
      }, get: function(e2) {
        return localStorage.getItem(e2);
      } }, nameMap: { dragStart: i ? "touchstart" : "mousedown", dragMove: i ? "touchmove" : "mousemove", dragEnd: i ? "touchend" : "mouseup" }, randomOrder: function(e2) {
        return function(e3) {
          for (var t3 = e3.length - 1; t3 >= 0; t3--) {
            var n2 = Math.floor(Math.random() * (t3 + 1)), i2 = e3[n2];
            e3[n2] = e3[t3], e3[t3] = i2;
          }
          return e3;
        }([].concat(function(e3) {
          if (Array.isArray(e3)) {
            for (var t3 = 0, n2 = Array(e3.length); t3 < e3.length; t3++)
              n2[t3] = e3[t3];
            return n2;
          }
          return Array.from(e3);
        }(Array(e2))).map(function(e3, t3) {
          return t3;
        }));
      } };
      t2.default = a;
    }, function(e, t2, n) {
      var i = n(2);
      e.exports = function(e2) {
        e2 = e2 || {};
        var t3 = "", n2 = i.$each, a = e2.audio, r = (e2.$value, e2.$index, i.$escape), o = e2.theme, s = e2.index;
        return n2(a, function(e3, n3) {
          t3 += '\n<li>\n    <span class="aplayer-list-cur" style="background-color: ', t3 += r(e3.theme || o), t3 += ';"></span>\n    <span class="aplayer-list-index">', t3 += r(n3 + s), t3 += '</span>\n    <span class="aplayer-list-title">', t3 += r(e3.name), t3 += '</span>\n    <span class="aplayer-list-author">', t3 += r(e3.artist), t3 += "</span>\n</li>\n";
        }), t3;
      };
    }, function(e, t2, n) {
      e.exports = n(15);
    }, function(e, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var i = g(n(33)), a = g(n(32)), r = g(n(31)), o = g(n(30)), s = g(n(29)), l = g(n(28)), u = g(n(27)), c = g(n(26)), p2 = g(n(25)), d = g(n(24)), h2 = g(n(23)), y = g(n(22)), f = g(n(21)), v = g(n(20)), m = g(n(19));
      function g(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }
      var w = { play: i.default, pause: a.default, volumeUp: r.default, volumeDown: o.default, volumeOff: s.default, orderRandom: l.default, orderList: u.default, menu: c.default, loopAll: p2.default, loopOne: d.default, loopNone: h2.default, loading: y.default, right: f.default, skip: v.default, lrc: m.default };
      t2.default = w;
    }, function(e, t2, n) {
      var i, a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e2) {
        return typeof e2;
      } : function(e2) {
        return e2 && "function" == typeof Symbol && e2.constructor === Symbol && e2 !== Symbol.prototype ? "symbol" : typeof e2;
      };
      i = /* @__PURE__ */ function() {
        return this;
      }();
      try {
        i = i || Function("return this")() || (0, eval)("this");
      } catch (e2) {
        "object" === ("undefined" == typeof window ? "undefined" : a(window)) && (i = window);
      }
      e.exports = i;
    }, function(e, t2, n) {
      var i, a, r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e2) {
        return typeof e2;
      } : function(e2) {
        return e2 && "function" == typeof Symbol && e2.constructor === Symbol && e2 !== Symbol.prototype ? "symbol" : typeof e2;
      };
      void 0 === (a = "function" == typeof (i = function() {
        if ("object" === ("undefined" == typeof window ? "undefined" : r(window)) && void 0 !== document.querySelectorAll && void 0 !== window.pageYOffset && void 0 !== history.pushState) {
          var e2 = function(e3, t4, n3, i2) {
            return n3 > i2 ? t4 : e3 + (t4 - e3) * ((a2 = n3 / i2) < 0.5 ? 4 * a2 * a2 * a2 : (a2 - 1) * (2 * a2 - 2) * (2 * a2 - 2) + 1);
            var a2;
          }, t3 = function(t4, n3, i2, a2) {
            n3 = n3 || 500;
            var r2 = (a2 = a2 || window).scrollTop || window.pageYOffset;
            if ("number" == typeof t4)
              var o = parseInt(t4);
            else
              var o = function(e3, t5) {
                return "HTML" === e3.nodeName ? -t5 : e3.getBoundingClientRect().top + t5;
              }(t4, r2);
            var s = Date.now(), l = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function(e3) {
              window.setTimeout(e3, 15);
            };
            !function u() {
              var c = Date.now() - s;
              a2 !== window ? a2.scrollTop = e2(r2, o, c, n3) : window.scroll(0, e2(r2, o, c, n3)), c > n3 ? "function" == typeof i2 && i2(t4) : l(u);
            }();
          }, n2 = function(e3) {
            if (!e3.defaultPrevented) {
              e3.preventDefault(), location.hash !== this.hash && window.history.pushState(null, null, this.hash);
              var n3 = document.getElementById(this.hash.substring(1));
              if (!n3)
                return;
              t3(n3, 500, function(e4) {
                location.replace("#" + e4.id);
              });
            }
          };
          return document.addEventListener("DOMContentLoaded", function() {
            for (var e3, t4 = document.querySelectorAll('a[href^="#"]:not([href="#"])'), i2 = t4.length; e3 = t4[--i2]; )
              e3.addEventListener("click", n2, false);
          }), t3;
        }
      }) ? i.call(t2, n, t2, e) : i) || (e.exports = a);
    }, function(e, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var i = /* @__PURE__ */ function() {
        function e2(e3, t3) {
          for (var n2 = 0; n2 < t3.length; n2++) {
            var i2 = t3[n2];
            i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e3, i2.key, i2);
          }
        }
        return function(t3, n2, i2) {
          return n2 && e2(t3.prototype, n2), i2 && e2(t3, i2), t3;
        };
      }(), a = s(n(1)), r = s(n(0)), o = s(n(5));
      function s(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }
      var l = function() {
        function e2(t3) {
          !function(e3, t4) {
            if (!(e3 instanceof t4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e2), this.player = t3, this.index = 0, this.audios = this.player.options.audio, this.bindEvents();
        }
        return i(e2, [{ key: "bindEvents", value: function() {
          var e3 = this;
          this.player.template.list.addEventListener("click", function(t3) {
            var n2 = void 0;
            n2 = "LI" === t3.target.tagName.toUpperCase() ? t3.target : t3.target.parentElement;
            var i2 = parseInt(n2.getElementsByClassName("aplayer-list-index")[0].innerHTML) - 1;
            i2 !== e3.index ? (e3.switch(i2), e3.player.play()) : e3.player.toggle();
          });
        } }, { key: "show", value: function() {
          this.player.events.trigger("listshow"), this.player.template.list.classList.remove("aplayer-list-hide"), this.player.template.listOl.scrollTop = 33 * this.index;
        } }, { key: "hide", value: function() {
          this.player.events.trigger("listhide"), this.player.template.list.classList.add("aplayer-list-hide");
        } }, { key: "toggle", value: function() {
          this.player.template.list.classList.contains("aplayer-list-hide") ? this.show() : this.hide();
        } }, { key: "add", value: function(e3) {
          this.player.events.trigger("listadd", { audios: e3 }), "[object Array]" !== Object.prototype.toString.call(e3) && (e3 = [e3]), e3.map(function(e4) {
            return e4.name = e4.name || e4.title || "Audio name", e4.artist = e4.artist || e4.author || "Audio artist", e4.cover = e4.cover || e4.pic, e4.type = e4.type || "normal", e4;
          });
          var t3 = !(this.audios.length > 1), n2 = 0 === this.audios.length;
          this.player.template.listOl.innerHTML += (0, a.default)({ theme: this.player.options.theme, audio: e3, index: this.audios.length + 1 }), this.audios = this.audios.concat(e3), t3 && this.audios.length > 1 && this.player.container.classList.add("aplayer-withlist"), this.player.randomOrder = r.default.randomOrder(this.audios.length), this.player.template.listCurs = this.player.container.querySelectorAll(".aplayer-list-cur"), this.player.template.listCurs[this.audios.length - 1].style.backgroundColor = e3.theme || this.player.options.theme, n2 && ("random" === this.player.options.order ? this.switch(this.player.randomOrder[0]) : this.switch(0));
        } }, { key: "remove", value: function(e3) {
          if (this.player.events.trigger("listremove", { index: e3 }), this.audios[e3])
            if (this.audios.length > 1) {
              var t3 = this.player.container.querySelectorAll(".aplayer-list li");
              t3[e3].remove(), this.audios.splice(e3, 1), this.player.lrc && this.player.lrc.remove(e3), e3 === this.index && (this.audios[e3] ? this.switch(e3) : this.switch(e3 - 1)), this.index > e3 && this.index--;
              for (var n2 = e3; n2 < t3.length; n2++)
                t3[n2].getElementsByClassName("aplayer-list-index")[0].textContent = n2;
              1 === this.audios.length && this.player.container.classList.remove("aplayer-withlist"), this.player.template.listCurs = this.player.container.querySelectorAll(".aplayer-list-cur");
            } else
              this.clear();
        } }, { key: "switch", value: function(e3) {
          if (this.player.events.trigger("listswitch", { index: e3 }), void 0 !== e3 && this.audios[e3]) {
            this.index = e3;
            var t3 = this.audios[this.index];
            this.player.template.pic.style.backgroundImage = t3.cover ? "url('" + t3.cover + "')" : "", this.player.theme(this.audios[this.index].theme || this.player.options.theme, this.index, false), this.player.template.title.innerHTML = t3.name, this.player.template.author.innerHTML = t3.artist ? " - " + t3.artist : "";
            var n2 = this.player.container.getElementsByClassName("aplayer-list-light")[0];
            n2 && n2.classList.remove("aplayer-list-light"), this.player.container.querySelectorAll(".aplayer-list li")[this.index].classList.add("aplayer-list-light"), (0, o.default)(33 * this.index, 500, null, this.player.template.listOl), this.player.setAudio(t3), this.player.lrc && this.player.lrc.switch(this.index), this.player.lrc && this.player.lrc.update(0), 1 !== this.player.duration && (this.player.template.dtime.innerHTML = r.default.secondToTime(this.player.duration));
          }
        } }, { key: "clear", value: function() {
          this.player.events.trigger("listclear"), this.index = 0, this.player.container.classList.remove("aplayer-withlist"), this.player.pause(), this.audios = [], this.player.lrc && this.player.lrc.clear(), this.player.audio.src = "", this.player.template.listOl.innerHTML = "", this.player.template.pic.style.backgroundImage = "", this.player.theme(this.player.options.theme, this.index, false), this.player.template.title.innerHTML = "No audio", this.player.template.author.innerHTML = "", this.player.bar.set("loaded", 0, "width"), this.player.template.dtime.innerHTML = r.default.secondToTime(0);
        } }]), e2;
      }();
      t2.default = l;
    }, function(e, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var i = /* @__PURE__ */ function() {
        function e2(e3, t3) {
          for (var n2 = 0; n2 < t3.length; n2++) {
            var i2 = t3[n2];
            i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e3, i2.key, i2);
          }
        }
        return function(t3, n2, i2) {
          return n2 && e2(t3.prototype, n2), i2 && e2(t3, i2), t3;
        };
      }();
      var a = function() {
        function e2() {
          !function(e3, t3) {
            if (!(e3 instanceof t3))
              throw new TypeError("Cannot call a class as a function");
          }(this, e2), this.events = {}, this.audioEvents = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "mozaudioavailable", "pause", "play", "playing", "progress", "ratechange", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], this.playerEvents = ["destroy", "listshow", "listhide", "listadd", "listremove", "listswitch", "listclear", "noticeshow", "noticehide", "lrcshow", "lrchide"];
        }
        return i(e2, [{ key: "on", value: function(e3, t3) {
          this.type(e3) && "function" == typeof t3 && (this.events[e3] || (this.events[e3] = []), this.events[e3].push(t3));
        } }, { key: "trigger", value: function(e3, t3) {
          if (this.events[e3] && this.events[e3].length)
            for (var n2 = 0; n2 < this.events[e3].length; n2++)
              this.events[e3][n2](t3);
        } }, { key: "type", value: function(e3) {
          return -1 !== this.playerEvents.indexOf(e3) ? "player" : -1 !== this.audioEvents.indexOf(e3) ? "audio" : (void 0, null);
        } }]), e2;
      }();
      t2.default = a;
    }, function(e, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var i = /* @__PURE__ */ function() {
        function e2(e3, t3) {
          for (var n2 = 0; n2 < t3.length; n2++) {
            var i2 = t3[n2];
            i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e3, i2.key, i2);
          }
        }
        return function(t3, n2, i2) {
          return n2 && e2(t3.prototype, n2), i2 && e2(t3, i2), t3;
        };
      }();
      var a = function() {
        function e2(t3) {
          !function(e3, t4) {
            if (!(e3 instanceof t4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e2), this.player = t3, window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(e3) {
            window.setTimeout(e3, 1e3 / 60);
          }, this.types = ["loading"], this.init();
        }
        return i(e2, [{ key: "init", value: function() {
          var e3 = this;
          this.types.forEach(function(t3) {
            e3["init" + t3 + "Checker"]();
          });
        } }, { key: "initloadingChecker", value: function() {
          var e3 = this, t3 = 0, n2 = 0, i2 = false;
          this.loadingChecker = setInterval(function() {
            e3.enableloadingChecker && (n2 = e3.player.audio.currentTime, i2 || n2 !== t3 || e3.player.audio.paused || (e3.player.container.classList.add("aplayer-loading"), i2 = true), i2 && n2 > t3 && !e3.player.audio.paused && (e3.player.container.classList.remove("aplayer-loading"), i2 = false), t3 = n2);
          }, 100);
        } }, { key: "enable", value: function(e3) {
          this["enable" + e3 + "Checker"] = true, "fps" === e3 && this.initfpsChecker();
        } }, { key: "disable", value: function(e3) {
          this["enable" + e3 + "Checker"] = false;
        } }, { key: "destroy", value: function() {
          var e3 = this;
          this.types.forEach(function(t3) {
            e3["enable" + t3 + "Checker"] = false, e3[t3 + "Checker"] && clearInterval(e3[t3 + "Checker"]);
          });
        } }]), e2;
      }();
      t2.default = a;
    }, function(e, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var i = /* @__PURE__ */ function() {
        function e2(e3, t3) {
          for (var n2 = 0; n2 < t3.length; n2++) {
            var i2 = t3[n2];
            i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e3, i2.key, i2);
          }
        }
        return function(t3, n2, i2) {
          return n2 && e2(t3.prototype, n2), i2 && e2(t3, i2), t3;
        };
      }(), a = o(n(0)), r = o(n(3));
      function o(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }
      var s = function() {
        function e2(t3) {
          !function(e3, t4) {
            if (!(e3 instanceof t4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e2), this.player = t3, this.initPlayButton(), this.initPlayBar(), this.initOrderButton(), this.initLoopButton(), this.initMenuButton(), a.default.isMobile || this.initVolumeButton(), this.initMiniSwitcher(), this.initSkipButton(), this.initLrcButton();
        }
        return i(e2, [{ key: "initPlayButton", value: function() {
          var e3 = this;
          this.player.template.pic.addEventListener("click", function() {
            e3.player.toggle();
          });
        } }, { key: "initPlayBar", value: function() {
          var e3 = this, t3 = function(t4) {
            var n3 = ((t4.clientX || t4.changedTouches[0].clientX) - a.default.getElementViewLeft(e3.player.template.barWrap)) / e3.player.template.barWrap.clientWidth;
            n3 = Math.max(n3, 0), n3 = Math.min(n3, 1), e3.player.bar.set("played", n3, "width"), e3.player.lrc && e3.player.lrc.update(n3 * e3.player.duration), e3.player.template.ptime.innerHTML = a.default.secondToTime(n3 * e3.player.duration);
          }, n2 = function n3(i2) {
            document.removeEventListener(a.default.nameMap.dragEnd, n3), document.removeEventListener(a.default.nameMap.dragMove, t3);
            var r2 = ((i2.clientX || i2.changedTouches[0].clientX) - a.default.getElementViewLeft(e3.player.template.barWrap)) / e3.player.template.barWrap.clientWidth;
            r2 = Math.max(r2, 0), r2 = Math.min(r2, 1), e3.player.bar.set("played", r2, "width"), e3.player.seek(e3.player.bar.get("played", "width") * e3.player.duration), e3.player.disableTimeupdate = false;
          };
          this.player.template.barWrap.addEventListener(a.default.nameMap.dragStart, function() {
            e3.player.disableTimeupdate = true, document.addEventListener(a.default.nameMap.dragMove, t3), document.addEventListener(a.default.nameMap.dragEnd, n2);
          });
        } }, { key: "initVolumeButton", value: function() {
          var e3 = this;
          this.player.template.volumeButton.addEventListener("click", function() {
            e3.player.audio.muted ? (e3.player.audio.muted = false, e3.player.switchVolumeIcon(), e3.player.bar.set("volume", e3.player.volume(), "height")) : (e3.player.audio.muted = true, e3.player.switchVolumeIcon(), e3.player.bar.set("volume", 0, "height"));
          });
          var t3 = function(t4) {
            var n3 = 1 - ((t4.clientY || t4.changedTouches[0].clientY) - a.default.getElementViewTop(e3.player.template.volumeBar, e3.player.options.fixed)) / e3.player.template.volumeBar.clientHeight;
            n3 = Math.max(n3, 0), n3 = Math.min(n3, 1), e3.player.volume(n3);
          }, n2 = function n3(i2) {
            e3.player.template.volumeBarWrap.classList.remove("aplayer-volume-bar-wrap-active"), document.removeEventListener(a.default.nameMap.dragEnd, n3), document.removeEventListener(a.default.nameMap.dragMove, t3);
            var r2 = 1 - ((i2.clientY || i2.changedTouches[0].clientY) - a.default.getElementViewTop(e3.player.template.volumeBar, e3.player.options.fixed)) / e3.player.template.volumeBar.clientHeight;
            r2 = Math.max(r2, 0), r2 = Math.min(r2, 1), e3.player.volume(r2);
          };
          this.player.template.volumeBarWrap.addEventListener(a.default.nameMap.dragStart, function() {
            e3.player.template.volumeBarWrap.classList.add("aplayer-volume-bar-wrap-active"), document.addEventListener(a.default.nameMap.dragMove, t3), document.addEventListener(a.default.nameMap.dragEnd, n2);
          });
        } }, { key: "initOrderButton", value: function() {
          var e3 = this;
          this.player.template.order.addEventListener("click", function() {
            "list" === e3.player.options.order ? (e3.player.options.order = "random", e3.player.template.order.innerHTML = r.default.orderRandom) : "random" === e3.player.options.order && (e3.player.options.order = "list", e3.player.template.order.innerHTML = r.default.orderList);
          });
        } }, { key: "initLoopButton", value: function() {
          var e3 = this;
          this.player.template.loop.addEventListener("click", function() {
            e3.player.list.audios.length > 1 ? "one" === e3.player.options.loop ? (e3.player.options.loop = "none", e3.player.template.loop.innerHTML = r.default.loopNone) : "none" === e3.player.options.loop ? (e3.player.options.loop = "all", e3.player.template.loop.innerHTML = r.default.loopAll) : "all" === e3.player.options.loop && (e3.player.options.loop = "one", e3.player.template.loop.innerHTML = r.default.loopOne) : "one" === e3.player.options.loop || "all" === e3.player.options.loop ? (e3.player.options.loop = "none", e3.player.template.loop.innerHTML = r.default.loopNone) : "none" === e3.player.options.loop && (e3.player.options.loop = "all", e3.player.template.loop.innerHTML = r.default.loopAll);
          });
        } }, { key: "initMenuButton", value: function() {
          var e3 = this;
          this.player.template.menu.addEventListener("click", function() {
            e3.player.list.toggle();
          });
        } }, { key: "initMiniSwitcher", value: function() {
          var e3 = this;
          this.player.template.miniSwitcher.addEventListener("click", function() {
            e3.player.setMode("mini" === e3.player.mode ? "normal" : "mini");
          });
        } }, { key: "initSkipButton", value: function() {
          var e3 = this;
          this.player.template.skipBackButton.addEventListener("click", function() {
            e3.player.skipBack();
          }), this.player.template.skipForwardButton.addEventListener("click", function() {
            e3.player.skipForward();
          }), this.player.template.skipPlayButton.addEventListener("click", function() {
            e3.player.toggle();
          });
        } }, { key: "initLrcButton", value: function() {
          var e3 = this;
          this.player.template.lrcButton.addEventListener("click", function() {
            e3.player.template.lrcButton.classList.contains("aplayer-icon-lrc-inactivity") ? (e3.player.template.lrcButton.classList.remove("aplayer-icon-lrc-inactivity"), e3.player.lrc && e3.player.lrc.show()) : (e3.player.template.lrcButton.classList.add("aplayer-icon-lrc-inactivity"), e3.player.lrc && e3.player.lrc.hide());
          });
        } }]), e2;
      }();
      t2.default = s;
    }, function(e, t2, n) {
      var i = n(2);
      e.exports = function(e2) {
        e2 = e2 || {};
        var t3 = "", n2 = i.$each, a = e2.lyrics, r = (e2.$value, e2.$index, i.$escape);
        return n2(a, function(e3, n3) {
          t3 += "\n    <p", 0 === n3 && (t3 += ' class="aplayer-lrc-current"'), t3 += ">", t3 += r(e3[1]), t3 += "</p>\n";
        }), t3;
      };
    }, function(e, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var i, a = /* @__PURE__ */ function() {
        function e2(e3, t3) {
          for (var n2 = 0; n2 < t3.length; n2++) {
            var i2 = t3[n2];
            i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e3, i2.key, i2);
          }
        }
        return function(t3, n2, i2) {
          return n2 && e2(t3.prototype, n2), i2 && e2(t3, i2), t3;
        };
      }(), r = n(10), o = (i = r) && i.__esModule ? i : { default: i };
      var s = function() {
        function e2(t3) {
          !function(e3, t4) {
            if (!(e3 instanceof t4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e2), this.container = t3.container, this.async = t3.async, this.player = t3.player, this.parsed = [], this.index = 0, this.current = [];
        }
        return a(e2, [{ key: "show", value: function() {
          this.player.events.trigger("lrcshow"), this.player.template.lrcWrap.classList.remove("aplayer-lrc-hide");
        } }, { key: "hide", value: function() {
          this.player.events.trigger("lrchide"), this.player.template.lrcWrap.classList.add("aplayer-lrc-hide");
        } }, { key: "toggle", value: function() {
          this.player.template.lrcWrap.classList.contains("aplayer-lrc-hide") ? this.show() : this.hide();
        } }, { key: "update", value: function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.player.audio.currentTime;
          if (this.index > this.current.length - 1 || e3 < this.current[this.index][0] || !this.current[this.index + 1] || e3 >= this.current[this.index + 1][0])
            for (var t3 = 0; t3 < this.current.length; t3++)
              e3 >= this.current[t3][0] && (!this.current[t3 + 1] || e3 < this.current[t3 + 1][0]) && (this.index = t3, this.container.style.transform = "translateY(" + 16 * -this.index + "px)", this.container.style.webkitTransform = "translateY(" + 16 * -this.index + "px)", this.container.getElementsByClassName("aplayer-lrc-current")[0].classList.remove("aplayer-lrc-current"), this.container.getElementsByTagName("p")[t3].classList.add("aplayer-lrc-current"));
        } }, { key: "switch", value: function(e3) {
          var t3 = this;
          if (!this.parsed[e3])
            if (this.async) {
              this.parsed[e3] = [["00:00", "Loading"]];
              var n2 = new XMLHttpRequest();
              n2.onreadystatechange = function() {
                e3 === t3.player.list.index && 4 === n2.readyState && (n2.status >= 200 && n2.status < 300 || 304 === n2.status ? t3.parsed[e3] = t3.parse(n2.responseText) : (t3.player.notice("LRC file request fails: status " + n2.status), t3.parsed[e3] = [["00:00", "Not available"]]), t3.container.innerHTML = (0, o.default)({ lyrics: t3.parsed[e3] }), t3.update(0), t3.current = t3.parsed[e3]);
              };
              var i2 = this.player.list.audios[e3].lrc;
              n2.open("get", i2, true), n2.send(null);
            } else
              this.player.list.audios[e3].lrc ? this.parsed[e3] = this.parse(this.player.list.audios[e3].lrc) : this.parsed[e3] = [["00:00", "Not available"]];
          this.container.innerHTML = (0, o.default)({ lyrics: this.parsed[e3] }), this.update(0), this.current = this.parsed[e3];
        } }, { key: "parse", value: function(e3) {
          if (e3) {
            for (var t3 = (e3 = e3.replace(/([^\]^\n])\[/g, function(e4, t4) {
              return t4 + "\n[";
            })).split("\n"), n2 = [], i2 = t3.length, a2 = 0; a2 < i2; a2++) {
              var r2 = t3[a2].match(/\[(\d{2}):(\d{2})(\.(\d{2,3}))?]/g), o2 = t3[a2].replace(/.*\[(\d{2}):(\d{2})(\.(\d{2,3}))?]/g, "").replace(/<(\d{2}):(\d{2})(\.(\d{2,3}))?>/g, "").replace(/^\s+|\s+$/g, "");
              if (r2)
                for (var s2 = r2.length, l = 0; l < s2; l++) {
                  var u = /\[(\d{2}):(\d{2})(\.(\d{2,3}))?]/.exec(r2[l]), c = 60 * u[1] + parseInt(u[2]) + (u[4] ? parseInt(u[4]) / (2 === (u[4] + "").length ? 100 : 1e3) : 0);
                  n2.push([c, o2]);
                }
            }
            return (n2 = n2.filter(function(e4) {
              return e4[1];
            })).sort(function(e4, t4) {
              return e4[0] - t4[0];
            }), n2;
          }
          return [];
        } }, { key: "remove", value: function(e3) {
          this.parsed.splice(e3, 1);
        } }, { key: "clear", value: function() {
          this.parsed = [], this.container.innerHTML = "";
        } }]), e2;
      }();
      t2.default = s;
    }, function(e, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var i, a = /* @__PURE__ */ function() {
        function e2(e3, t3) {
          for (var n2 = 0; n2 < t3.length; n2++) {
            var i2 = t3[n2];
            i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e3, i2.key, i2);
          }
        }
        return function(t3, n2, i2) {
          return n2 && e2(t3.prototype, n2), i2 && e2(t3, i2), t3;
        };
      }(), r = n(0), o = (i = r) && i.__esModule ? i : { default: i };
      var s = function() {
        function e2(t3) {
          !function(e3, t4) {
            if (!(e3 instanceof t4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e2), this.storageName = t3.options.storageName, this.data = JSON.parse(o.default.storage.get(this.storageName)), this.data || (this.data = {}), this.data.volume = this.data.volume || t3.options.volume;
        }
        return a(e2, [{ key: "get", value: function(e3) {
          return this.data[e3];
        } }, { key: "set", value: function(e3, t3) {
          this.data[e3] = t3, o.default.storage.set(this.storageName, JSON.stringify(this.data));
        } }]), e2;
      }();
      t2.default = s;
    }, function(e, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var i = /* @__PURE__ */ function() {
        function e2(e3, t3) {
          for (var n2 = 0; n2 < t3.length; n2++) {
            var i2 = t3[n2];
            i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e3, i2.key, i2);
          }
        }
        return function(t3, n2, i2) {
          return n2 && e2(t3.prototype, n2), i2 && e2(t3, i2), t3;
        };
      }();
      var a = function() {
        function e2(t3) {
          !function(e3, t4) {
            if (!(e3 instanceof t4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e2), this.elements = {}, this.elements.volume = t3.volume, this.elements.played = t3.played, this.elements.loaded = t3.loaded;
        }
        return i(e2, [{ key: "set", value: function(e3, t3, n2) {
          t3 = Math.max(t3, 0), t3 = Math.min(t3, 1), this.elements[e3].style[n2] = 100 * t3 + "%";
        } }, { key: "get", value: function(e3, t3) {
          return parseFloat(this.elements[e3].style[t3]) / 100;
        } }]), e2;
      }();
      t2.default = a;
    }, function(e, t2, n) {
      (function(t3) {
        e.exports = false;
        try {
          e.exports = "[object process]" === Object.prototype.toString.call(t3.process);
        } catch (e2) {
        }
      }).call(this, n(4));
    }, function(e, t2, n) {
      (function(t3) {
        var i = n(14), a = Object.create(i ? t3 : window), r = /["&'<>]/;
        a.$escape = function(e2) {
          return function(e3) {
            var t4 = "" + e3, n2 = r.exec(t4);
            if (!n2)
              return e3;
            var i2 = "", a2 = void 0, o = void 0, s = void 0;
            for (a2 = n2.index, o = 0; a2 < t4.length; a2++) {
              switch (t4.charCodeAt(a2)) {
                case 34:
                  s = "&#34;";
                  break;
                case 38:
                  s = "&#38;";
                  break;
                case 39:
                  s = "&#39;";
                  break;
                case 60:
                  s = "&#60;";
                  break;
                case 62:
                  s = "&#62;";
                  break;
                default:
                  continue;
              }
              o !== a2 && (i2 += t4.substring(o, a2)), o = a2 + 1, i2 += s;
            }
            return o !== a2 ? i2 + t4.substring(o, a2) : i2;
          }(function e3(t4) {
            "string" != typeof t4 && (t4 = void 0 === t4 || null === t4 ? "" : "function" == typeof t4 ? e3(t4.call(t4)) : JSON.stringify(t4));
            return t4;
          }(e2));
        }, a.$each = function(e2, t4) {
          if (Array.isArray(e2))
            for (var n2 = 0, i2 = e2.length; n2 < i2; n2++)
              t4(e2[n2], n2);
          else
            for (var a2 in e2)
              t4(e2[a2], a2);
        }, e.exports = a;
      }).call(this, n(4));
    }, function(e, t2, n) {
      var i = n(2);
      e.exports = function(e2) {
        var t3 = "", a = (e2 = e2 || {}).options, r = e2.cover, o = i.$escape, s = e2.icons, l = function(e3) {
          return t3 += e3;
        }, u = e2.getObject;
        e2.theme, e2.audio, e2.index;
        return a.fixed ? (t3 += '\n<div class="aplayer-list', a.listFolded && (t3 += " aplayer-list-hide"), t3 += '"', a.listMaxHeight && (t3 += ' style="max-height: ', t3 += o(a.listMaxHeight), t3 += '"'), t3 += ">\n    <ol", a.listMaxHeight && (t3 += ' style="max-height: ', t3 += o(a.listMaxHeight), t3 += '"'), t3 += ">\n        ", l(n(1)(u({ theme: a.theme, audio: a.audio, index: 1 }))), t3 += '\n    </ol>\n</div>\n<div class="aplayer-body">\n    <div class="aplayer-pic" style="', r && (t3 += "background-image: url(&quot;", t3 += o(r), t3 += "&quot;);"), t3 += "background-color: ", t3 += o(a.theme), t3 += ';">\n        <div class="aplayer-button aplayer-play">', t3 += s.play, t3 += '</div>\n    </div>\n    <div class="aplayer-info" style="display: none;">\n        <div class="aplayer-music">\n            <span class="aplayer-title">No audio</span>\n            <span class="aplayer-author"></span>\n        </div>\n        <div class="aplayer-controller">\n            <div class="aplayer-bar-wrap">\n                <div class="aplayer-bar">\n                    <div class="aplayer-loaded" style="width: 0"></div>\n                    <div class="aplayer-played" style="width: 0; background: ', t3 += o(a.theme), t3 += ';">\n                        <span class="aplayer-thumb" style="background: ', t3 += o(a.theme), t3 += ';">\n                            <span class="aplayer-loading-icon">', t3 += s.loading, t3 += '</span>\n                        </span>\n                    </div>\n                </div>\n            </div>\n            <div class="aplayer-time">\n                <span class="aplayer-time-inner">\n                    <span class="aplayer-ptime">00:00</span> / <span class="aplayer-dtime">00:00</span>\n                </span>\n                <span class="aplayer-icon aplayer-icon-back">\n                    ', t3 += s.skip, t3 += '\n                </span>\n                <span class="aplayer-icon aplayer-icon-play">\n                    ', t3 += s.play, t3 += '\n                </span>\n                <span class="aplayer-icon aplayer-icon-forward">\n                    ', t3 += s.skip, t3 += '\n                </span>\n                <div class="aplayer-volume-wrap">\n                    <button type="button" class="aplayer-icon aplayer-icon-volume-down">\n                        ', t3 += s.volumeDown, t3 += '\n                    </button>\n                    <div class="aplayer-volume-bar-wrap">\n                        <div class="aplayer-volume-bar">\n                            <div class="aplayer-volume" style="height: 80%; background: ', t3 += o(a.theme), t3 += ';"></div>\n                        </div>\n                    </div>\n                </div>\n                <button type="button" class="aplayer-icon aplayer-icon-order">\n                    ', "list" === a.order ? t3 += s.orderList : "random" === a.order && (t3 += s.orderRandom), t3 += '\n                </button>\n                <button type="button" class="aplayer-icon aplayer-icon-loop">\n                    ', "one" === a.loop ? t3 += s.loopOne : "all" === a.loop ? t3 += s.loopAll : "none" === a.loop && (t3 += s.loopNone), t3 += '\n                </button>\n                <button type="button" class="aplayer-icon aplayer-icon-menu">\n                    ', t3 += s.menu, t3 += '\n                </button>\n                <button type="button" class="aplayer-icon aplayer-icon-lrc">\n                    ', t3 += s.lrc, t3 += '\n                </button>\n            </div>\n        </div>\n    </div>\n    <div class="aplayer-notice"></div>\n    <div class="aplayer-miniswitcher"><button class="aplayer-icon">', t3 += s.right, t3 += '</button></div>\n</div>\n<div class="aplayer-lrc">\n    <div class="aplayer-lrc-contents" style="transform: translateY(0); -webkit-transform: translateY(0);"></div>\n</div>\n') : (t3 += '\n<div class="aplayer-body">\n    <div class="aplayer-pic" style="', r && (t3 += "background-image: url(&quot;", t3 += o(r), t3 += "&quot;);"), t3 += "background-color: ", t3 += o(a.theme), t3 += ';">\n        <div class="aplayer-button aplayer-play">', t3 += s.play, t3 += '</div>\n    </div>\n    <div class="aplayer-info">\n        <div class="aplayer-music">\n            <span class="aplayer-title">No audio</span>\n            <span class="aplayer-author"></span>\n        </div>\n        <div class="aplayer-lrc">\n            <div class="aplayer-lrc-contents" style="transform: translateY(0); -webkit-transform: translateY(0);"></div>\n        </div>\n        <div class="aplayer-controller">\n            <div class="aplayer-bar-wrap">\n                <div class="aplayer-bar">\n                    <div class="aplayer-loaded" style="width: 0"></div>\n                    <div class="aplayer-played" style="width: 0; background: ', t3 += o(a.theme), t3 += ';">\n                        <span class="aplayer-thumb" style="background: ', t3 += o(a.theme), t3 += ';">\n                            <span class="aplayer-loading-icon">', t3 += s.loading, t3 += '</span>\n                        </span>\n                    </div>\n                </div>\n            </div>\n            <div class="aplayer-time">\n                <span class="aplayer-time-inner">\n                    <span class="aplayer-ptime">00:00</span> / <span class="aplayer-dtime">00:00</span>\n                </span>\n                <span class="aplayer-icon aplayer-icon-back">\n                    ', t3 += s.skip, t3 += '\n                </span>\n                <span class="aplayer-icon aplayer-icon-play">\n                    ', t3 += s.play, t3 += '\n                </span>\n                <span class="aplayer-icon aplayer-icon-forward">\n                    ', t3 += s.skip, t3 += '\n                </span>\n                <div class="aplayer-volume-wrap">\n                    <button type="button" class="aplayer-icon aplayer-icon-volume-down">\n                        ', t3 += s.volumeDown, t3 += '\n                    </button>\n                    <div class="aplayer-volume-bar-wrap">\n                        <div class="aplayer-volume-bar">\n                            <div class="aplayer-volume" style="height: 80%; background: ', t3 += o(a.theme), t3 += ';"></div>\n                        </div>\n                    </div>\n                </div>\n                <button type="button" class="aplayer-icon aplayer-icon-order">\n                    ', "list" === a.order ? t3 += s.orderList : "random" === a.order && (t3 += s.orderRandom), t3 += '\n                </button>\n                <button type="button" class="aplayer-icon aplayer-icon-loop">\n                    ', "one" === a.loop ? t3 += s.loopOne : "all" === a.loop ? t3 += s.loopAll : "none" === a.loop && (t3 += s.loopNone), t3 += '\n                </button>\n                <button type="button" class="aplayer-icon aplayer-icon-menu">\n                    ', t3 += s.menu, t3 += '\n                </button>\n                <button type="button" class="aplayer-icon aplayer-icon-lrc">\n                    ', t3 += s.lrc, t3 += '\n                </button>\n            </div>\n        </div>\n    </div>\n    <div class="aplayer-notice"></div>\n    <div class="aplayer-miniswitcher"><button class="aplayer-icon">', t3 += s.right, t3 += '</button></div>\n</div>\n<div class="aplayer-list', a.listFolded && (t3 += " aplayer-list-hide"), t3 += '"', a.listMaxHeight && (t3 += ' style="max-height: ', t3 += o(a.listMaxHeight), t3 += '"'), t3 += ">\n    <ol", a.listMaxHeight && (t3 += ' style="max-height: ', t3 += o(a.listMaxHeight), t3 += '"'), t3 += ">\n        ", l(n(1)(u({ theme: a.theme, audio: a.audio, index: 1 }))), t3 += "\n    </ol>\n</div>\n"), t3;
      };
    }, function(e, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var i = /* @__PURE__ */ function() {
        function e2(e3, t3) {
          for (var n2 = 0; n2 < t3.length; n2++) {
            var i2 = t3[n2];
            i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e3, i2.key, i2);
          }
        }
        return function(t3, n2, i2) {
          return n2 && e2(t3.prototype, n2), i2 && e2(t3, i2), t3;
        };
      }(), a = o(n(3)), r = o(n(16));
      function o(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }
      var s = function() {
        function e2(t3) {
          !function(e3, t4) {
            if (!(e3 instanceof t4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e2), this.container = t3.container, this.options = t3.options, this.randomOrder = t3.randomOrder, this.init();
        }
        return i(e2, [{ key: "init", value: function() {
          var e3 = "";
          this.options.audio.length && (e3 = "random" === this.options.order ? this.options.audio[this.randomOrder[0]].cover : this.options.audio[0].cover), this.container.innerHTML = (0, r.default)({ options: this.options, icons: a.default, cover: e3, getObject: function(e4) {
            return e4;
          } }), this.lrc = this.container.querySelector(".aplayer-lrc-contents"), this.lrcWrap = this.container.querySelector(".aplayer-lrc"), this.ptime = this.container.querySelector(".aplayer-ptime"), this.info = this.container.querySelector(".aplayer-info"), this.time = this.container.querySelector(".aplayer-time"), this.barWrap = this.container.querySelector(".aplayer-bar-wrap"), this.button = this.container.querySelector(".aplayer-button"), this.body = this.container.querySelector(".aplayer-body"), this.list = this.container.querySelector(".aplayer-list"), this.listOl = this.container.querySelector(".aplayer-list ol"), this.listCurs = this.container.querySelectorAll(".aplayer-list-cur"), this.played = this.container.querySelector(".aplayer-played"), this.loaded = this.container.querySelector(".aplayer-loaded"), this.thumb = this.container.querySelector(".aplayer-thumb"), this.volume = this.container.querySelector(".aplayer-volume"), this.volumeBar = this.container.querySelector(".aplayer-volume-bar"), this.volumeButton = this.container.querySelector(".aplayer-time button"), this.volumeBarWrap = this.container.querySelector(".aplayer-volume-bar-wrap"), this.loop = this.container.querySelector(".aplayer-icon-loop"), this.order = this.container.querySelector(".aplayer-icon-order"), this.menu = this.container.querySelector(".aplayer-icon-menu"), this.pic = this.container.querySelector(".aplayer-pic"), this.title = this.container.querySelector(".aplayer-title"), this.author = this.container.querySelector(".aplayer-author"), this.dtime = this.container.querySelector(".aplayer-dtime"), this.notice = this.container.querySelector(".aplayer-notice"), this.miniSwitcher = this.container.querySelector(".aplayer-miniswitcher"), this.skipBackButton = this.container.querySelector(".aplayer-icon-back"), this.skipForwardButton = this.container.querySelector(".aplayer-icon-forward"), this.skipPlayButton = this.container.querySelector(".aplayer-icon-play"), this.lrcButton = this.container.querySelector(".aplayer-icon-lrc");
        } }]), e2;
      }();
      t2.default = s;
    }, function(e, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e2) {
        var t3 = { container: e2.element || document.getElementsByClassName("aplayer")[0], mini: e2.narrow || e2.fixed || false, fixed: false, autoplay: false, mutex: true, lrcType: e2.showlrc || e2.lrc || 0, preload: "auto", theme: "#b7daff", loop: "all", order: "list", volume: 0.7, listFolded: e2.fixed, listMaxHeight: e2.listmaxheight || "250px", audio: e2.music || [], storageName: "aplayer-setting" };
        for (var n2 in t3)
          t3.hasOwnProperty(n2) && !e2.hasOwnProperty(n2) && (e2[n2] = t3[n2]);
        return "[object Array]" !== Object.prototype.toString.call(e2.audio) && (e2.audio = [e2.audio]), e2.audio.map(function(e3) {
          return e3.name = e3.name || e3.title || "Audio name", e3.artist = e3.artist || e3.author || "Audio artist", e3.cover = e3.cover || e3.pic, e3.type = e3.type || "normal", e3;
        }), e2.audio.length <= 1 && "one" === e2.loop && (e2.loop = "all"), e2;
      };
    }, function(e, t2) {
      e.exports = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32"><path d="M26.667 5.333h-21.333c-0 0-0.001 0-0.001 0-1.472 0-2.666 1.194-2.666 2.666 0 0 0 0.001 0 0.001v-0 16c0 0 0 0.001 0 0.001 0 1.472 1.194 2.666 2.666 2.666 0 0 0.001 0 0.001 0h21.333c0 0 0.001 0 0.001 0 1.472 0 2.666-1.194 2.666-2.666 0-0 0-0.001 0-0.001v0-16c0-0 0-0.001 0-0.001 0-1.472-1.194-2.666-2.666-2.666-0 0-0.001 0-0.001 0h0zM5.333 16h5.333v2.667h-5.333v-2.667zM18.667 24h-13.333v-2.667h13.333v2.667zM26.667 24h-5.333v-2.667h5.333v2.667zM26.667 18.667h-13.333v-2.667h13.333v2.667z"></path></svg>';
    }, function(e, t2) {
      e.exports = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32"><path d="M25.468 6.947c-0.326-0.172-0.724-0.151-1.030 0.057l-6.438 4.38v-3.553c0-0.371-0.205-0.71-0.532-0.884-0.326-0.172-0.724-0.151-1.030 0.057l-12 8.164c-0.274 0.186-0.438 0.496-0.438 0.827s0.164 0.641 0.438 0.827l12 8.168c0.169 0.115 0.365 0.174 0.562 0.174 0.16 0 0.321-0.038 0.468-0.116 0.327-0.173 0.532-0.514 0.532-0.884v-3.556l6.438 4.382c0.169 0.115 0.365 0.174 0.562 0.174 0.16 0 0.321-0.038 0.468-0.116 0.327-0.173 0.532-0.514 0.532-0.884v-16.333c0-0.371-0.205-0.71-0.532-0.884z"></path></svg>';
    }, function(e, t2) {
      e.exports = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32"><path d="M22 16l-10.105-10.6-1.895 1.987 8.211 8.613-8.211 8.612 1.895 1.988 8.211-8.613z"></path></svg>';
    }, function(e, t2) {
      e.exports = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32"><path d="M4 16c0-6.6 5.4-12 12-12s12 5.4 12 12c0 1.2-0.8 2-2 2s-2-0.8-2-2c0-4.4-3.6-8-8-8s-8 3.6-8 8 3.6 8 8 8c1.2 0 2 0.8 2 2s-0.8 2-2 2c-6.6 0-12-5.4-12-12z"></path></svg>';
    }, function(e, t2) {
      e.exports = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 29 32"><path d="M2.667 7.027l1.707-1.693 22.293 22.293-1.693 1.707-4-4h-11.64v4l-5.333-5.333 5.333-5.333v4h8.973l-8.973-8.973v0.973h-2.667v-3.64l-4-4zM22.667 17.333h2.667v5.573l-2.667-2.667v-2.907zM22.667 6.667v-4l5.333 5.333-5.333 5.333v-4h-10.907l-2.667-2.667h13.573z"></path></svg>';
    }, function(e, t2) {
      e.exports = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 33 32"><path d="M9.333 9.333h13.333v4l5.333-5.333-5.333-5.333v4h-16v8h2.667v-5.333zM22.667 22.667h-13.333v-4l-5.333 5.333 5.333 5.333v-4h16v-8h-2.667v5.333zM17.333 20v-8h-1.333l-2.667 1.333v1.333h2v5.333h2z"></path></svg>';
    }, function(e, t2) {
      e.exports = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 29 32"><path d="M9.333 9.333h13.333v4l5.333-5.333-5.333-5.333v4h-16v8h2.667v-5.333zM22.667 22.667h-13.333v-4l-5.333 5.333 5.333 5.333v-4h16v-8h-2.667v5.333z"></path></svg>';
    }, function(e, t2) {
      e.exports = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 22 32"><path d="M20.8 14.4q0.704 0 1.152 0.48t0.448 1.12-0.48 1.12-1.12 0.48h-19.2q-0.64 0-1.12-0.48t-0.48-1.12 0.448-1.12 1.152-0.48h19.2zM1.6 11.2q-0.64 0-1.12-0.48t-0.48-1.12 0.448-1.12 1.152-0.48h19.2q0.704 0 1.152 0.48t0.448 1.12-0.48 1.12-1.12 0.48h-19.2zM20.8 20.8q0.704 0 1.152 0.48t0.448 1.12-0.48 1.12-1.12 0.48h-19.2q-0.64 0-1.12-0.48t-0.48-1.12 0.448-1.12 1.152-0.48h19.2z"></path></svg>';
    }, function(e, t2) {
      e.exports = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32"><path d="M0.622 18.334h19.54v7.55l11.052-9.412-11.052-9.413v7.549h-19.54v3.725z"></path></svg>';
    }, function(e, t2) {
      e.exports = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 32 32"><path d="M22.667 4l7 6-7 6 7 6-7 6v-4h-3.653l-3.76-3.76 2.827-2.827 2.587 2.587h2v-8h-2l-12 12h-6v-4h4.347l12-12h3.653v-4zM2.667 8h6l3.76 3.76-2.827 2.827-2.587-2.587h-4.347v-4z"></path></svg>';
    }, function(e, t2) {
      e.exports = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 28 32"><path d="M13.728 6.272v19.456q0 0.448-0.352 0.8t-0.8 0.32-0.8-0.32l-5.952-5.952h-4.672q-0.48 0-0.8-0.352t-0.352-0.8v-6.848q0-0.48 0.352-0.8t0.8-0.352h4.672l5.952-5.952q0.32-0.32 0.8-0.32t0.8 0.32 0.352 0.8z"></path></svg>';
    }, function(e, t2) {
      e.exports = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 28 32"><path d="M13.728 6.272v19.456q0 0.448-0.352 0.8t-0.8 0.32-0.8-0.32l-5.952-5.952h-4.672q-0.48 0-0.8-0.352t-0.352-0.8v-6.848q0-0.48 0.352-0.8t0.8-0.352h4.672l5.952-5.952q0.32-0.32 0.8-0.32t0.8 0.32 0.352 0.8zM20.576 16q0 1.344-0.768 2.528t-2.016 1.664q-0.16 0.096-0.448 0.096-0.448 0-0.8-0.32t-0.32-0.832q0-0.384 0.192-0.64t0.544-0.448 0.608-0.384 0.512-0.64 0.192-1.024-0.192-1.024-0.512-0.64-0.608-0.384-0.544-0.448-0.192-0.64q0-0.48 0.32-0.832t0.8-0.32q0.288 0 0.448 0.096 1.248 0.48 2.016 1.664t0.768 2.528z"></path></svg>';
    }, function(e, t2) {
      e.exports = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 28 32"><path d="M13.728 6.272v19.456q0 0.448-0.352 0.8t-0.8 0.32-0.8-0.32l-5.952-5.952h-4.672q-0.48 0-0.8-0.352t-0.352-0.8v-6.848q0-0.48 0.352-0.8t0.8-0.352h4.672l5.952-5.952q0.32-0.32 0.8-0.32t0.8 0.32 0.352 0.8zM20.576 16q0 1.344-0.768 2.528t-2.016 1.664q-0.16 0.096-0.448 0.096-0.448 0-0.8-0.32t-0.32-0.832q0-0.384 0.192-0.64t0.544-0.448 0.608-0.384 0.512-0.64 0.192-1.024-0.192-1.024-0.512-0.64-0.608-0.384-0.544-0.448-0.192-0.64q0-0.48 0.32-0.832t0.8-0.32q0.288 0 0.448 0.096 1.248 0.48 2.016 1.664t0.768 2.528zM25.152 16q0 2.72-1.536 5.056t-4 3.36q-0.256 0.096-0.448 0.096-0.48 0-0.832-0.352t-0.32-0.8q0-0.704 0.672-1.056 1.024-0.512 1.376-0.8 1.312-0.96 2.048-2.4t0.736-3.104-0.736-3.104-2.048-2.4q-0.352-0.288-1.376-0.8-0.672-0.352-0.672-1.056 0-0.448 0.32-0.8t0.8-0.352q0.224 0 0.48 0.096 2.496 1.056 4 3.36t1.536 5.056zM29.728 16q0 4.096-2.272 7.552t-6.048 5.056q-0.224 0.096-0.448 0.096-0.48 0-0.832-0.352t-0.32-0.8q0-0.64 0.704-1.056 0.128-0.064 0.384-0.192t0.416-0.192q0.8-0.448 1.44-0.896 2.208-1.632 3.456-4.064t1.216-5.152-1.216-5.152-3.456-4.064q-0.64-0.448-1.44-0.896-0.128-0.096-0.416-0.192t-0.384-0.192q-0.704-0.416-0.704-1.056 0-0.448 0.32-0.8t0.832-0.352q0.224 0 0.448 0.096 3.776 1.632 6.048 5.056t2.272 7.552z"></path></svg>';
    }, function(e, t2) {
      e.exports = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 17 32"><path d="M14.080 4.8q2.88 0 2.88 2.048v18.24q0 2.112-2.88 2.112t-2.88-2.112v-18.24q0-2.048 2.88-2.048zM2.88 4.8q2.88 0 2.88 2.048v18.24q0 2.112-2.88 2.112t-2.88-2.112v-18.24q0-2.048 2.88-2.048z"></path></svg>';
    }, function(e, t2) {
      e.exports = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 16 31"><path d="M15.552 15.168q0.448 0.32 0.448 0.832 0 0.448-0.448 0.768l-13.696 8.512q-0.768 0.512-1.312 0.192t-0.544-1.28v-16.448q0-0.96 0.544-1.28t1.312 0.192z"></path></svg>';
    }, function(e, t2, n) {
      var i, a, r = e.exports = {};
      function o() {
        throw new Error("setTimeout has not been defined");
      }
      function s() {
        throw new Error("clearTimeout has not been defined");
      }
      function l(e2) {
        if (i === setTimeout)
          return setTimeout(e2, 0);
        if ((i === o || !i) && setTimeout)
          return i = setTimeout, setTimeout(e2, 0);
        try {
          return i(e2, 0);
        } catch (t3) {
          try {
            return i.call(null, e2, 0);
          } catch (t4) {
            return i.call(this, e2, 0);
          }
        }
      }
      !function() {
        try {
          i = "function" == typeof setTimeout ? setTimeout : o;
        } catch (e2) {
          i = o;
        }
        try {
          a = "function" == typeof clearTimeout ? clearTimeout : s;
        } catch (e2) {
          a = s;
        }
      }();
      var u, c = [], p2 = false, d = -1;
      function h2() {
        p2 && u && (p2 = false, u.length ? c = u.concat(c) : d = -1, c.length && y());
      }
      function y() {
        if (!p2) {
          var e2 = l(h2);
          p2 = true;
          for (var t3 = c.length; t3; ) {
            for (u = c, c = []; ++d < t3; )
              u && u[d].run();
            d = -1, t3 = c.length;
          }
          u = null, p2 = false, function(e3) {
            if (a === clearTimeout)
              return clearTimeout(e3);
            if ((a === s || !a) && clearTimeout)
              return a = clearTimeout, clearTimeout(e3);
            try {
              a(e3);
            } catch (t4) {
              try {
                return a.call(null, e3);
              } catch (t5) {
                return a.call(this, e3);
              }
            }
          }(e2);
        }
      }
      function f(e2, t3) {
        this.fun = e2, this.array = t3;
      }
      function v() {
      }
      r.nextTick = function(e2) {
        var t3 = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var n2 = 1; n2 < arguments.length; n2++)
            t3[n2 - 1] = arguments[n2];
        c.push(new f(e2, t3)), 1 !== c.length || p2 || l(y);
      }, f.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, r.title = "browser", r.browser = true, r.env = {}, r.argv = [], r.version = "", r.versions = {}, r.on = v, r.addListener = v, r.once = v, r.off = v, r.removeListener = v, r.removeAllListeners = v, r.emit = v, r.prependListener = v, r.prependOnceListener = v, r.listeners = function(e2) {
        return [];
      }, r.binding = function(e2) {
        throw new Error("process.binding is not supported");
      }, r.cwd = function() {
        return "/";
      }, r.chdir = function(e2) {
        throw new Error("process.chdir is not supported");
      }, r.umask = function() {
        return 0;
      };
    }, function(e, t2, n) {
      (function(e2, t3) {
        !function(e3, n2) {
          if (!e3.setImmediate) {
            var i, a, r, o, s, l = 1, u = {}, c = false, p2 = e3.document, d = Object.getPrototypeOf && Object.getPrototypeOf(e3);
            d = d && d.setTimeout ? d : e3, "[object process]" === {}.toString.call(e3.process) ? i = function(e4) {
              t3.nextTick(function() {
                y(e4);
              });
            } : !function() {
              if (e3.postMessage && !e3.importScripts) {
                var t4 = true, n3 = e3.onmessage;
                return e3.onmessage = function() {
                  t4 = false;
                }, e3.postMessage("", "*"), e3.onmessage = n3, t4;
              }
            }() ? e3.MessageChannel ? ((r = new MessageChannel()).port1.onmessage = function(e4) {
              y(e4.data);
            }, i = function(e4) {
              r.port2.postMessage(e4);
            }) : p2 && "onreadystatechange" in p2.createElement("script") ? (a = p2.documentElement, i = function(e4) {
              var t4 = p2.createElement("script");
              t4.onreadystatechange = function() {
                y(e4), t4.onreadystatechange = null, a.removeChild(t4), t4 = null;
              }, a.appendChild(t4);
            }) : i = function(e4) {
              setTimeout(y, 0, e4);
            } : (o = "setImmediate$" + Math.random() + "$", s = function(t4) {
              t4.source === e3 && "string" == typeof t4.data && 0 === t4.data.indexOf(o) && y(+t4.data.slice(o.length));
            }, e3.addEventListener ? e3.addEventListener("message", s, false) : e3.attachEvent("onmessage", s), i = function(t4) {
              e3.postMessage(o + t4, "*");
            }), d.setImmediate = function(e4) {
              "function" != typeof e4 && (e4 = new Function("" + e4));
              for (var t4 = new Array(arguments.length - 1), n3 = 0; n3 < t4.length; n3++)
                t4[n3] = arguments[n3 + 1];
              var a2 = { callback: e4, args: t4 };
              return u[l] = a2, i(l), l++;
            }, d.clearImmediate = h2;
          }
          function h2(e4) {
            delete u[e4];
          }
          function y(e4) {
            if (c)
              setTimeout(y, 0, e4);
            else {
              var t4 = u[e4];
              if (t4) {
                c = true;
                try {
                  !function(e5) {
                    var t5 = e5.callback, i2 = e5.args;
                    switch (i2.length) {
                      case 0:
                        t5();
                        break;
                      case 1:
                        t5(i2[0]);
                        break;
                      case 2:
                        t5(i2[0], i2[1]);
                        break;
                      case 3:
                        t5(i2[0], i2[1], i2[2]);
                        break;
                      default:
                        t5.apply(n2, i2);
                    }
                  }(t4);
                } finally {
                  h2(e4), c = false;
                }
              }
            }
          }
        }("undefined" == typeof self ? void 0 === e2 ? void 0 : e2 : self);
      }).call(this, n(4), n(34));
    }, function(e, t2, n) {
      var i = Function.prototype.apply;
      function a(e2, t3) {
        this._id = e2, this._clearFn = t3;
      }
      t2.setTimeout = function() {
        return new a(i.call(setTimeout, window, arguments), clearTimeout);
      }, t2.setInterval = function() {
        return new a(i.call(setInterval, window, arguments), clearInterval);
      }, t2.clearTimeout = t2.clearInterval = function(e2) {
        e2 && e2.close();
      }, a.prototype.unref = a.prototype.ref = function() {
      }, a.prototype.close = function() {
        this._clearFn.call(window, this._id);
      }, t2.enroll = function(e2, t3) {
        clearTimeout(e2._idleTimeoutId), e2._idleTimeout = t3;
      }, t2.unenroll = function(e2) {
        clearTimeout(e2._idleTimeoutId), e2._idleTimeout = -1;
      }, t2._unrefActive = t2.active = function(e2) {
        clearTimeout(e2._idleTimeoutId);
        var t3 = e2._idleTimeout;
        t3 >= 0 && (e2._idleTimeoutId = setTimeout(function() {
          e2._onTimeout && e2._onTimeout();
        }, t3));
      }, n(35), t2.setImmediate = setImmediate, t2.clearImmediate = clearImmediate;
    }, function(e, t2, n) {
      (function(t3) {
        var n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e2) {
          return typeof e2;
        } : function(e2) {
          return e2 && "function" == typeof Symbol && e2.constructor === Symbol && e2 !== Symbol.prototype ? "symbol" : typeof e2;
        }, i = setTimeout;
        function a() {
        }
        function r(e2) {
          if (!(this instanceof r))
            throw new TypeError("Promises must be constructed via new");
          if ("function" != typeof e2)
            throw new TypeError("not a function");
          this._state = 0, this._handled = false, this._value = void 0, this._deferreds = [], c(e2, this);
        }
        function o(e2, t4) {
          for (; 3 === e2._state; )
            e2 = e2._value;
          0 !== e2._state ? (e2._handled = true, r._immediateFn(function() {
            var n3 = 1 === e2._state ? t4.onFulfilled : t4.onRejected;
            if (null !== n3) {
              var i2;
              try {
                i2 = n3(e2._value);
              } catch (e3) {
                return void l(t4.promise, e3);
              }
              s(t4.promise, i2);
            } else
              (1 === e2._state ? s : l)(t4.promise, e2._value);
          })) : e2._deferreds.push(t4);
        }
        function s(e2, t4) {
          try {
            if (t4 === e2)
              throw new TypeError("A promise cannot be resolved with itself.");
            if (t4 && ("object" === (void 0 === t4 ? "undefined" : n2(t4)) || "function" == typeof t4)) {
              var i2 = t4.then;
              if (t4 instanceof r)
                return e2._state = 3, e2._value = t4, void u(e2);
              if ("function" == typeof i2)
                return void c((a2 = i2, o2 = t4, function() {
                  a2.apply(o2, arguments);
                }), e2);
            }
            e2._state = 1, e2._value = t4, u(e2);
          } catch (t5) {
            l(e2, t5);
          }
          var a2, o2;
        }
        function l(e2, t4) {
          e2._state = 2, e2._value = t4, u(e2);
        }
        function u(e2) {
          2 === e2._state && 0 === e2._deferreds.length && r._immediateFn(function() {
            e2._handled || r._unhandledRejectionFn(e2._value);
          });
          for (var t4 = 0, n3 = e2._deferreds.length; t4 < n3; t4++)
            o(e2, e2._deferreds[t4]);
          e2._deferreds = null;
        }
        function c(e2, t4) {
          var n3 = false;
          try {
            e2(function(e3) {
              n3 || (n3 = true, s(t4, e3));
            }, function(e3) {
              n3 || (n3 = true, l(t4, e3));
            });
          } catch (e3) {
            if (n3)
              return;
            n3 = true, l(t4, e3);
          }
        }
        r.prototype.catch = function(e2) {
          return this.then(null, e2);
        }, r.prototype.then = function(e2, t4) {
          var n3 = new this.constructor(a);
          return o(this, new function(e3, t5, n4) {
            this.onFulfilled = "function" == typeof e3 ? e3 : null, this.onRejected = "function" == typeof t5 ? t5 : null, this.promise = n4;
          }(e2, t4, n3)), n3;
        }, r.prototype.finally = function(e2) {
          var t4 = this.constructor;
          return this.then(function(n3) {
            return t4.resolve(e2()).then(function() {
              return n3;
            });
          }, function(n3) {
            return t4.resolve(e2()).then(function() {
              return t4.reject(n3);
            });
          });
        }, r.all = function(e2) {
          return new r(function(t4, i2) {
            if (!e2 || void 0 === e2.length)
              throw new TypeError("Promise.all accepts an array");
            var a2 = Array.prototype.slice.call(e2);
            if (0 === a2.length)
              return t4([]);
            var r2 = a2.length;
            function o2(e3, s3) {
              try {
                if (s3 && ("object" === (void 0 === s3 ? "undefined" : n2(s3)) || "function" == typeof s3)) {
                  var l2 = s3.then;
                  if ("function" == typeof l2)
                    return void l2.call(s3, function(t5) {
                      o2(e3, t5);
                    }, i2);
                }
                a2[e3] = s3, 0 == --r2 && t4(a2);
              } catch (e4) {
                i2(e4);
              }
            }
            for (var s2 = 0; s2 < a2.length; s2++)
              o2(s2, a2[s2]);
          });
        }, r.resolve = function(e2) {
          return e2 && "object" === (void 0 === e2 ? "undefined" : n2(e2)) && e2.constructor === r ? e2 : new r(function(t4) {
            t4(e2);
          });
        }, r.reject = function(e2) {
          return new r(function(t4, n3) {
            n3(e2);
          });
        }, r.race = function(e2) {
          return new r(function(t4, n3) {
            for (var i2 = 0, a2 = e2.length; i2 < a2; i2++)
              e2[i2].then(t4, n3);
          });
        }, r._immediateFn = "function" == typeof t3 && function(e2) {
          t3(e2);
        } || function(e2) {
          i(e2, 0);
        }, r._unhandledRejectionFn = function(e2) {
          "undefined" != typeof console && console && void 0;
        }, e.exports = r;
      }).call(this, n(36).setImmediate);
    }, function(e, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var i = /* @__PURE__ */ function() {
        function e2(e3, t3) {
          for (var n2 = 0; n2 < t3.length; n2++) {
            var i2 = t3[n2];
            i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e3, i2.key, i2);
          }
        }
        return function(t3, n2, i2) {
          return n2 && e2(t3.prototype, n2), i2 && e2(t3, i2), t3;
        };
      }(), a = v(n(37)), r = v(n(0)), o = v(n(3)), s = v(n(18)), l = v(n(17)), u = v(n(13)), c = v(n(12)), p2 = v(n(11)), d = v(n(9)), h2 = v(n(8)), y = v(n(7)), f = v(n(6));
      function v(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }
      var m = [], g = function() {
        function e2(t3) {
          if (function(e3, t4) {
            if (!(e3 instanceof t4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e2), this.options = (0, s.default)(t3), this.container = this.options.container, this.paused = true, this.playedPromise = a.default.resolve(), this.mode = "normal", this.randomOrder = r.default.randomOrder(this.options.audio.length), this.container.classList.add("aplayer"), this.options.lrcType && !this.options.fixed && this.container.classList.add("aplayer-withlrc"), this.options.audio.length > 1 && this.container.classList.add("aplayer-withlist"), r.default.isMobile && this.container.classList.add("aplayer-mobile"), this.arrow = this.container.offsetWidth <= 300, this.arrow && this.container.classList.add("aplayer-arrow"), this.container = this.options.container, 2 === this.options.lrcType || true === this.options.lrcType)
            for (var n2 = this.container.getElementsByClassName("aplayer-lrc-content"), i2 = 0; i2 < n2.length; i2++)
              this.options.audio[i2] && (this.options.audio[i2].lrc = n2[i2].innerHTML);
          this.template = new l.default({ container: this.container, options: this.options, randomOrder: this.randomOrder }), this.options.fixed && (this.container.classList.add("aplayer-fixed"), this.template.body.style.width = this.template.body.offsetWidth - 18 + "px"), this.options.mini && (this.setMode("mini"), this.template.info.style.display = "block"), this.template.info.offsetWidth < 200 && this.template.time.classList.add("aplayer-time-narrow"), this.options.lrcType && (this.lrc = new p2.default({ container: this.template.lrc, async: 3 === this.options.lrcType, player: this })), this.events = new y.default(), this.storage = new c.default(this), this.bar = new u.default(this.template), this.controller = new d.default(this), this.timer = new h2.default(this), this.list = new f.default(this), this.initAudio(), this.bindEvents(), "random" === this.options.order ? this.list.switch(this.randomOrder[0]) : this.list.switch(0), this.options.autoplay && this.play(), m.push(this);
        }
        return i(e2, [{ key: "initAudio", value: function() {
          var e3 = this;
          this.audio = document.createElement("audio"), this.audio.preload = this.options.preload;
          for (var t3 = function(t4) {
            e3.audio.addEventListener(e3.events.audioEvents[t4], function(n3) {
              e3.events.trigger(e3.events.audioEvents[t4], n3);
            });
          }, n2 = 0; n2 < this.events.audioEvents.length; n2++)
            t3(n2);
          this.volume(this.storage.get("volume"), true);
        } }, { key: "bindEvents", value: function() {
          var e3 = this;
          this.on("play", function() {
            e3.paused && e3.setUIPlaying();
          }), this.on("pause", function() {
            e3.paused || e3.setUIPaused();
          }), this.on("timeupdate", function() {
            if (!e3.disableTimeupdate) {
              e3.bar.set("played", e3.audio.currentTime / e3.duration, "width"), e3.lrc && e3.lrc.update();
              var t4 = r.default.secondToTime(e3.audio.currentTime);
              e3.template.ptime.innerHTML !== t4 && (e3.template.ptime.innerHTML = t4);
            }
          }), this.on("durationchange", function() {
            1 !== e3.duration && (e3.template.dtime.innerHTML = r.default.secondToTime(e3.duration));
          }), this.on("progress", function() {
            var t4 = e3.audio.buffered.length ? e3.audio.buffered.end(e3.audio.buffered.length - 1) / e3.duration : 0;
            e3.bar.set("loaded", t4, "width");
          });
          var t3 = void 0;
          this.on("error", function() {
            e3.list.audios.length > 1 ? (e3.notice("An audio error has occurred, player will skip forward in 2 seconds."), t3 = setTimeout(function() {
              e3.skipForward(), e3.paused || e3.play();
            }, 2e3)) : 1 === e3.list.audios.length && e3.notice("An audio error has occurred.");
          }), this.events.on("listswitch", function() {
            t3 && clearTimeout(t3);
          }), this.on("ended", function() {
            "none" === e3.options.loop ? "list" === e3.options.order ? e3.list.index < e3.list.audios.length - 1 ? (e3.list.switch((e3.list.index + 1) % e3.list.audios.length), e3.play()) : (e3.list.switch((e3.list.index + 1) % e3.list.audios.length), e3.pause()) : "random" === e3.options.order && (e3.randomOrder.indexOf(e3.list.index) < e3.randomOrder.length - 1 ? (e3.list.switch(e3.nextIndex()), e3.play()) : (e3.list.switch(e3.nextIndex()), e3.pause())) : "one" === e3.options.loop ? (e3.list.switch(e3.list.index), e3.play()) : "all" === e3.options.loop && (e3.skipForward(), e3.play());
          });
        } }, { key: "setAudio", value: function(e3) {
          this.hls && (this.hls.destroy(), this.hls = null);
          var t3 = e3.type;
          this.options.customAudioType && this.options.customAudioType[t3] ? "[object Function]" === Object.prototype.toString.call(this.options.customAudioType[t3]) ? this.options.customAudioType[t3](this.audio, e3, this) : void 0 : (t3 && "auto" !== t3 || (t3 = /m3u8(#|\?|$)/i.exec(e3.url) ? "hls" : "normal"), "hls" === t3 ? Hls.isSupported() ? (this.hls = new Hls(), this.hls.loadSource(e3.url), this.hls.attachMedia(this.audio)) : this.audio.canPlayType("application/x-mpegURL") || this.audio.canPlayType("application/vnd.apple.mpegURL") ? this.audio.src = e3.url : this.notice("Error: HLS is not supported.") : "normal" === t3 && (this.audio.src = e3.url)), this.seek(0), this.paused || this.audio.play();
        } }, { key: "theme", value: function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.list.audios[this.list.index].theme || this.options.theme, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.list.index;
          (!(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]) && this.list.audios[t3] && (this.list.audios[t3].theme = e3), this.template.listCurs[t3] && (this.template.listCurs[t3].style.backgroundColor = e3), t3 === this.list.index && (this.template.pic.style.backgroundColor = e3, this.template.played.style.background = e3, this.template.thumb.style.background = e3, this.template.volume.style.background = e3);
        } }, { key: "seek", value: function(e3) {
          e3 = Math.max(e3, 0), e3 = Math.min(e3, this.duration), this.audio.currentTime = e3, this.bar.set("played", e3 / this.duration, "width"), this.template.ptime.innerHTML = r.default.secondToTime(e3);
        } }, { key: "setUIPlaying", value: function() {
          var e3 = this;
          if (this.paused && (this.paused = false, this.template.button.classList.remove("aplayer-play"), this.template.button.classList.add("aplayer-pause"), this.template.button.innerHTML = "", setTimeout(function() {
            e3.template.button.innerHTML = o.default.pause;
          }, 100), this.template.skipPlayButton.innerHTML = o.default.pause), this.timer.enable("loading"), this.options.mutex)
            for (var t3 = 0; t3 < m.length; t3++)
              this !== m[t3] && m[t3].pause();
        } }, { key: "play", value: function() {
          var e3 = this;
          this.setUIPlaying();
          var t3 = this.audio.play();
          t3 && t3.catch(function(t4) {
            void 0, "NotAllowedError" === t4.name && e3.setUIPaused();
          });
        } }, { key: "setUIPaused", value: function() {
          var e3 = this;
          this.paused || (this.paused = true, this.template.button.classList.remove("aplayer-pause"), this.template.button.classList.add("aplayer-play"), this.template.button.innerHTML = "", setTimeout(function() {
            e3.template.button.innerHTML = o.default.play;
          }, 100), this.template.skipPlayButton.innerHTML = o.default.play), this.container.classList.remove("aplayer-loading"), this.timer.disable("loading");
        } }, { key: "pause", value: function() {
          this.setUIPaused(), this.audio.pause();
        } }, { key: "switchVolumeIcon", value: function() {
          this.volume() >= 0.95 ? this.template.volumeButton.innerHTML = o.default.volumeUp : this.volume() > 0 ? this.template.volumeButton.innerHTML = o.default.volumeDown : this.template.volumeButton.innerHTML = o.default.volumeOff;
        } }, { key: "volume", value: function(e3, t3) {
          return e3 = parseFloat(e3), isNaN(e3) || (e3 = Math.max(e3, 0), e3 = Math.min(e3, 1), this.bar.set("volume", e3, "height"), t3 || this.storage.set("volume", e3), this.audio.volume = e3, this.audio.muted && (this.audio.muted = false), this.switchVolumeIcon()), this.audio.muted ? 0 : this.audio.volume;
        } }, { key: "on", value: function(e3, t3) {
          this.events.on(e3, t3);
        } }, { key: "toggle", value: function() {
          this.template.button.classList.contains("aplayer-play") ? this.play() : this.template.button.classList.contains("aplayer-pause") && this.pause();
        } }, { key: "switchAudio", value: function(e3) {
          this.list.switch(e3);
        } }, { key: "addAudio", value: function(e3) {
          this.list.add(e3);
        } }, { key: "removeAudio", value: function(e3) {
          this.list.remove(e3);
        } }, { key: "destroy", value: function() {
          m.splice(m.indexOf(this), 1), this.pause(), this.container.innerHTML = "", this.audio.src = "", this.timer.destroy(), this.events.trigger("destroy");
        } }, { key: "setMode", value: function() {
          var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "normal";
          this.mode = e3, "mini" === e3 ? this.container.classList.add("aplayer-narrow") : "normal" === e3 && this.container.classList.remove("aplayer-narrow");
        } }, { key: "notice", value: function(e3) {
          var t3 = this, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2e3, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0.8;
          this.template.notice.innerHTML = e3, this.template.notice.style.opacity = i2, this.noticeTime && clearTimeout(this.noticeTime), this.events.trigger("noticeshow", { text: e3 }), n2 && (this.noticeTime = setTimeout(function() {
            t3.template.notice.style.opacity = 0, t3.events.trigger("noticehide");
          }, n2));
        } }, { key: "prevIndex", value: function() {
          if (!(this.list.audios.length > 1))
            return 0;
          if ("list" === this.options.order)
            return this.list.index - 1 < 0 ? this.list.audios.length - 1 : this.list.index - 1;
          if ("random" === this.options.order) {
            var e3 = this.randomOrder.indexOf(this.list.index);
            return 0 === e3 ? this.randomOrder[this.randomOrder.length - 1] : this.randomOrder[e3 - 1];
          }
        } }, { key: "nextIndex", value: function() {
          if (!(this.list.audios.length > 1))
            return 0;
          if ("list" === this.options.order)
            return (this.list.index + 1) % this.list.audios.length;
          if ("random" === this.options.order) {
            var e3 = this.randomOrder.indexOf(this.list.index);
            return e3 === this.randomOrder.length - 1 ? this.randomOrder[0] : this.randomOrder[e3 + 1];
          }
        } }, { key: "skipBack", value: function() {
          this.list.switch(this.prevIndex());
        } }, { key: "skipForward", value: function() {
          this.list.switch(this.nextIndex());
        } }, { key: "duration", get: function() {
          return isNaN(this.audio.duration) ? 0 : this.audio.duration;
        } }], [{ key: "version", get: function() {
          return "1.10.1";
        } }]), e2;
      }();
      t2.default = g;
    }, , function(e, t2, n) {
    }, function(e, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true }), n(40);
      var i, a = n(38), r = (i = a) && i.__esModule ? i : { default: i };
      void 0, t2.default = r.default;
    }]).default;
  });
})(APlayer_min);
var APlayer_minExports = APlayer_min.exports;
const APlayer = /* @__PURE__ */ getDefaultExportFromCjs(APlayer_minExports);
function base32Encode(str) {
  var base32chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  var bits = "";
  var base32 = "";
  for (var i = 0; i < str.length; i++) {
    var bit = str.charCodeAt(i).toString(2);
    while (bit.length < 8) {
      bit = "0" + bit;
    }
    bits += bit;
  }
  while (bits.length % 5 !== 0) {
    bits += "0";
  }
  for (var i = 0; i < bits.length; i += 5) {
    var chunk = bits.substring(i, i + 5);
    base32 += base32chars[parseInt(chunk, 2)];
  }
  while (base32.length % 8 !== 0) {
    base32 += "=";
  }
  return base32.replace(/=/g, "HiFiNiYINYUECICHANG");
}
function generateParam(data) {
  var key = "95wwwHiFiNicom27";
  var outText = "";
  for (var i = 0, j = 0; i < data.length; i++, j++) {
    if (j == key.length)
      j = 0;
    outText += String.fromCharCode(data.charCodeAt(i) ^ key.charCodeAt(j));
  }
  return base32Encode(outText);
}
const _hoisted_1 = { class: "flex flex-col" };
const _hoisted_2 = { key: 0 };
const _hoisted_3 = { class: "flex justify-between items-center mb-16px" };
const _hoisted_4 = { class: "text-#333 text-24px" };
const _hoisted_5 = { class: "text-#666 text-16px" };
const channelName = "hifini-helper-channel";
const _sfc_main = {
  __name: "App",
  setup(__props) {
    const store = usePlaylistStore();
    const showManageDialog = ref(false);
    const showAboutDialog = ref(false);
    const playerRef = ref();
    const contentRef = ref();
    const aplayer = ref(null);
    provide("aplayerInstance", aplayer);
    const channel = new BroadcastChannel(channelName);
    localStorage.setItem("channel", channelName);
    const messageHandler = (e) => {
      if (e && e.data && e.data !== "undefined") {
        if (e.data.msg === "heartbeat") {
          channel.postMessage({ msgId: e.data.msgId, from: "player", code: 200, msg: "heartbeat" });
          return;
        }
        const id = e.data.id;
        if (store.playlist.some((x) => x.id == id)) {
          channel.postMessage({ msgId: e.data.msgId, from: "player", code: 1001, msg: "歌曲已存在，请勿重复添加！" });
          return;
        }
        const url = e.data.url.startsWith("http") || e.data.url.startsWith("blob") ? e.data.url : `${location.origin}/${e.data.url}`;
        const song = {
          id: e.data.id,
          name: e.data.title,
          artist: e.data.author,
          url,
          cover: e.data.pic,
          page: e.data.page,
          theme: "#4ddd4c",
          type: "custom",
          updateTime: Date.now()
        };
        if (e.data.storeKey) {
          song.storeKey = e.data.storeKey;
        }
        addSong(song);
        channel.postMessage({ msgId: e.data.msgId, from: "player", code: 200 });
        showToast("歌曲添加成功！");
      }
    };
    channel.addEventListener("message", (e) => {
      messageHandler(e);
      window.focus();
    });
    window.addEventListener(
      "message",
      (e) => {
        messageHandler(e);
      },
      false
    );
    window.addEventListener("beforeunload", function(event) {
      localStorage.removeItem("channel", channelName);
    });
    const addSong = (song) => {
      store.add(song);
      nextTick(() => {
        if (aplayer.value) {
          aplayer.value.list.add(song);
        }
      });
    };
    const updateSong = (index, url) => {
      const updateTime = Date.now();
      store.playlist[index].url = url;
      store.playlist[index].updateTime = updateTime;
      if (aplayer.value) {
        aplayer.value.list.audios[index].url = url;
        aplayer.value.list.audios[index].updateTime = updateTime;
      }
    };
    const resetSongUpdateTime = (index) => {
      store.playlist[index].updateTime = -1;
      if (aplayer.value) {
        aplayer.value.list.audios[index].updateTime = -1;
      }
    };
    const retry = async (index, signal) => {
      let src2 = null;
      const getParseValue = (str, key) => {
        const regExp = new RegExp(`${key}:\\s*\\'(.*)\\'`, "igm");
        const result = regExp.exec(str);
        if (result) {
          return result[1];
        }
        return null;
      };
      try {
        const song = store.playlist[index];
        const res = await fetch(song.page, { signal });
        if (res.ok && res.status === 200) {
          const textContent = await res.text();
          let parser = new DOMParser();
          const doc2 = parser.parseFromString(textContent, "text/html");
          if (doc2) {
            const playerContent = Array.from(doc2.querySelectorAll("script")).filter((x) => x.innerText).map((x) => x.innerText).find((x) => x.indexOf("APlayer") !== -1);
            if (playerContent) {
              const url = getParseValue(playerContent, "url");
              if (url == null ? void 0 : url.startsWith("http")) {
                src2 = url;
              } else {
                src2 = false ? `https://www.hifini.com/${url}` : `${location.origin}/${url}`;
              }
              if (src2.indexOf("generateParam") !== -1) {
                const quoteIndex = src2.indexOf("'");
                const part1 = src2.substr(0, quoteIndex);
                const bracesIndex = src2.indexOf("(");
                const part2 = src2.substring(bracesIndex + 2);
                src2 = part1 + generateParam(part2);
              }
              updateSong(index, src2);
            }
          }
        }
      } catch (error) {
      }
      return src2;
    };
    const isExpired = (lastUpdateTime) => {
      const diff = Date.now() - lastUpdateTime;
      return diff > 8 * 60 * 60 * 1e3;
    };
    const abortController = ref(null);
    const setAudio = async (audioElement, audio, player) => {
      const index = player.list.index;
      try {
        if (abortController.value) {
          abortController.value.abort();
        }
        abortController.value = new AbortController();
        const res = await fetch(audio.url, { signal: abortController.value.signal });
        if (res.redirected && res.url && res.url.indexOf("https://www.hifini.com/") !== -1) {
          const songUrlNew = await retry(index, abortController.value.signal);
          if (songUrlNew) {
            audioElement.src = songUrlNew;
            player.play();
            return;
          }
        }
        const resText = await res.text();
        if (resText && resText.trim() === "-1") {
          const songUrlNew = await retry(index, abortController.value.signal);
          if (songUrlNew) {
            audioElement.src = songUrlNew;
            player.play();
            return;
          }
        }
        audioElement.src = res.url;
        player.play();
      } catch (err) {
        resetSongUpdateTime(index);
        if (err.name === "AbortError") {
          return;
        }
        if ((err == null ? void 0 : err.message) === "Failed to fetch") {
          const songUrlNew = await retry(index, abortController.value.signal);
          if (songUrlNew) {
            audioElement.src = songUrlNew;
            player.play();
            return;
          }
        }
      }
    };
    const setAudioByStoreData = async (audioElement, audio, player) => {
      const index = player.list.index;
      const blobData = await get(audio.storeKey);
      if (blobData) {
        audio.url && URL.revokeObjectURL(audio.url);
        const newUrl = URL.createObjectURL(blobData);
        updateSong(index, newUrl);
        audioElement.src = newUrl;
        player.play();
      }
    };
    onMounted(() => {
      var _a;
      aplayer.value = new APlayer({
        container: playerRef.value,
        audio: ((_a = store.playlist) == null ? void 0 : _a.length) ? JSON.parse(JSON.stringify(store.playlist)) : [],
        customAudioType: {
          custom: function(audioElement, audio, player) {
            document.title = `听歌小助手 - ${audio.name}（${audio.artist}）`;
            player.seek(0);
            if (audio.storeKey && audio.url.startsWith("blob")) {
              setAudioByStoreData(audioElement, audio, player);
              return;
            }
            if (audio.updateTime && audio.updateTime !== -1 && !isExpired(audio.updateTime)) {
              audioElement.src = audio.url;
              return;
            }
            setAudio(audioElement, audio, player);
          }
        }
      });
      aplayer.value.events.events["error"] = [];
      nextTick(() => {
        if (contentRef.value) {
          const listHeight = contentRef.value.offsetHeight - (80 + 66);
          const aplayerList = document.querySelector(".aplayer-list");
          if (aplayerList) {
            aplayerList.style.maxHeight = `${listHeight}px`;
            const ol = aplayerList.querySelector("ol");
            if (ol) {
              ol.style.maxHeight = `${listHeight}px`;
            }
          }
        }
      });
    });
    return (_ctx, _cache) => {
      const _component_van_button = Button;
      return openBlock(), createElementBlock("main", _hoisted_1, [
        createVNode(AppHeader, {
          onShowAbout: _cache[0] || (_cache[0] = ($event) => showAboutDialog.value = true)
        }),
        unref(store).playlist.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_2, [
          createVNode(_sfc_main$6)
        ])) : createCommentVNode("", true),
        withDirectives(createBaseVNode("div", {
          ref_key: "contentRef",
          ref: contentRef,
          class: "px-15px py-10px box-border flex-1"
        }, [
          createBaseVNode("div", _hoisted_3, [
            createBaseVNode("div", _hoisted_4, [
              createTextVNode("你的歌单"),
              createBaseVNode("span", _hoisted_5, toDisplayString(`（共${unref(store).playlist.length}首歌曲）`), 1)
            ]),
            createVNode(_component_van_button, {
              class: "w-100px h-40px",
              round: "",
              color: "#4ddd4c",
              onClick: _cache[1] || (_cache[1] = ($event) => showManageDialog.value = true)
            }, {
              default: withCtx(() => [
                createTextVNode("管理")
              ]),
              _: 1
            })
          ]),
          createBaseVNode("div", {
            ref_key: "playerRef",
            ref: playerRef,
            class: "m-0"
          }, null, 512)
        ], 512), [
          [vShow, unref(store).playlist.length > 0]
        ]),
        createVNode(MusicPlayer),
        createVNode(_sfc_main$2, {
          show: showManageDialog.value,
          "onUpdate:show": _cache[2] || (_cache[2] = ($event) => showManageDialog.value = $event)
        }, null, 8, ["show"]),
        createVNode(AboutDialog, {
          show: showAboutDialog.value,
          "onUpdate:show": _cache[3] || (_cache[3] = ($event) => showAboutDialog.value = $event)
        }, null, 8, ["show"])
      ]);
    };
  }
};
const pinia = createPinia();
pinia.use(src_default);
createApp(_sfc_main).use(pinia).mount("#app");

</script>
    <style>
:root,:host{--van-black: #000;--van-white: #fff;--van-gray-1: #f7f8fa;--van-gray-2: #f2f3f5;--van-gray-3: #ebedf0;--van-gray-4: #dcdee0;--van-gray-5: #c8c9cc;--van-gray-6: #969799;--van-gray-7: #646566;--van-gray-8: #323233;--van-red: #ee0a24;--van-blue: #1989fa;--van-orange: #ff976a;--van-orange-dark: #ed6a0c;--van-orange-light: #fffbe8;--van-green: #07c160;--van-gradient-red: linear-gradient(to right, #ff6034, #ee0a24);--van-gradient-orange: linear-gradient(to right, #ffd01e, #ff8917);--van-primary-color: var(--van-blue);--van-success-color: var(--van-green);--van-danger-color: var(--van-red);--van-warning-color: var(--van-orange);--van-text-color: var(--van-gray-8);--van-text-color-2: var(--van-gray-6);--van-text-color-3: var(--van-gray-5);--van-active-color: var(--van-gray-2);--van-active-opacity: .6;--van-disabled-opacity: .5;--van-background: var(--van-gray-1);--van-background-2: var(--van-white);--van-background-3: var(--van-white);--van-padding-base: 4px;--van-padding-xs: 8px;--van-padding-sm: 12px;--van-padding-md: 16px;--van-padding-lg: 24px;--van-padding-xl: 32px;--van-font-bold: 600;--van-font-size-xs: 10px;--van-font-size-sm: 12px;--van-font-size-md: 14px;--van-font-size-lg: 16px;--van-line-height-xs: 14px;--van-line-height-sm: 18px;--van-line-height-md: 20px;--van-line-height-lg: 22px;--van-base-font: -apple-system, BlinkMacSystemFont, "Helvetica Neue", Helvetica, Segoe UI, Arial, Roboto, "PingFang SC", "miui", "Hiragino Sans GB", "Microsoft Yahei", sans-serif;--van-price-font: avenir-heavy, "PingFang SC", helvetica neue, arial, sans-serif;--van-duration-base: .3s;--van-duration-fast: .2s;--van-ease-out: ease-out;--van-ease-in: ease-in;--van-border-color: var(--van-gray-3);--van-border-width: 1px;--van-radius-sm: 2px;--van-radius-md: 4px;--van-radius-lg: 8px;--van-radius-max: 999px}.van-theme-dark{--van-text-color: #f5f5f5;--van-text-color-2: #707070;--van-text-color-3: #4d4d4d;--van-border-color: #3a3a3c;--van-active-color: #3a3a3c;--van-background: #000;--van-background-2: #1c1c1e;--van-background-3: #37363b}html{-webkit-tap-highlight-color:transparent}body{margin:0;font-family:var(--van-base-font)}a{text-decoration:none}input,button,textarea{color:inherit;font:inherit}a:focus,input:focus,button:focus,textarea:focus,[class*=van-]:focus{outline:none}ol,ul{margin:0;padding:0;list-style:none}@keyframes van-slide-up-enter{0%{transform:translate3d(0,100%,0)}}@keyframes van-slide-up-leave{to{transform:translate3d(0,100%,0)}}@keyframes van-slide-down-enter{0%{transform:translate3d(0,-100%,0)}}@keyframes van-slide-down-leave{to{transform:translate3d(0,-100%,0)}}@keyframes van-slide-left-enter{0%{transform:translate3d(-100%,0,0)}}@keyframes van-slide-left-leave{to{transform:translate3d(-100%,0,0)}}@keyframes van-slide-right-enter{0%{transform:translate3d(100%,0,0)}}@keyframes van-slide-right-leave{to{transform:translate3d(100%,0,0)}}@keyframes van-fade-in{0%{opacity:0}to{opacity:1}}@keyframes van-fade-out{0%{opacity:1}to{opacity:0}}@keyframes van-rotate{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.van-fade-enter-active{animation:var(--van-duration-base) van-fade-in both var(--van-ease-out)}.van-fade-leave-active{animation:var(--van-duration-base) van-fade-out both var(--van-ease-in)}.van-slide-up-enter-active{animation:van-slide-up-enter var(--van-duration-base) both var(--van-ease-out)}.van-slide-up-leave-active{animation:van-slide-up-leave var(--van-duration-base) both var(--van-ease-in)}.van-slide-down-enter-active{animation:van-slide-down-enter var(--van-duration-base) both var(--van-ease-out)}.van-slide-down-leave-active{animation:van-slide-down-leave var(--van-duration-base) both var(--van-ease-in)}.van-slide-left-enter-active{animation:van-slide-left-enter var(--van-duration-base) both var(--van-ease-out)}.van-slide-left-leave-active{animation:van-slide-left-leave var(--van-duration-base) both var(--van-ease-in)}.van-slide-right-enter-active{animation:van-slide-right-enter var(--van-duration-base) both var(--van-ease-out)}.van-slide-right-leave-active{animation:van-slide-right-leave var(--van-duration-base) both var(--van-ease-in)}.van-clearfix:after{display:table;clear:both;content:""}.van-ellipsis{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.van-multi-ellipsis--l2{display:-webkit-box;overflow:hidden;text-overflow:ellipsis;-webkit-line-clamp:2;line-break:anywhere;-webkit-box-orient:vertical}.van-multi-ellipsis--l3{display:-webkit-box;overflow:hidden;text-overflow:ellipsis;-webkit-line-clamp:3;line-break:anywhere;-webkit-box-orient:vertical}.van-safe-area-top{padding-top:constant(safe-area-inset-top);padding-top:env(safe-area-inset-top)}.van-safe-area-bottom{padding-bottom:constant(safe-area-inset-bottom);padding-bottom:env(safe-area-inset-bottom)}.van-haptics-feedback{cursor:pointer}.van-haptics-feedback:active{opacity:var(--van-active-opacity)}[class*=van-hairline]:after{position:absolute;box-sizing:border-box;content:" ";pointer-events:none;top:-50%;right:-50%;bottom:-50%;left:-50%;border:0 solid var(--van-border-color);transform:scale(.5)}.van-hairline,.van-hairline--top,.van-hairline--left,.van-hairline--right,.van-hairline--bottom,.van-hairline--surround,.van-hairline--top-bottom{position:relative}.van-hairline--top:after{border-top-width:var(--van-border-width)}.van-hairline--left:after{border-left-width:var(--van-border-width)}.van-hairline--right:after{border-right-width:var(--van-border-width)}.van-hairline--bottom:after{border-bottom-width:var(--van-border-width)}.van-hairline--top-bottom:after,.van-hairline-unset--top-bottom:after{border-width:var(--van-border-width) 0}.van-hairline--surround:after{border-width:var(--van-border-width)}
:root,:host{--van-badge-size: 16px;--van-badge-color: var(--van-white);--van-badge-padding: 0 3px;--van-badge-font-size: var(--van-font-size-sm);--van-badge-font-weight: var(--van-font-bold);--van-badge-border-width: var(--van-border-width);--van-badge-background: var(--van-danger-color);--van-badge-dot-color: var(--van-danger-color);--van-badge-dot-size: 8px;--van-badge-font: -apple-system-font, helvetica neue, arial, sans-serif}.van-badge{display:inline-block;box-sizing:border-box;min-width:var(--van-badge-size);padding:var(--van-badge-padding);color:var(--van-badge-color);font-weight:var(--van-badge-font-weight);font-size:var(--van-badge-font-size);font-family:var(--van-badge-font);line-height:1.2;text-align:center;background:var(--van-badge-background);border:var(--van-badge-border-width) solid var(--van-background-2);border-radius:var(--van-radius-max)}.van-badge--fixed{position:absolute;transform-origin:100%}.van-badge--top-left{top:0;left:0;transform:translate(-50%,-50%)}.van-badge--top-right{top:0;right:0;transform:translate(50%,-50%)}.van-badge--bottom-left{bottom:0;left:0;transform:translate(-50%,50%)}.van-badge--bottom-right{bottom:0;right:0;transform:translate(50%,50%)}.van-badge--dot{width:var(--van-badge-dot-size);min-width:0;height:var(--van-badge-dot-size);background:var(--van-badge-dot-color);border-radius:100%;border:none;padding:0}.van-badge__wrapper{position:relative;display:inline-block}
.van-icon{position:relative;display:inline-block;font: 14px/1 vant-icon;font:normal normal normal 14px/1 var(--van-icon-font-family, "vant-icon");font-size:inherit;text-rendering:auto;-webkit-font-smoothing:antialiased}.van-icon:before{display:inline-block}.van-icon-arrow-double-left:before{content:"\e653"}.van-icon-arrow-double-right:before{content:"\e654"}.van-icon-contact:before{content:"\e753"}.van-icon-notes:before{content:"\e63c"}.van-icon-records:before{content:"\e63d"}.van-icon-cash-back-record:before{content:"\e63e"}.van-icon-newspaper:before{content:"\e63f"}.van-icon-discount:before{content:"\e640"}.van-icon-completed:before{content:"\e641"}.van-icon-user:before{content:"\e642"}.van-icon-description:before{content:"\e643"}.van-icon-list-switch:before{content:"\e6ad"}.van-icon-list-switching:before{content:"\e65a"}.van-icon-link-o:before{content:"\e751"}.van-icon-miniprogram-o:before{content:"\e752"}.van-icon-qq:before{content:"\e74e"}.van-icon-wechat-moments:before{content:"\e74f"}.van-icon-weibo:before{content:"\e750"}.van-icon-cash-o:before{content:"\e74d"}.van-icon-guide-o:before{content:"\e74c"}.van-icon-invitation:before{content:"\e6d6"}.van-icon-shield-o:before{content:"\e74b"}.van-icon-exchange:before{content:"\e6af"}.van-icon-eye:before{content:"\e6b0"}.van-icon-enlarge:before{content:"\e6b1"}.van-icon-expand-o:before{content:"\e6b2"}.van-icon-eye-o:before{content:"\e6b3"}.van-icon-expand:before{content:"\e6b4"}.van-icon-filter-o:before{content:"\e6b5"}.van-icon-fire:before{content:"\e6b6"}.van-icon-fail:before{content:"\e6b7"}.van-icon-failure:before{content:"\e6b8"}.van-icon-fire-o:before{content:"\e6b9"}.van-icon-flag-o:before{content:"\e6ba"}.van-icon-font:before{content:"\e6bb"}.van-icon-font-o:before{content:"\e6bc"}.van-icon-gem-o:before{content:"\e6bd"}.van-icon-flower-o:before{content:"\e6be"}.van-icon-gem:before{content:"\e6bf"}.van-icon-gift-card:before{content:"\e6c0"}.van-icon-friends:before{content:"\e6c1"}.van-icon-friends-o:before{content:"\e6c2"}.van-icon-gold-coin:before{content:"\e6c3"}.van-icon-gold-coin-o:before{content:"\e6c4"}.van-icon-good-job-o:before{content:"\e6c5"}.van-icon-gift:before{content:"\e6c6"}.van-icon-gift-o:before{content:"\e6c7"}.van-icon-gift-card-o:before{content:"\e6c8"}.van-icon-good-job:before{content:"\e6c9"}.van-icon-home-o:before{content:"\e6ca"}.van-icon-goods-collect:before{content:"\e6cb"}.van-icon-graphic:before{content:"\e6cc"}.van-icon-goods-collect-o:before{content:"\e6cd"}.van-icon-hot-o:before{content:"\e6ce"}.van-icon-info:before{content:"\e6cf"}.van-icon-hotel-o:before{content:"\e6d0"}.van-icon-info-o:before{content:"\e6d1"}.van-icon-hot-sale-o:before{content:"\e6d2"}.van-icon-hot:before{content:"\e6d3"}.van-icon-like:before{content:"\e6d4"}.van-icon-idcard:before{content:"\e6d5"}.van-icon-like-o:before{content:"\e6d7"}.van-icon-hot-sale:before{content:"\e6d8"}.van-icon-location-o:before{content:"\e6d9"}.van-icon-location:before{content:"\e6da"}.van-icon-label:before{content:"\e6db"}.van-icon-lock:before{content:"\e6dc"}.van-icon-label-o:before{content:"\e6dd"}.van-icon-map-marked:before{content:"\e6de"}.van-icon-logistics:before{content:"\e6df"}.van-icon-manager:before{content:"\e6e0"}.van-icon-more:before{content:"\e6e1"}.van-icon-live:before{content:"\e6e2"}.van-icon-manager-o:before{content:"\e6e3"}.van-icon-medal:before{content:"\e6e4"}.van-icon-more-o:before{content:"\e6e5"}.van-icon-music-o:before{content:"\e6e6"}.van-icon-music:before{content:"\e6e7"}.van-icon-new-arrival-o:before{content:"\e6e8"}.van-icon-medal-o:before{content:"\e6e9"}.van-icon-new-o:before{content:"\e6ea"}.van-icon-free-postage:before{content:"\e6eb"}.van-icon-newspaper-o:before{content:"\e6ec"}.van-icon-new-arrival:before{content:"\e6ed"}.van-icon-minus:before{content:"\e6ee"}.van-icon-orders-o:before{content:"\e6ef"}.van-icon-new:before{content:"\e6f0"}.van-icon-paid:before{content:"\e6f1"}.van-icon-notes-o:before{content:"\e6f2"}.van-icon-other-pay:before{content:"\e6f3"}.van-icon-pause-circle:before{content:"\e6f4"}.van-icon-pause:before{content:"\e6f5"}.van-icon-pause-circle-o:before{content:"\e6f6"}.van-icon-peer-pay:before{content:"\e6f7"}.van-icon-pending-payment:before{content:"\e6f8"}.van-icon-passed:before{content:"\e6f9"}.van-icon-plus:before{content:"\e6fa"}.van-icon-phone-circle-o:before{content:"\e6fb"}.van-icon-phone-o:before{content:"\e6fc"}.van-icon-printer:before{content:"\e6fd"}.van-icon-photo-fail:before{content:"\e6fe"}.van-icon-phone:before{content:"\e6ff"}.van-icon-photo-o:before{content:"\e700"}.van-icon-play-circle:before{content:"\e701"}.van-icon-play:before{content:"\e702"}.van-icon-phone-circle:before{content:"\e703"}.van-icon-point-gift-o:before{content:"\e704"}.van-icon-point-gift:before{content:"\e705"}.van-icon-play-circle-o:before{content:"\e706"}.van-icon-shrink:before{content:"\e707"}.van-icon-photo:before{content:"\e708"}.van-icon-qr:before{content:"\e709"}.van-icon-qr-invalid:before{content:"\e70a"}.van-icon-question-o:before{content:"\e70b"}.van-icon-revoke:before{content:"\e70c"}.van-icon-replay:before{content:"\e70d"}.van-icon-service:before{content:"\e70e"}.van-icon-question:before{content:"\e70f"}.van-icon-search:before{content:"\e710"}.van-icon-refund-o:before{content:"\e711"}.van-icon-service-o:before{content:"\e712"}.van-icon-scan:before{content:"\e713"}.van-icon-share:before{content:"\e714"}.van-icon-send-gift-o:before{content:"\e715"}.van-icon-share-o:before{content:"\e716"}.van-icon-setting:before{content:"\e717"}.van-icon-points:before{content:"\e718"}.van-icon-photograph:before{content:"\e719"}.van-icon-shop:before{content:"\e71a"}.van-icon-shop-o:before{content:"\e71b"}.van-icon-shop-collect-o:before{content:"\e71c"}.van-icon-shop-collect:before{content:"\e71d"}.van-icon-smile:before{content:"\e71e"}.van-icon-shopping-cart-o:before{content:"\e71f"}.van-icon-sign:before{content:"\e720"}.van-icon-sort:before{content:"\e721"}.van-icon-star-o:before{content:"\e722"}.van-icon-smile-comment-o:before{content:"\e723"}.van-icon-stop:before{content:"\e724"}.van-icon-stop-circle-o:before{content:"\e725"}.van-icon-smile-o:before{content:"\e726"}.van-icon-star:before{content:"\e727"}.van-icon-success:before{content:"\e728"}.van-icon-stop-circle:before{content:"\e729"}.van-icon-records-o:before{content:"\e72a"}.van-icon-shopping-cart:before{content:"\e72b"}.van-icon-tosend:before{content:"\e72c"}.van-icon-todo-list:before{content:"\e72d"}.van-icon-thumb-circle-o:before{content:"\e72e"}.van-icon-thumb-circle:before{content:"\e72f"}.van-icon-umbrella-circle:before{content:"\e730"}.van-icon-underway:before{content:"\e731"}.van-icon-upgrade:before{content:"\e732"}.van-icon-todo-list-o:before{content:"\e733"}.van-icon-tv-o:before{content:"\e734"}.van-icon-underway-o:before{content:"\e735"}.van-icon-user-o:before{content:"\e736"}.van-icon-vip-card-o:before{content:"\e737"}.van-icon-vip-card:before{content:"\e738"}.van-icon-send-gift:before{content:"\e739"}.van-icon-wap-home:before{content:"\e73a"}.van-icon-wap-nav:before{content:"\e73b"}.van-icon-volume-o:before{content:"\e73c"}.van-icon-video:before{content:"\e73d"}.van-icon-wap-home-o:before{content:"\e73e"}.van-icon-volume:before{content:"\e73f"}.van-icon-warning:before{content:"\e740"}.van-icon-weapp-nav:before{content:"\e741"}.van-icon-wechat-pay:before{content:"\e742"}.van-icon-warning-o:before{content:"\e743"}.van-icon-wechat:before{content:"\e744"}.van-icon-setting-o:before{content:"\e745"}.van-icon-youzan-shield:before{content:"\e746"}.van-icon-warn-o:before{content:"\e747"}.van-icon-smile-comment:before{content:"\e748"}.van-icon-user-circle-o:before{content:"\e749"}.van-icon-video-o:before{content:"\e74a"}.van-icon-add-square:before{content:"\e65c"}.van-icon-add:before{content:"\e65d"}.van-icon-arrow-down:before{content:"\e65e"}.van-icon-arrow-up:before{content:"\e65f"}.van-icon-arrow:before{content:"\e660"}.van-icon-after-sale:before{content:"\e661"}.van-icon-add-o:before{content:"\e662"}.van-icon-alipay:before{content:"\e663"}.van-icon-ascending:before{content:"\e664"}.van-icon-apps-o:before{content:"\e665"}.van-icon-aim:before{content:"\e666"}.van-icon-award:before{content:"\e667"}.van-icon-arrow-left:before{content:"\e668"}.van-icon-award-o:before{content:"\e669"}.van-icon-audio:before{content:"\e66a"}.van-icon-bag-o:before{content:"\e66b"}.van-icon-balance-list:before{content:"\e66c"}.van-icon-back-top:before{content:"\e66d"}.van-icon-bag:before{content:"\e66e"}.van-icon-balance-pay:before{content:"\e66f"}.van-icon-balance-o:before{content:"\e670"}.van-icon-bar-chart-o:before{content:"\e671"}.van-icon-bars:before{content:"\e672"}.van-icon-balance-list-o:before{content:"\e673"}.van-icon-birthday-cake-o:before{content:"\e674"}.van-icon-bookmark:before{content:"\e675"}.van-icon-bill:before{content:"\e676"}.van-icon-bell:before{content:"\e677"}.van-icon-browsing-history-o:before{content:"\e678"}.van-icon-browsing-history:before{content:"\e679"}.van-icon-bookmark-o:before{content:"\e67a"}.van-icon-bulb-o:before{content:"\e67b"}.van-icon-bullhorn-o:before{content:"\e67c"}.van-icon-bill-o:before{content:"\e67d"}.van-icon-calendar-o:before{content:"\e67e"}.van-icon-brush-o:before{content:"\e67f"}.van-icon-card:before{content:"\e680"}.van-icon-cart-o:before{content:"\e681"}.van-icon-cart-circle:before{content:"\e682"}.van-icon-cart-circle-o:before{content:"\e683"}.van-icon-cart:before{content:"\e684"}.van-icon-cash-on-deliver:before{content:"\e685"}.van-icon-cash-back-record-o:before{content:"\e686"}.van-icon-cashier-o:before{content:"\e687"}.van-icon-chart-trending-o:before{content:"\e688"}.van-icon-certificate:before{content:"\e689"}.van-icon-chat:before{content:"\e68a"}.van-icon-clear:before{content:"\e68b"}.van-icon-chat-o:before{content:"\e68c"}.van-icon-checked:before{content:"\e68d"}.van-icon-clock:before{content:"\e68e"}.van-icon-clock-o:before{content:"\e68f"}.van-icon-close:before{content:"\e690"}.van-icon-closed-eye:before{content:"\e691"}.van-icon-circle:before{content:"\e692"}.van-icon-cluster-o:before{content:"\e693"}.van-icon-column:before{content:"\e694"}.van-icon-comment-circle-o:before{content:"\e695"}.van-icon-cluster:before{content:"\e696"}.van-icon-comment:before{content:"\e697"}.van-icon-comment-o:before{content:"\e698"}.van-icon-comment-circle:before{content:"\e699"}.van-icon-completed-o:before{content:"\e69a"}.van-icon-credit-pay:before{content:"\e69b"}.van-icon-coupon:before{content:"\e69c"}.van-icon-debit-pay:before{content:"\e69d"}.van-icon-coupon-o:before{content:"\e69e"}.van-icon-contact-o:before{content:"\e69f"}.van-icon-descending:before{content:"\e6a0"}.van-icon-desktop-o:before{content:"\e6a1"}.van-icon-diamond-o:before{content:"\e6a2"}.van-icon-description-o:before{content:"\e6a3"}.van-icon-delete:before{content:"\e6a4"}.van-icon-diamond:before{content:"\e6a5"}.van-icon-delete-o:before{content:"\e6a6"}.van-icon-cross:before{content:"\e6a7"}.van-icon-edit:before{content:"\e6a8"}.van-icon-ellipsis:before{content:"\e6a9"}.van-icon-down:before{content:"\e6aa"}.van-icon-discount-o:before{content:"\e6ab"}.van-icon-ecard-pay:before{content:"\e6ac"}.van-icon-envelop-o:before{content:"\e6ae"}@font-face{font-weight:400;font-family:vant-icon;font-style:normal;font-display:auto;src:url(data:font/woff2;charset=utf-8;base64,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) format("woff2"),url(//at.alicdn.com/t/c/font_2553510_ciljc7axaw7.woff?t=1705587463221) format("woff")}.van-icon__image{display:block;width:1em;height:1em;object-fit:contain}
:root,:host{--van-loading-text-color: var(--van-text-color-2);--van-loading-text-font-size: var(--van-font-size-md);--van-loading-spinner-color: var(--van-gray-5);--van-loading-spinner-size: 30px;--van-loading-spinner-duration: .8s}.van-loading{position:relative;color:var(--van-loading-spinner-color);font-size:0;vertical-align:middle}.van-loading__spinner{position:relative;display:inline-block;width:var(--van-loading-spinner-size);max-width:100%;height:var(--van-loading-spinner-size);max-height:100%;vertical-align:middle;animation:van-rotate var(--van-loading-spinner-duration) linear infinite}.van-loading__spinner--spinner{animation-timing-function:steps(12)}.van-loading__spinner--circular{animation-duration:2s}.van-loading__line{position:absolute;top:0;left:0;width:100%;height:100%}.van-loading__line:before{display:block;width:2px;height:25%;margin:0 auto;background-color:currentColor;border-radius:40%;content:" "}.van-loading__circular{display:block;width:100%;height:100%}.van-loading__circular circle{animation:van-circular 1.5s ease-in-out infinite;stroke:currentColor;stroke-width:3;stroke-linecap:round}.van-loading__text{display:inline-block;margin-left:var(--van-padding-xs);color:var(--van-loading-text-color);font-size:var(--van-loading-text-font-size);vertical-align:middle}.van-loading--vertical{display:flex;flex-direction:column;align-items:center}.van-loading--vertical .van-loading__text{margin:var(--van-padding-xs) 0 0}@keyframes van-circular{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-40}to{stroke-dasharray:90,150;stroke-dashoffset:-120}}.van-loading__line--1{transform:rotate(30deg);opacity:1}.van-loading__line--2{transform:rotate(60deg);opacity:.9375}.van-loading__line--3{transform:rotate(90deg);opacity:.875}.van-loading__line--4{transform:rotate(120deg);opacity:.8125}.van-loading__line--5{transform:rotate(150deg);opacity:.75}.van-loading__line--6{transform:rotate(180deg);opacity:.6875}.van-loading__line--7{transform:rotate(210deg);opacity:.625}.van-loading__line--8{transform:rotate(240deg);opacity:.5625}.van-loading__line--9{transform:rotate(270deg);opacity:.5}.van-loading__line--10{transform:rotate(300deg);opacity:.4375}.van-loading__line--11{transform:rotate(330deg);opacity:.375}.van-loading__line--12{transform:rotate(360deg);opacity:.3125}
:root,:host{--van-button-mini-height: 24px;--van-button-mini-padding: 0 var(--van-padding-base);--van-button-mini-font-size: var(--van-font-size-xs);--van-button-small-height: 32px;--van-button-small-padding: 0 var(--van-padding-xs);--van-button-small-font-size: var(--van-font-size-sm);--van-button-normal-padding: 0 15px;--van-button-normal-font-size: var(--van-font-size-md);--van-button-large-height: 50px;--van-button-default-height: 44px;--van-button-default-line-height: 1.2;--van-button-default-font-size: var(--van-font-size-lg);--van-button-default-color: var(--van-text-color);--van-button-default-background: var(--van-background-2);--van-button-default-border-color: var(--van-gray-4);--van-button-primary-color: var(--van-white);--van-button-primary-background: var(--van-primary-color);--van-button-primary-border-color: var(--van-primary-color);--van-button-success-color: var(--van-white);--van-button-success-background: var(--van-success-color);--van-button-success-border-color: var(--van-success-color);--van-button-danger-color: var(--van-white);--van-button-danger-background: var(--van-danger-color);--van-button-danger-border-color: var(--van-danger-color);--van-button-warning-color: var(--van-white);--van-button-warning-background: var(--van-warning-color);--van-button-warning-border-color: var(--van-warning-color);--van-button-border-width: var(--van-border-width);--van-button-radius: var(--van-radius-md);--van-button-round-radius: var(--van-radius-max);--van-button-plain-background: var(--van-white);--van-button-disabled-opacity: var(--van-disabled-opacity);--van-button-icon-size: 1.2em;--van-button-loading-icon-size: 20px}.van-theme-dark{--van-button-plain-background: transparent}.van-button{position:relative;display:inline-block;box-sizing:border-box;height:var(--van-button-default-height);margin:0;padding:0;font-size:var(--van-button-default-font-size);line-height:var(--van-button-default-line-height);text-align:center;border-radius:var(--van-button-radius);cursor:pointer;transition:opacity var(--van-duration-fast);-webkit-appearance:none;-webkit-font-smoothing:auto}.van-button:before{position:absolute;top:50%;left:50%;width:100%;height:100%;background:var(--van-black);border:inherit;border-color:var(--van-black);border-radius:inherit;transform:translate(-50%,-50%);opacity:0;content:" "}.van-button:active:before{opacity:.1}.van-button--loading:before,.van-button--disabled:before{display:none}.van-button--default{color:var(--van-button-default-color);background:var(--van-button-default-background);border:var(--van-button-border-width) solid var(--van-button-default-border-color)}.van-button--primary{color:var(--van-button-primary-color);background:var(--van-button-primary-background);border:var(--van-button-border-width) solid var(--van-button-primary-border-color)}.van-button--success{color:var(--van-button-success-color);background:var(--van-button-success-background);border:var(--van-button-border-width) solid var(--van-button-success-border-color)}.van-button--danger{color:var(--van-button-danger-color);background:var(--van-button-danger-background);border:var(--van-button-border-width) solid var(--van-button-danger-border-color)}.van-button--warning{color:var(--van-button-warning-color);background:var(--van-button-warning-background);border:var(--van-button-border-width) solid var(--van-button-warning-border-color)}.van-button--plain{background:var(--van-button-plain-background)}.van-button--plain.van-button--primary{color:var(--van-button-primary-background)}.van-button--plain.van-button--success{color:var(--van-button-success-background)}.van-button--plain.van-button--danger{color:var(--van-button-danger-background)}.van-button--plain.van-button--warning{color:var(--van-button-warning-background)}.van-button--large{width:100%;height:var(--van-button-large-height)}.van-button--normal{padding:var(--van-button-normal-padding);font-size:var(--van-button-normal-font-size)}.van-button--small{height:var(--van-button-small-height);padding:var(--van-button-small-padding);font-size:var(--van-button-small-font-size)}.van-button__loading{color:inherit;font-size:inherit}.van-button__loading .van-loading__spinner{color:currentColor;width:var(--van-button-loading-icon-size);height:var(--van-button-loading-icon-size)}.van-button--mini{height:var(--van-button-mini-height);padding:var(--van-button-mini-padding);font-size:var(--van-button-mini-font-size)}.van-button--mini+.van-button--mini{margin-left:var(--van-padding-base)}.van-button--block{display:block;width:100%}.van-button--disabled{cursor:not-allowed;opacity:var(--van-button-disabled-opacity)}.van-button--loading{cursor:default}.van-button--round{border-radius:var(--van-button-round-radius)}.van-button--square{border-radius:0}.van-button__content{display:flex;align-items:center;justify-content:center;height:100%}.van-button__content:before{content:" "}.van-button__icon{font-size:var(--van-button-icon-size);line-height:inherit}.van-button__icon+.van-button__text,.van-button__loading+.van-button__text,.van-button__text+.van-button__icon,.van-button__text+.van-button__loading{margin-left:var(--van-padding-base)}.van-button--hairline{border-width:0}.van-button--hairline:after{border-color:inherit;border-radius:calc(var(--van-button-radius) * 2)}.van-button--hairline.van-button--round:after{border-radius:var(--van-button-round-radius)}.van-button--hairline.van-button--square:after{border-radius:0}
:root,:host{--van-overlay-z-index: 1;--van-overlay-background: rgba(0, 0, 0, .7)}.van-overlay{position:fixed;top:0;left:0;z-index:var(--van-overlay-z-index);width:100%;height:100%;background:var(--van-overlay-background)}
:root,:host{--van-popup-background: var(--van-background-2);--van-popup-transition: transform var(--van-duration-base);--van-popup-round-radius: 16px;--van-popup-close-icon-size: 22px;--van-popup-close-icon-color: var(--van-gray-5);--van-popup-close-icon-margin: 16px;--van-popup-close-icon-z-index: 1}.van-overflow-hidden{overflow:hidden!important}.van-popup{position:fixed;max-height:100%;overflow-y:auto;box-sizing:border-box;background:var(--van-popup-background);transition:var(--van-popup-transition);-webkit-overflow-scrolling:touch}.van-popup--center{top:50%;left:0;right:0;width:-webkit-fit-content;width:fit-content;max-width:calc(100vw - var(--van-padding-md) * 2);margin:0 auto;transform:translateY(-50%)}.van-popup--center.van-popup--round{border-radius:var(--van-popup-round-radius)}.van-popup--top{top:0;left:0;width:100%}.van-popup--top.van-popup--round{border-radius:0 0 var(--van-popup-round-radius) var(--van-popup-round-radius)}.van-popup--right{top:50%;right:0;transform:translate3d(0,-50%,0)}.van-popup--right.van-popup--round{border-radius:var(--van-popup-round-radius) 0 0 var(--van-popup-round-radius)}.van-popup--bottom{bottom:0;left:0;width:100%}.van-popup--bottom.van-popup--round{border-radius:var(--van-popup-round-radius) var(--van-popup-round-radius) 0 0}.van-popup--left{top:50%;left:0;transform:translate3d(0,-50%,0)}.van-popup--left.van-popup--round{border-radius:0 var(--van-popup-round-radius) var(--van-popup-round-radius) 0}.van-popup-slide-top-enter-active,.van-popup-slide-left-enter-active,.van-popup-slide-right-enter-active,.van-popup-slide-bottom-enter-active{transition-timing-function:var(--van-ease-out)}.van-popup-slide-top-leave-active,.van-popup-slide-left-leave-active,.van-popup-slide-right-leave-active,.van-popup-slide-bottom-leave-active{transition-timing-function:var(--van-ease-in)}.van-popup-slide-top-enter-from,.van-popup-slide-top-leave-active{transform:translate3d(0,-100%,0)}.van-popup-slide-right-enter-from,.van-popup-slide-right-leave-active{transform:translate3d(100%,-50%,0)}.van-popup-slide-bottom-enter-from,.van-popup-slide-bottom-leave-active{transform:translate3d(0,100%,0)}.van-popup-slide-left-enter-from,.van-popup-slide-left-leave-active{transform:translate3d(-100%,-50%,0)}.van-popup__close-icon{position:absolute;z-index:var(--van-popup-close-icon-z-index);color:var(--van-popup-close-icon-color);font-size:var(--van-popup-close-icon-size)}.van-popup__close-icon--top-left{top:var(--van-popup-close-icon-margin);left:var(--van-popup-close-icon-margin)}.van-popup__close-icon--top-right{top:var(--van-popup-close-icon-margin);right:var(--van-popup-close-icon-margin)}.van-popup__close-icon--bottom-left{bottom:var(--van-popup-close-icon-margin);left:var(--van-popup-close-icon-margin)}.van-popup__close-icon--bottom-right{right:var(--van-popup-close-icon-margin);bottom:var(--van-popup-close-icon-margin)}
:root,:host{--van-popover-arrow-size: 6px;--van-popover-radius: var(--van-radius-lg);--van-popover-action-width: 128px;--van-popover-action-height: 44px;--van-popover-action-font-size: var(--van-font-size-md);--van-popover-action-line-height: var(--van-line-height-md);--van-popover-action-icon-size: 20px;--van-popover-horizontal-action-height: 34px;--van-popover-horizontal-action-icon-size: 16px;--van-popover-light-text-color: var(--van-text-color);--van-popover-light-background: var(--van-background-2);--van-popover-light-action-disabled-text-color: var(--van-text-color-3);--van-popover-dark-text-color: var(--van-white);--van-popover-dark-background: #4a4a4a;--van-popover-dark-action-disabled-text-color: var(--van-text-color-2)}.van-popover{position:absolute;overflow:visible;background-color:transparent;transition:opacity .15s,transform .15s}.van-popover__wrapper{display:inline-block}.van-popover__arrow{position:absolute;width:0;height:0;border-color:transparent;border-style:solid;border-width:var(--van-popover-arrow-size)}.van-popover__content{overflow:hidden;border-radius:var(--van-popover-radius)}.van-popover__content--horizontal{display:flex;width:-webkit-max-content;width:max-content}.van-popover__content--horizontal .van-popover__action{flex:none;width:auto;height:var(--van-popover-horizontal-action-height);padding:0 var(--van-padding-sm)}.van-popover__content--horizontal .van-popover__action:last-child:after{display:none}.van-popover__content--horizontal .van-popover__action-icon{margin-right:var(--van-padding-base);font-size:var(--van-popover-horizontal-action-icon-size)}.van-popover__action{position:relative;display:flex;align-items:center;box-sizing:border-box;width:var(--van-popover-action-width);height:var(--van-popover-action-height);padding:0 var(--van-padding-md);font-size:var(--van-popover-action-font-size);line-height:var(--van-line-height-md);cursor:pointer}.van-popover__action:last-child .van-popover__action-text:after{display:none}.van-popover__action-text{display:flex;flex:1;align-items:center;justify-content:center;height:100%}.van-popover__action-icon{margin-right:var(--van-padding-xs);font-size:var(--van-popover-action-icon-size)}.van-popover__action--with-icon .van-popover__action-text{justify-content:flex-start}.van-popover[data-popper-placement^=top] .van-popover__arrow{bottom:0;border-top-color:currentColor;border-bottom-width:0;margin-bottom:calc(var(--van-popover-arrow-size) * -1)}.van-popover[data-popper-placement=top]{transform-origin:50% 100%}.van-popover[data-popper-placement=top] .van-popover__arrow{left:50%;transform:translate(-50%)}.van-popover[data-popper-placement=top-start]{transform-origin:0 100%}.van-popover[data-popper-placement=top-start] .van-popover__arrow{left:var(--van-padding-md)}.van-popover[data-popper-placement=top-end]{transform-origin:100% 100%}.van-popover[data-popper-placement=top-end] .van-popover__arrow{right:var(--van-padding-md)}.van-popover[data-popper-placement^=left] .van-popover__arrow{right:0;border-right-width:0;border-left-color:currentColor;margin-right:calc(var(--van-popover-arrow-size) * -1)}.van-popover[data-popper-placement=left]{transform-origin:100% 50%}.van-popover[data-popper-placement=left] .van-popover__arrow{top:50%;transform:translateY(-50%)}.van-popover[data-popper-placement=left-start]{transform-origin:100% 0}.van-popover[data-popper-placement=left-start] .van-popover__arrow{top:var(--van-padding-md)}.van-popover[data-popper-placement=left-end]{transform-origin:100% 100%}.van-popover[data-popper-placement=left-end] .van-popover__arrow{bottom:var(--van-padding-md)}.van-popover[data-popper-placement^=right] .van-popover__arrow{left:0;border-right-color:currentColor;border-left-width:0;margin-left:calc(var(--van-popover-arrow-size) * -1)}.van-popover[data-popper-placement=right]{transform-origin:0 50%}.van-popover[data-popper-placement=right] .van-popover__arrow{top:50%;transform:translateY(-50%)}.van-popover[data-popper-placement=right-start]{transform-origin:0 0}.van-popover[data-popper-placement=right-start] .van-popover__arrow{top:var(--van-padding-md)}.van-popover[data-popper-placement=right-end]{transform-origin:0 100%}.van-popover[data-popper-placement=right-end] .van-popover__arrow{bottom:var(--van-padding-md)}.van-popover[data-popper-placement^=bottom] .van-popover__arrow{top:0;border-top-width:0;border-bottom-color:currentColor;margin-top:calc(var(--van-popover-arrow-size) * -1)}.van-popover[data-popper-placement=bottom]{transform-origin:50% 0}.van-popover[data-popper-placement=bottom] .van-popover__arrow{left:50%;transform:translate(-50%)}.van-popover[data-popper-placement=bottom-start]{transform-origin:0 0}.van-popover[data-popper-placement=bottom-start] .van-popover__arrow{left:var(--van-padding-md)}.van-popover[data-popper-placement=bottom-end]{transform-origin:100% 0}.van-popover[data-popper-placement=bottom-end] .van-popover__arrow{right:var(--van-padding-md)}.van-popover--light{color:var(--van-popover-light-text-color)}.van-popover--light .van-popover__content{background:var(--van-popover-light-background);box-shadow:0 2px 12px rgba(50,50,51,.12)}.van-popover--light .van-popover__arrow{color:var(--van-popover-light-background)}.van-popover--light .van-popover__action:active{background-color:var(--van-active-color)}.van-popover--light .van-popover__action--disabled{color:var(--van-popover-light-action-disabled-text-color);cursor:not-allowed}.van-popover--light .van-popover__action--disabled:active{background-color:transparent}.van-popover--dark{color:var(--van-popover-dark-text-color)}.van-popover--dark .van-popover__content{background:var(--van-popover-dark-background)}.van-popover--dark .van-popover__arrow{color:var(--van-popover-dark-background)}.van-popover--dark .van-popover__action:active{background-color:rgba(0,0,0,.2)}.van-popover--dark .van-popover__action--disabled{color:var(--van-popover-dark-action-disabled-text-color)}.van-popover--dark .van-popover__action--disabled:active{background-color:transparent}.van-popover--dark .van-popover__action-text:after{border-color:var(--van-gray-7)}.van-popover-zoom-enter-from,.van-popover-zoom-leave-active{transform:scale(.8);opacity:0}.van-popover-zoom-enter-active{transition-timing-function:var(--van-ease-out)}.van-popover-zoom-leave-active{transition-timing-function:var(--van-ease-in)}
:root,:host{--van-slider-active-background: var(--van-primary-color);--van-slider-inactive-background: var(--van-gray-3);--van-slider-disabled-opacity: var(--van-disabled-opacity);--van-slider-bar-height: 2px;--van-slider-button-width: 24px;--van-slider-button-height: 24px;--van-slider-button-radius: 50%;--van-slider-button-background: var(--van-white);--van-slider-button-shadow: 0 1px 2px rgba(0, 0, 0, .5)}.van-theme-dark{--van-slider-inactive-background: var(--van-background-3)}.van-slider{position:relative;width:100%;height:var(--van-slider-bar-height);background:var(--van-slider-inactive-background);border-radius:var(--van-radius-max);cursor:pointer}.van-slider:before{position:absolute;top:calc(var(--van-padding-xs) * -1);right:0;bottom:calc(var(--van-padding-xs) * -1);left:0;content:""}.van-slider__bar{position:absolute;width:100%;height:100%;background:var(--van-slider-active-background);border-radius:inherit;transition:all var(--van-duration-fast)}.van-slider__button{width:var(--van-slider-button-width);height:var(--van-slider-button-height);background:var(--van-slider-button-background);border-radius:var(--van-slider-button-radius);box-shadow:var(--van-slider-button-shadow)}.van-slider__button-wrapper{position:absolute;cursor:-webkit-grab;cursor:grab;top:50%}.van-slider__button-wrapper--right{right:0;transform:translate3d(50%,-50%,0)}.van-slider__button-wrapper--left{left:0;transform:translate3d(-50%,-50%,0)}.van-slider--disabled{cursor:not-allowed;opacity:var(--van-slider-disabled-opacity)}.van-slider--disabled .van-slider__button-wrapper{cursor:not-allowed}.van-slider--vertical{display:inline-block;width:var(--van-slider-bar-height);height:100%}.van-slider--vertical .van-slider__button-wrapper--right{top:auto;right:50%;bottom:0;transform:translate3d(50%,50%,0)}.van-slider--vertical .van-slider__button-wrapper--left{top:0;right:50%;left:auto;transform:translate3d(50%,-50%,0)}.van-slider--vertical:before{top:0;right:calc(var(--van-padding-xs) * -1);bottom:0;left:calc(var(--van-padding-xs) * -1)}
.base-btn[data-v-394afb03] {
  width: var(--3e06cfc9);
  height: var(--3e06cfc9);
  appearance: none;
  border-radius: var(--3e06cfc9);
  border: none;
  background-color: transparent;
  display: flex;
  align-items: center;
  justify-content: center;
}
.base-btn[data-v-394afb03]:active {
  background-color: rgba(0, 0, 0, 0.3);
}
:root,:host{--van-empty-padding: var(--van-padding-xl) 0;--van-empty-image-size: 160px;--van-empty-description-margin-top: var(--van-padding-md);--van-empty-description-padding: 0 60px;--van-empty-description-color: var(--van-text-color-2);--van-empty-description-font-size: var(--van-font-size-md);--van-empty-description-line-height: var(--van-line-height-md);--van-empty-bottom-margin-top: 24px}.van-empty{display:flex;flex-direction:column;align-items:center;justify-content:center;box-sizing:border-box;padding:var(--van-empty-padding)}.van-empty__image{width:var(--van-empty-image-size);height:var(--van-empty-image-size)}.van-empty__image img{width:100%;height:100%}.van-empty__description{margin-top:var(--van-empty-description-margin-top);padding:var(--van-empty-description-padding);color:var(--van-empty-description-color);font-size:var(--van-empty-description-font-size);line-height:var(--van-empty-description-line-height)}.van-empty__bottom{margin-top:var(--van-empty-bottom-margin-top)}.van-theme-dark .van-empty{opacity:.5}
.header[data-v-4a5ab5c6] {
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid #ebeef5;
  padding: 10px 15px;
}
.header .logo[data-v-4a5ab5c6] {
  display: flex;
  align-items: center;
}
.header .logo .title[data-v-4a5ab5c6] {
  font-family: 'LXGWMarkerGothic';
  font-size: 20px;
  font-weight: bold;
  margin-left: 10px;
}
.custom[data-v-2c463995] .content h4 {
  margin: 15px 0;
}
.custom[data-v-2c463995] .content p {
  color: #666;
  line-height: 1.5;
  margin: 10px 0;
  font-size: 14px;
}
:root,:host{--van-image-placeholder-text-color: var(--van-text-color-2);--van-image-placeholder-font-size: var(--van-font-size-md);--van-image-placeholder-background: var(--van-background);--van-image-loading-icon-size: 32px;--van-image-loading-icon-color: var(--van-gray-4);--van-image-error-icon-size: 32px;--van-image-error-icon-color: var(--van-gray-4)}.van-image{position:relative;display:inline-block}.van-image--round{overflow:hidden;border-radius:var(--van-radius-max)}.van-image--round .van-image__img{border-radius:inherit}.van-image--block{display:block}.van-image__img,.van-image__error,.van-image__loading{display:block;width:100%;height:100%}.van-image__error,.van-image__loading{position:absolute;top:0;left:0;display:flex;flex-direction:column;align-items:center;justify-content:center;color:var(--van-image-placeholder-text-color);font-size:var(--van-image-placeholder-font-size);background:var(--van-image-placeholder-background)}.van-image__loading-icon{color:var(--van-image-loading-icon-color);font-size:var(--van-image-loading-icon-size)}.van-image__error-icon{color:var(--van-image-error-icon-color);font-size:var(--van-image-error-icon-size)}
:root,:host{--van-action-bar-background: var(--van-background-2);--van-action-bar-height: 50px}.van-action-bar{position:fixed;right:0;bottom:0;left:0;display:flex;align-items:center;box-sizing:content-box;height:var(--van-action-bar-height);background:var(--van-action-bar-background)}
:root,:host{--van-action-bar-button-height: 40px;--van-action-bar-button-warning-color: var(--van-gradient-orange);--van-action-bar-button-danger-color: var(--van-gradient-red)}.van-action-bar-button{flex:1;height:var(--van-action-bar-button-height);font-weight:var(--van-font-bold);font-size:var(--van-font-size-md);border:none;border-radius:0}.van-action-bar-button--first{margin-left:5px;border-top-left-radius:var(--van-radius-max);border-bottom-left-radius:var(--van-radius-max)}.van-action-bar-button--last{margin-right:5px;border-top-right-radius:var(--van-radius-max);border-bottom-right-radius:var(--van-radius-max)}.van-action-bar-button--warning{background:var(--van-action-bar-button-warning-color)}.van-action-bar-button--danger{background:var(--van-action-bar-button-danger-color)}@media (max-width: 321px){.van-action-bar-button{font-size:13px}}
:root,:host{--van-dialog-width: 320px;--van-dialog-small-screen-width: 90%;--van-dialog-font-size: var(--van-font-size-lg);--van-dialog-transition: var(--van-duration-base);--van-dialog-radius: 16px;--van-dialog-background: var(--van-background-2);--van-dialog-header-font-weight: var(--van-font-bold);--van-dialog-header-line-height: 24px;--van-dialog-header-padding-top: 26px;--van-dialog-header-isolated-padding: var(--van-padding-lg) 0;--van-dialog-message-padding: var(--van-padding-lg);--van-dialog-message-font-size: var(--van-font-size-md);--van-dialog-message-line-height: var(--van-line-height-md);--van-dialog-message-max-height: 60vh;--van-dialog-has-title-message-text-color: var(--van-gray-7);--van-dialog-has-title-message-padding-top: var(--van-padding-xs);--van-dialog-button-height: 48px;--van-dialog-round-button-height: 36px;--van-dialog-confirm-button-text-color: var(--van-primary-color)}.van-dialog{top:45%;width:var(--van-dialog-width);overflow:hidden;font-size:var(--van-dialog-font-size);background:var(--van-dialog-background);border-radius:var(--van-dialog-radius);-webkit-backface-visibility:hidden;backface-visibility:hidden;transition:var(--van-dialog-transition);transition-property:transform,opacity}@media (max-width: 321px){.van-dialog{width:var(--van-dialog-small-screen-width)}}.van-dialog__header{color:var(--van-text-color);padding-top:var(--van-dialog-header-padding-top);font-weight:var(--van-dialog-header-font-weight);line-height:var(--van-dialog-header-line-height);text-align:center}.van-dialog__header--isolated{padding:var(--van-dialog-header-isolated-padding)}.van-dialog__content--isolated{display:flex;align-items:center;min-height:104px}.van-dialog__message{color:var(--van-text-color);flex:1;max-height:var(--van-dialog-message-max-height);padding:26px var(--van-dialog-message-padding);overflow-y:auto;font-size:var(--van-dialog-message-font-size);line-height:var(--van-dialog-message-line-height);white-space:pre-wrap;text-align:center;word-wrap:break-word;-webkit-overflow-scrolling:touch}.van-dialog__message--has-title{padding-top:var(--van-dialog-has-title-message-padding-top);color:var(--van-dialog-has-title-message-text-color)}.van-dialog__message--left{text-align:left}.van-dialog__message--right{text-align:right}.van-dialog__message--justify{text-align:justify}.van-dialog__footer{display:flex;overflow:hidden;-webkit-user-select:none;user-select:none}.van-dialog__confirm,.van-dialog__cancel{flex:1;height:var(--van-dialog-button-height);margin:0;border:0;border-radius:0}.van-dialog__confirm,.van-dialog__confirm:active{color:var(--van-dialog-confirm-button-text-color)}.van-dialog--round-button .van-dialog__footer{position:relative;height:auto;padding:var(--van-padding-xs) var(--van-padding-lg) var(--van-padding-md)}.van-dialog--round-button .van-dialog__message{padding-bottom:var(--van-padding-md);color:var(--van-text-color)}.van-dialog--round-button .van-dialog__confirm,.van-dialog--round-button .van-dialog__cancel{height:var(--van-dialog-round-button-height)}.van-dialog--round-button .van-dialog__confirm{color:var(--van-white)}.van-dialog--round-button .van-action-bar-button--first{border-top-left-radius:var(--van-radius-max);border-bottom-left-radius:var(--van-radius-max)}.van-dialog--round-button .van-action-bar-button--last{border-top-right-radius:var(--van-radius-max);border-bottom-right-radius:var(--van-radius-max)}.van-dialog-bounce-enter-from{transform:translate3d(0,-50%,0) scale(.7);opacity:0}.van-dialog-bounce-leave-active{transform:translate3d(0,-50%,0) scale(.9);opacity:0}
.playlist[data-v-025a921d] {
  list-style: none;
  padding: 0;
  margin: 0;
  background-color: #f4f4f4;
}
.playlist .item[data-v-025a921d] {
  display: flex;
  padding: 4px 4px 4px 10px;
  box-sizing: border-box;
  width: 100%;
  justify-content: space-between;
  background-color: #fff;
}
.playlist .item.active[data-v-025a921d] {
  position: relative;
  background-color: rgba(195, 195, 196, 0.2);
}
.playlist .item.active[data-v-025a921d]::before {
  position: absolute;
  content: '';
  top: 0;
  left: 0;
  width: 3px;
  height: 100%;
  background-color: #02c902;
}
:root,:host{--van-toast-max-width: 70%;--van-toast-font-size: var(--van-font-size-md);--van-toast-text-color: var(--van-white);--van-toast-loading-icon-color: var(--van-white);--van-toast-line-height: var(--van-line-height-md);--van-toast-radius: var(--van-radius-lg);--van-toast-background: rgba(0, 0, 0, .7);--van-toast-icon-size: 36px;--van-toast-text-min-width: 96px;--van-toast-text-padding: var(--van-padding-xs) var(--van-padding-sm);--van-toast-default-padding: var(--van-padding-md);--van-toast-default-width: 88px;--van-toast-default-min-height: 88px;--van-toast-position-top-distance: 20%;--van-toast-position-bottom-distance: 20%}.van-toast{display:flex;flex-direction:column;align-items:center;justify-content:center;box-sizing:content-box;transition:all var(--van-duration-fast);width:var(--van-toast-default-width);max-width:var(--van-toast-max-width);min-height:var(--van-toast-default-min-height);padding:var(--van-toast-default-padding);color:var(--van-toast-text-color);font-size:var(--van-toast-font-size);line-height:var(--van-toast-line-height);white-space:pre-wrap;word-break:break-all;text-align:center;background:var(--van-toast-background);border-radius:var(--van-toast-radius)}.van-toast--break-normal{word-break:normal;word-wrap:normal}.van-toast--break-word{word-break:normal;word-wrap:break-word}.van-toast--unclickable{overflow:hidden;cursor:not-allowed}.van-toast--unclickable *{pointer-events:none}.van-toast--text,.van-toast--html{width:-webkit-fit-content;width:fit-content;min-width:var(--van-toast-text-min-width);min-height:0;padding:var(--van-toast-text-padding)}.van-toast--text .van-toast__text,.van-toast--html .van-toast__text{margin-top:0}.van-toast--top{top:var(--van-toast-position-top-distance)}.van-toast--bottom{top:auto;bottom:var(--van-toast-position-bottom-distance)}.van-toast__icon{font-size:var(--van-toast-icon-size)}.van-toast__loading{padding:var(--van-padding-base);color:var(--van-toast-loading-icon-color)}.van-toast__text{margin-top:var(--van-padding-xs)}
.music-player[data-v-6fa33c71] {
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: none;
}
.music-player[data-v-6fa33c71] .header {
  border-bottom: none;
}
.music-player[data-v-6fa33c71] .header .logo {
  border-bottom: none;
  filter: drop-shadow(0px 0px 1px #fff);
}
.music-player[data-v-6fa33c71] .header .title {
  text-shadow: 0 1px #fff, 1px 0 #fff, -1px 0 #fff, 0 -1px #fff;
}
.music-player .empty[data-v-6fa33c71] {
  width: 100%;
  height: 100%;
  background-color: #fff;
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
}
.music-player .layout[data-v-6fa33c71] {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  padding: 10px;
  box-sizing: border-box;
  backdrop-filter: blur(40px) brightness(60%);
  color: #fff;
}
.music-player .layout .content[data-v-6fa33c71] {
  flex: 1;
  display: flex;
  align-items: center;
  flex-direction: column;
  justify-content: space-between;
}
.music-player .layout .content .cover[data-v-6fa33c71] {
  width: 200px;
  height: 200px;
  border-radius: 10px;
}
.music-player .layout .content .custom-button[data-v-6fa33c71] {
  width: 6px;
  height: 6px;
  border-radius: 6px;
  background: #fff;
}
.music-player .layout .toolbar[data-v-6fa33c71] {
  height: 80px;
  padding: 0 16px;
  margin-bottom: 20px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: rgba(0, 0, 0, 0.3);
  border-radius: 20px;
}
@media screen and (max-width: 500px) {
.music-player[data-v-6fa33c71] {
    display: block;
}
}
[data-v-6fa33c71] .i-icon {
  display: flex;
}
.aplayer{background:#fff;font-family:Arial,Helvetica,sans-serif;margin:5px;box-shadow:0 2px 2px 0 rgba(0,0,0,.07),0 1px 5px 0 rgba(0,0,0,.1);border-radius:2px;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;line-height:normal;position:relative}.aplayer *{box-sizing:content-box}.aplayer svg{width:100%;height:100%}.aplayer svg circle,.aplayer svg path{fill:#fff}.aplayer.aplayer-withlist .aplayer-info{border-bottom:1px solid #e9e9e9}.aplayer.aplayer-withlist .aplayer-list{display:block}.aplayer.aplayer-withlist .aplayer-icon-order,.aplayer.aplayer-withlist .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-menu{display:inline}.aplayer.aplayer-withlrc .aplayer-pic{height:90px;width:90px}.aplayer.aplayer-withlrc .aplayer-info{margin-left:90px;height:90px;padding:10px 7px 0}.aplayer.aplayer-withlrc .aplayer-lrc{display:block}.aplayer.aplayer-narrow{width:66px}.aplayer.aplayer-narrow .aplayer-info,.aplayer.aplayer-narrow .aplayer-list{display:none}.aplayer.aplayer-narrow .aplayer-body,.aplayer.aplayer-narrow .aplayer-pic{height:66px;width:66px}.aplayer.aplayer-fixed{position:fixed;bottom:0;left:0;right:0;margin:0;z-index:99;overflow:visible;max-width:400px;box-shadow:none}.aplayer.aplayer-fixed .aplayer-list{margin-bottom:65px;border:1px solid #eee;border-bottom:none}.aplayer.aplayer-fixed .aplayer-body{position:fixed;bottom:0;left:0;right:0;margin:0;z-index:99;background:#fff;padding-right:18px;transition:all .3s ease;max-width:400px}.aplayer.aplayer-fixed .aplayer-lrc{display:block;position:fixed;bottom:10px;left:0;right:0;margin:0;z-index:98;pointer-events:none;text-shadow:-1px -1px 0 #fff}.aplayer.aplayer-fixed .aplayer-lrc:after,.aplayer.aplayer-fixed .aplayer-lrc:before{display:none}.aplayer.aplayer-fixed .aplayer-info{-webkit-transform:scaleX(1);transform:scaleX(1);-webkit-transform-origin:0 0;transform-origin:0 0;transition:all .3s ease;border-bottom:none;border-top:1px solid #e9e9e9}.aplayer.aplayer-fixed .aplayer-info .aplayer-music{width:calc(100% - 105px)}.aplayer.aplayer-fixed .aplayer-miniswitcher{display:block}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-info{display:block;-webkit-transform:scaleX(0);transform:scaleX(0)}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{width:66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-miniswitcher .aplayer-icon{-webkit-transform:rotateY(0);transform:rotateY(0)}.aplayer.aplayer-fixed .aplayer-icon-back,.aplayer.aplayer-fixed .aplayer-icon-forward,.aplayer.aplayer-fixed .aplayer-icon-lrc,.aplayer.aplayer-fixed .aplayer-icon-play{display:inline-block}.aplayer.aplayer-fixed .aplayer-icon-back,.aplayer.aplayer-fixed .aplayer-icon-forward,.aplayer.aplayer-fixed .aplayer-icon-menu,.aplayer.aplayer-fixed .aplayer-icon-play{position:absolute;bottom:27px;width:20px;height:20px}.aplayer.aplayer-fixed .aplayer-icon-back{right:75px}.aplayer.aplayer-fixed .aplayer-icon-play{right:50px}.aplayer.aplayer-fixed .aplayer-icon-forward{right:25px}.aplayer.aplayer-fixed .aplayer-icon-menu{right:0}.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order,.aplayer.aplayer-mobile .aplayer-icon-volume-down{display:none}.aplayer.aplayer-loading .aplayer-info .aplayer-controller .aplayer-loading-icon{display:block}.aplayer.aplayer-loading .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played .aplayer-thumb{-webkit-transform:scale(1);transform:scale(1)}.aplayer .aplayer-body{position:relative}.aplayer .aplayer-icon{width:15px;height:15px;border:none;background-color:transparent;outline:none;cursor:pointer;opacity:.8;vertical-align:middle;padding:0;font-size:12px;margin:0;display:inline-block}.aplayer .aplayer-icon path{transition:all .2s ease-in-out}.aplayer .aplayer-icon-back,.aplayer .aplayer-icon-forward,.aplayer .aplayer-icon-lrc,.aplayer .aplayer-icon-order,.aplayer .aplayer-icon-play{display:none}.aplayer .aplayer-icon-lrc-inactivity svg{opacity:.4}.aplayer .aplayer-icon-forward{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.aplayer .aplayer-lrc-content{display:none}.aplayer .aplayer-pic{position:relative;float:left;height:66px;width:66px;background-size:cover;background-position:50%;transition:all .3s ease;cursor:pointer}.aplayer .aplayer-pic:hover .aplayer-button{opacity:1}.aplayer .aplayer-pic .aplayer-button{position:absolute;border-radius:50%;opacity:.8;text-shadow:0 1px 1px rgba(0,0,0,.2);box-shadow:0 1px 1px rgba(0,0,0,.2);background:rgba(0,0,0,.2);transition:all .1s ease}.aplayer .aplayer-pic .aplayer-button path{fill:#fff}.aplayer .aplayer-pic .aplayer-hide{display:none}.aplayer .aplayer-pic .aplayer-play{width:26px;height:26px;border:2px solid #fff;bottom:50%;right:50%;margin:0 -15px -15px 0}.aplayer .aplayer-pic .aplayer-play svg{position:absolute;top:3px;left:4px;height:20px;width:20px}.aplayer .aplayer-pic .aplayer-pause{width:16px;height:16px;border:2px solid #fff;bottom:4px;right:4px}.aplayer .aplayer-pic .aplayer-pause svg{position:absolute;top:2px;left:2px;height:12px;width:12px}.aplayer .aplayer-info{margin-left:66px;padding:14px 7px 0 10px;height:66px;box-sizing:border-box}.aplayer .aplayer-info .aplayer-music{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin:0 0 13px 5px;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;cursor:default;padding-bottom:2px;height:20px}.aplayer .aplayer-info .aplayer-music .aplayer-title{font-size:14px}.aplayer .aplayer-info .aplayer-music .aplayer-author{font-size:12px;color:#666}.aplayer .aplayer-info .aplayer-controller{position:relative;display:flex}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap{margin:0 0 0 5px;padding:4px 0;cursor:pointer!important;flex:1}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap:hover .aplayer-bar .aplayer-played .aplayer-thumb{-webkit-transform:scale(1);transform:scale(1)}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar{position:relative;height:2px;width:100%;background:#cdcdcd}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-loaded{position:absolute;left:0;top:0;bottom:0;background:#aaa;height:2px;transition:all .5s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played{position:absolute;left:0;top:0;bottom:0;height:2px}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played .aplayer-thumb{position:absolute;top:0;right:5px;margin-top:-4px;margin-right:-10px;height:10px;width:10px;border-radius:50%;cursor:pointer;transition:all .3s ease-in-out;-webkit-transform:scale(0);transform:scale(0)}.aplayer .aplayer-info .aplayer-controller .aplayer-time{position:relative;right:0;bottom:4px;height:17px;color:#999;font-size:11px;padding-left:7px}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-time-inner{vertical-align:middle}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon{cursor:pointer;transition:all .2s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#666}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-loop{margin-right:2px}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon:hover path{fill:#000}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-menu,.aplayer .aplayer-info .aplayer-controller .aplayer-time.aplayer-time-narrow .aplayer-icon-menu,.aplayer .aplayer-info .aplayer-controller .aplayer-time.aplayer-time-narrow .aplayer-icon-mode{display:none}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap{position:relative;display:inline-block;margin-left:3px;cursor:pointer!important}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap:hover .aplayer-volume-bar-wrap{height:40px}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap{position:absolute;bottom:15px;right:-3px;width:25px;height:0;z-index:99;overflow:hidden;transition:all .2s ease-in-out}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap.aplayer-volume-bar-wrap-active{height:40px}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap .aplayer-volume-bar{position:absolute;bottom:0;right:10px;width:5px;height:35px;background:#aaa;border-radius:2.5px;overflow:hidden}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap .aplayer-volume-bar .aplayer-volume{position:absolute;bottom:0;right:0;width:5px;transition:all .1s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-loading-icon{display:none}.aplayer .aplayer-info .aplayer-controller .aplayer-loading-icon svg{position:absolute;-webkit-animation:rotate 1s linear infinite;animation:rotate 1s linear infinite}.aplayer .aplayer-lrc{display:none;position:relative;height:30px;text-align:center;overflow:hidden;margin:-10px 0 7px}.aplayer .aplayer-lrc:before{top:0;height:10%;background:linear-gradient(180deg,#fff 0,hsla(0,0%,100%,0));filter:progid:DXImageTransform.Microsoft.gradient(startColorstr="#ffffff",endColorstr="#00ffffff",GradientType=0)}.aplayer .aplayer-lrc:after,.aplayer .aplayer-lrc:before{position:absolute;z-index:1;display:block;overflow:hidden;width:100%;content:" "}.aplayer .aplayer-lrc:after{bottom:0;height:33%;background:linear-gradient(180deg,hsla(0,0%,100%,0) 0,hsla(0,0%,100%,.8));filter:progid:DXImageTransform.Microsoft.gradient(startColorstr="#00ffffff",endColorstr="#ccffffff",GradientType=0)}.aplayer .aplayer-lrc p{font-size:12px;color:#666;line-height:16px!important;height:16px!important;padding:0!important;margin:0!important;transition:all .5s ease-out;opacity:.4;overflow:hidden}.aplayer .aplayer-lrc p.aplayer-lrc-current{opacity:1;overflow:visible;height:auto!important;min-height:16px}.aplayer .aplayer-lrc.aplayer-lrc-hide{display:none}.aplayer .aplayer-lrc .aplayer-lrc-contents{width:100%;transition:all .5s ease-out;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;cursor:default}.aplayer .aplayer-list{overflow:auto;transition:all .5s ease;will-change:height;display:none;overflow:hidden}.aplayer .aplayer-list.aplayer-list-hide{max-height:0!important}.aplayer .aplayer-list ol{list-style-type:none;margin:0;padding:0;overflow-y:auto}.aplayer .aplayer-list ol::-webkit-scrollbar{width:5px}.aplayer .aplayer-list ol::-webkit-scrollbar-thumb{border-radius:3px;background-color:#eee}.aplayer .aplayer-list ol::-webkit-scrollbar-thumb:hover{background-color:#ccc}.aplayer .aplayer-list ol li{position:relative;height:32px;line-height:32px;padding:0 15px;font-size:12px;border-top:1px solid #e9e9e9;cursor:pointer;transition:all .2s ease;overflow:hidden;margin:0}.aplayer .aplayer-list ol li:first-child{border-top:none}.aplayer .aplayer-list ol li:hover{background:#efefef}.aplayer .aplayer-list ol li.aplayer-list-light{background:#e9e9e9}.aplayer .aplayer-list ol li.aplayer-list-light .aplayer-list-cur{display:inline-block}.aplayer .aplayer-list ol li .aplayer-list-cur{display:none;width:3px;height:22px;position:absolute;left:0;top:5px;cursor:pointer}.aplayer .aplayer-list ol li .aplayer-list-index{color:#666;margin-right:12px;cursor:pointer}.aplayer .aplayer-list ol li .aplayer-list-author{color:#666;float:right;cursor:pointer}.aplayer .aplayer-notice{opacity:0;position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);font-size:12px;border-radius:4px;padding:5px 10px;transition:all .3s ease-in-out;overflow:hidden;color:#fff;pointer-events:none;background-color:#f4f4f5;color:#909399}.aplayer .aplayer-miniswitcher{display:none;position:absolute;top:0;right:0;bottom:0;height:100%;background:#e6e6e6;width:18px;border-radius:0 2px 2px 0}.aplayer .aplayer-miniswitcher .aplayer-icon{height:100%;width:100%;-webkit-transform:rotateY(180deg);transform:rotateY(180deg);transition:all .3s ease}.aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#666}.aplayer .aplayer-miniswitcher .aplayer-icon:hover path{fill:#000}@-webkit-keyframes aplayer-roll{0%{left:0}to{left:-100%}}@keyframes aplayer-roll{0%{left:0}to{left:-100%}}@-webkit-keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}

/*# sourceMappingURL=APlayer.min.css.map*/@font-face {
  font-family: 'LXGWMarkerGothic';
  src: url('https://cdn.jsdelivr.net/gh/fan0530/fonts/LXGWMarkerGothic-Regular.ttf');
}
html,
body {
  height: 100%;
  padding: 0;
  margin: 0;
}
body {
  background-color: #ffd448;
  display: flex;
  justify-content: center;
}
#app {
  font-family: 'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  width: 100%;
  height: 100%;
  box-sizing: border-box;
}
main {
  height: 100%;
  overflow: hidden;
  background-color: #fff;
}
.custom-scrollbar::-webkit-scrollbar {
  width: 6px;
  height: 6px;
  background-color: transparent;
}
.custom-scrollbar:hover::-webkit-scrollbar-thumb {
  background-color: rgba(69, 90, 100, 0.2);
}
.custom-scrollbar::-webkit-scrollbar-thumb {
  background-color: transparent;
  border-radius: 6px;
}
@media screen and (min-width: 700px) {
#app {
    width: 700px;
    padding: 20px 0px;
    min-height: calc(100% - 40px);
}
main {
    border-radius: 4px;
}
}
.custom-popup {
  width: 100% !important;
  max-width: none;
  min-width: none;
}
@media screen and (min-width: 500px) {
.custom-popup {
    width: 52% !important;
    max-width: 800px;
    min-width: 500px;
}
}
 *,::before,::after{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}::backdrop{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}.container{width:100%;}.center{display:flex;align-items:center;justify-content:center;}@media (min-width: 640px){.container{max-width:640px;}}@media (min-width: 768px){.container{max-width:768px;}}@media (min-width: 1024px){.container{max-width:1024px;}}@media (min-width: 1280px){.container{max-width:1280px;}}@media (min-width: 1536px){.container{max-width:1536px;}}.absolute{position:absolute;}.fixed{position:fixed;}.relative{position:relative;}.left-0{left:0;}.top-0{top:0;}.z-3{z-index:3;}.m-0{margin:0;}.mx-16px{margin-left:16px;margin-right:16px;}.mb-16px{margin-bottom:16px;}.ml-10px{margin-left:10px;}.ml-15px{margin-left:15px;}.ml-6px{margin-left:6px;}.mr-10px{margin-right:10px;}.mr-6px{margin-right:6px;}.mt-16px{margin-top:16px;}.mt-4px{margin-top:4px;}.mt-8px{margin-top:8px;}.box-border{box-sizing:border-box;}.block{display:block;}.hidden{display:none;}.h-100\%,.h-full{height:100%;}.h-120px{height:120px;}.h-40px{height:40px;}.h-6px{height:6px;}.h-70\%{height:70%;}.h-85\%{height:85%;}.h4{height:1rem;}.w-100px{width:100px;}.w-6px{width:6px;}.w-full{width:100%;}.flex{display:flex;}.flex-1{flex:1 1 0%;}.flex-col{flex-direction:column;}.resize{resize:both;}.items-center{align-items:center;}.self-center{align-self:center;}.justify-between{justify-content:space-between;}.overflow-y-auto{overflow-y:auto;}.truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}.border{border-width:1px;}.rounded-6px{border-radius:6px;}.bg-\#4ddd4c{--un-bg-opacity:1;background-color:rgb(77 221 76 / var(--un-bg-opacity));}.p-16px{padding:16px;}.px{padding-left:1rem;padding-right:1rem;}.px-15px{padding-left:15px;padding-right:15px;}.px-16px{padding-left:16px;padding-right:16px;}.py-10px{padding-top:10px;padding-bottom:10px;}.text-13px{font-size:13px;}.text-14px{font-size:14px;}.text-16px{font-size:16px;}.text-24px{font-size:24px;}.text-\#333{--un-text-opacity:1;color:rgb(51 51 51 / var(--un-text-opacity));}.text-\#666{--un-text-opacity:1;color:rgb(102 102 102 / var(--un-text-opacity));}.text-\#999{--un-text-opacity:1;color:rgb(153 153 153 / var(--un-text-opacity));}.antialiased{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}.text-shadow{--un-text-shadow:0 0 1px var(--un-text-shadow-color, rgb(0 0 0 / 0.2)),0 0 1px var(--un-text-shadow-color, rgb(1 0 5 / 0.1));text-shadow:var(--un-text-shadow);}.outline{outline-style:solid;}.grayscale{--un-grayscale:grayscale(1);filter:var(--un-blur) var(--un-brightness) var(--un-contrast) var(--un-drop-shadow) var(--un-grayscale) var(--un-hue-rotate) var(--un-invert) var(--un-saturate) var(--un-sepia);}.filter{filter:var(--un-blur) var(--un-brightness) var(--un-contrast) var(--un-drop-shadow) var(--un-grayscale) var(--un-hue-rotate) var(--un-invert) var(--un-saturate) var(--un-sepia);}.backdrop-filter{-webkit-backdrop-filter:var(--un-backdrop-blur) var(--un-backdrop-brightness) var(--un-backdrop-contrast) var(--un-backdrop-grayscale) var(--un-backdrop-hue-rotate) var(--un-backdrop-invert) var(--un-backdrop-opacity) var(--un-backdrop-saturate) var(--un-backdrop-sepia);backdrop-filter:var(--un-backdrop-blur) var(--un-backdrop-brightness) var(--un-backdrop-contrast) var(--un-backdrop-grayscale) var(--un-backdrop-hue-rotate) var(--un-backdrop-invert) var(--un-backdrop-opacity) var(--un-backdrop-saturate) var(--un-backdrop-sepia);} 
</style>
  </head>
  <body>
    <div id="app"></div>
  </body>
</html>
